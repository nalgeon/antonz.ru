<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Антон Жиянов</title><description>Разработка софта, продуктоводство и здравый смысл</description><link>https://antonz.ru/</link><image><url>https://antonz.ru/assets/favicon/favicon.png</url><title>Антон Жиянов</title><link>https://antonz.ru/</link></image><generator>Hugo -- gohugo.io</generator><language>ru-ru</language><lastBuildDate>Wed, 12 Jan 2022 15:15:00 +0000</lastBuildDate><atom:link href="https://antonz.ru/index.xml" rel="self" type="application/rss+xml"/><item><title>Гибкие типы данных в SQLite</title><link>https://antonz.ru/sqlite-types/</link><pubDate>Wed, 12 Jan 2022 15:15:00 +0000</pubDate><guid>https://antonz.ru/sqlite-types/</guid><description>Почему sqlite называют «джаваскриптом в мире баз данных».</description><content:encoded><![CDATA[<p>Люди часто не понимают, что за ерунда происходит в SQLite с типами данных. Давайте разберемся.</p>
<p>SQLite использует пять типов:</p>
<ul>
<li><code>INTEGER</code> — целые числа,</li>
<li><code>REAL</code> — действительные числа,</li>
<li><code>TEXT</code> — строки,</li>
<li><code>BLOB</code> — бинарные данные,</li>
<li><code>NULL</code> — пустое значение.</li>
</ul>
<p>Пока ничего необычного (только типов маловато по сравнению с другими СУБД).</p>
<p>А как вам такое:</p>
<blockquote>
<p>SQLite может хранить данные любого типа — вне зависимости от того, какой тип указан на столбце.</p>
</blockquote>
<p>Хотите записать число <code>3.14</code> в integer-поле? Пожалуйста (и никакого округления). Или, может быть, <code>'привет'</code> в поле типа real? Без проблем.</p>
<p>Дело в том, что SQLite хранит тип не только на столбце, но и на каждом значении в таблице. Именно поэтому в одном столбце без проблем хранятся значения разных типов. Тип на столбце используется как рекомендация: при вставке SQLite пытается привести значение к рекомендуемому типу, но если не получилось — сохраняет «как есть».</p>
<p>Это удобно для анализа данных — можно сначала все загрузить, а потом средствами SQL разбираться с проблемными значениями. Любая другая СУБД выдаст ошибку при импорте и заставит вас «шерстить» файл скриптами или вручную.</p>
<p>С другой стороны, это неожиданное поведение, за которое многие недолюбливают SQLite и даже прозвали его «JavaScript в мире баз данных». Со временем разработчики SQLite прислушались и сделали альтернативный механизм «строгих» таблиц — но о нем в другой раз.</p>
<div class="row">
<div class="col-xs-12 col-sm-10 col-md-8"><p><em>И подписывайтесь на канал <span class="nowrap"><i class="fas fa-database"></i> «<a href="https://t.me/sqliter">SQLite на практике</a>»</span></em></p></div>
</div>
]]></content:encoded></item><item><title>Все расширения для SQLite</title><link>https://antonz.ru/sqlean/</link><pubDate>Tue, 04 Jan 2022 11:30:00 +0000</pubDate><guid>https://antonz.ru/sqlean/</guid><description>Регулярки, статистика, файлы и еще 100+ функций.</description><content:encoded><![CDATA[<p>Мне очень нравится SQLite. Это миниатюрная встраиваемая база, которая отлично подходит как для исследовательского анализа данных, так и в качестве хранилища для небольших приложений (<a href="https://habr.com/ru/post/547448/">писал об этом</a>, не буду повторяться).</p>
<p>Но есть у нее один недостаток: маловато встроенных функций по сравнению с PostgreSQL или Oracle. К счастью, авторы заложили в SQLite механизм расширений, на котором можно сделать почти все что угодно. В результате интернет заполнен обрывочными расширениями, которые добавляют функцию-другую.</p>
<p>Мне хотелось большой системности. В результате появился проект <strong>sqlean</strong> — в нем я собираю вместе недостающие в SQLite функции, распределяю их по модулям, рефакторю код, пишу тесты и документацию. Получается что-то вроде стандартной библиотеки, как в Python или Go, только для SQLite.</p>
<p>Я планирую подробно написать про каждый модуль в отдельной статье, а пока — вот краткий обзор.</p>
<h2 id="основной-набор">Основной набор</h2>
<p>Это самые популярные функции, которых не хватало в SQLite:</p>
<ul>
<li><a href="https://github.com/nalgeon/sqlean/blob/main/docs/crypto.md">crypto</a>: криптографические хеш-функции вроде MD5, SHA-1 и SHA-256.</li>
<li><a href="https://github.com/nalgeon/sqlean/blob/main/docs/fileio.md">fileio</a>: работа с файловой системой — чтение и запись файлов, создание каталогов.</li>
<li><a href="https://github.com/nalgeon/sqlean/blob/main/docs/fuzzy.md">fuzzy</a>: нечеткое сравнение строк, фонетические алгоритмы, транслитерация.</li>
<li><a href="https://github.com/nalgeon/sqlean/blob/main/docs/ipaddr.md">ipaddr</a>: манипуляция IP-адресами и подсетями.</li>
<li><a href="https://github.com/nalgeon/sqlean/blob/main/docs/json1.md">json1</a>: работа с JSON.</li>
<li><a href="https://github.com/nalgeon/sqlean/blob/main/docs/math.md">math</a>: математические функции.</li>
<li><a href="https://github.com/nalgeon/sqlean/blob/main/docs/re.md">re</a>: регулярные выражения.</li>
<li><a href="https://github.com/nalgeon/sqlean/blob/main/docs/stats.md">stats</a>: статистика — медиана, процентили, стандартное отклонение.</li>
<li><a href="https://github.com/nalgeon/sqlean/blob/main/docs/text.md">text</a>: работа со строками.</li>
<li><a href="https://github.com/nalgeon/sqlean/blob/main/docs/unicode.md">unicode</a>: поддержка юникода для функций <code>upper()</code>, <code>lower()</code> и <code>LIKE</code>.</li>
<li><a href="https://github.com/nalgeon/sqlean/blob/main/docs/uuid.md">uuid</a>: генерация уникальных идентификаторов.</li>
<li><a href="https://github.com/nalgeon/sqlean/blob/main/docs/vsv.md">vsv</a>: работа с CSV-файлами как с таблицами базы.</li>
</ul>
<p>Все расширения можно <a href="https://github.com/nalgeon/sqlean/releases/latest">скачать</a> для Windows, Linix и macOS.</p>
<h2 id="инкубатор">Инкубатор</h2>
<p>Функции, которые пока не вошли в основной набор. Эти расширения могут быть плохо структурированы, но я их постепенно рефакторю и переношу в основные.</p>
<ul>
<li><a href="https://github.com/nalgeon/sqlean/issues/27#issuecomment-1004109889">array</a>: работа с массивами (почти как в постгресе).</li>
<li><a href="https://github.com/nalgeon/sqlean/issues/27#issuecomment-999732640">besttype</a>: преобразует строку в подходящий числовой тип.</li>
<li><a href="https://github.com/nalgeon/sqlean/issues/27#issuecomment-1002267134">bloom</a>: быстрый вероятностный способ понять, есть значение в таблице или нет.</li>
<li><a href="https://github.com/nalgeon/sqlean/issues/27#issuecomment-996605444">cbrt</a>: кубический корень из числа.</li>
<li><a href="https://github.com/nalgeon/sqlean/issues/27#issuecomment-1001239676">classifier</a>: бинарный классификатор на логистической регрессии.</li>
<li><a href="https://github.com/nalgeon/sqlean/issues/27#issuecomment-1000937999">compress</a> и <a href="https://github.com/nalgeon/sqlean/issues/27#issuecomment-1000938046">sqlar</a>: архивация и распаковка данных.</li>
<li><a href="https://github.com/nalgeon/sqlean/issues/27#issuecomment-997427979">cron</a>: проверяет даты по cron-шаблонам.</li>
<li><a href="https://github.com/nalgeon/sqlean/issues/27#issuecomment-1004347222">define</a>: динамически создает скалярные и табличные функции прямо из SQL.</li>
<li><a href="https://github.com/nalgeon/sqlean/issues/27#issuecomment-997423609">envfuncs</a>: читает переменные среды.</li>
<li><a href="https://github.com/nalgeon/sqlean/issues/27#issuecomment-996432840">eval</a>: выполняет произвольные SQL-запросы.</li>
<li><a href="https://github.com/nalgeon/sqlean/issues/27#issuecomment-997482625">fcmp</a>: сравнение и округление десятичных дробей.</li>
<li><a href="https://github.com/nalgeon/sqlean/issues/27#issuecomment-998138191">isodate</a>: дополнительные функции для работы с датами.</li>
<li><a href="https://github.com/nalgeon/sqlean/issues/27#issuecomment-999128539">math2</a>: больше математических функций и битовой арифметики.</li>
<li><a href="https://github.com/nalgeon/sqlean/issues/27#issuecomment-997417836">pearson</a>: корреляция Пирсона между двумя наборами данных.</li>
<li><a href="https://github.com/nalgeon/sqlean/issues/27#issuecomment-997052157">pivotvtab</a>: сводные таблицы.</li>
<li><a href="https://github.com/nalgeon/sqlean/issues/27#issuecomment-999732907">recsize</a>: считает размер записи в таблице.</li>
<li><a href="https://github.com/nalgeon/sqlean/issues/27#issuecomment-1002297477">spellfix</a>: быстрый поиск похожих слов в словаре.</li>
<li><a href="https://github.com/nalgeon/sqlean/issues/27#issuecomment-1000902666">stats2</a> и <a href="https://github.com/nalgeon/sqlean/issues/27#issuecomment-1002703581">stats3</a>: еще больше матстатистики.</li>
<li><a href="https://github.com/nalgeon/sqlean/issues/27#issuecomment-1003105288">text2</a>: еще больше функций для работы со строками.</li>
<li><a href="https://github.com/nalgeon/sqlean/issues/27#issuecomment-1001232670">uint</a>: натуральная сортировка и сравнение строк, содержащих числа (natsort).</li>
<li><a href="https://github.com/nalgeon/sqlean/issues/27#issuecomment-997432989">unhex</a>: преобразует строку в бинарные данные (обратная операция для <code>hex()</code>).</li>
<li><a href="https://github.com/nalgeon/sqlean/issues/27#issuecomment-997018486">xmltojson</a>: преобразует XML в JSON.</li>
<li><a href="https://github.com/nalgeon/sqlean/issues/27#issuecomment-1001190336">zipfile</a>: читает и пишет zip-архивы.</li>
</ul>
<p><a href="https://github.com/nalgeon/sqlean/issues/27">Голосуйте</a> за расширения в инкубаторе! Чем популярнее расширение, тем быстрее оно попадет в основной набор.</p>
<p>Инкубаторные расширения тоже можно <a href="https://github.com/nalgeon/sqlean/releases/tag/incubator">скачать</a>.</p>
<h2 id="как-подключить-расширение">Как подключить расширение</h2>
<p>Есть три способа. Если работаете с командной строкой SQLite (<code>sqlite.exe</code>):</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#000">sqlite</span><span style="color:#000">&gt;</span> .<span style="color:#a90d91">load</span> .<span style="color:#000">/</span><span style="color:#000">stats</span>
<span style="color:#000">sqlite</span><span style="color:#000">&gt;</span> <span style="color:#a90d91">select</span> <span style="color:#000">median</span>(<span style="color:#000">value</span>) <span style="color:#a90d91">from</span> <span style="color:#000">generate_series</span>(<span style="color:#1c01ce">1</span>, <span style="color:#1c01ce">99</span>);
</code></pre></div><p>Если используете инструмент вроде DB Browser for SQLite, SQLite Expert или DBeaver:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#a90d91">select</span> <span style="color:#000">load_extension</span>(<span style="color:#c41a16">&#39;c:\Users\anton\sqlite\stats.dll&#39;</span>);
<span style="color:#a90d91">select</span> <span style="color:#000">median</span>(<span style="color:#000">value</span>) <span style="color:#a90d91">from</span> <span style="color:#000">generate_series</span>(<span style="color:#1c01ce">1</span>, <span style="color:#1c01ce">99</span>);
</code></pre></div><p>Если работаете из Python (в других языках аналогично):</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#a90d91">import</span> <span style="color:#000">sqlite3</span>

<span style="color:#000">connection</span> <span style="color:#000">=</span> <span style="color:#000">sqlite3</span><span style="color:#000">.</span><span style="color:#000">connect</span>(<span style="color:#c41a16">&#34;:memory:&#34;</span>)
<span style="color:#000">connection</span><span style="color:#000">.</span><span style="color:#000">enable_load_extension</span>(<span style="color:#a90d91">True</span>)
<span style="color:#000">connection</span><span style="color:#000">.</span><span style="color:#000">load_extension</span>(<span style="color:#c41a16">&#34;./stats.so&#34;</span>)
<span style="color:#000">connection</span><span style="color:#000">.</span><span style="color:#000">execute</span>(<span style="color:#c41a16">&#34;select median(value) from generate_series(1, 99)&#34;</span>)
<span style="color:#000">connection</span><span style="color:#000">.</span><span style="color:#000">close</span>()
</code></pre></div><h2 id="что-дальше">Что дальше</h2>
<p>Если почувствуете, что в SQLite вам не хватает какой-то функции — приходите в репозиторий <a href="https://github.com/nalgeon/sqlean"><strong>sqlean</strong></a>, там наверняка найдется.</p>
<p>Я продолжаю добавлять новые расширения в инкубатор, а расширения из инкубатора рефакторю и переношу в основные. По каждому основному модулю планирую написать отдельную статью с примерами.</p>
<p>А если захотите поучаствовать — присылайте <a href="https://github.com/nalgeon/sqlean/blob/incubator/docs/submit.md">свои</a> или <a href="https://github.com/nalgeon/sqlean/blob/incubator/docs/external.md">чужие</a> расширения.</p>
<p>Всем SQLite!</p>
]]></content:encoded></item><item><title>Быстрый поиск похожих слов на SQL</title><link>https://antonz.ru/similar-words/</link><pubDate>Thu, 02 Dec 2021 13:30:00 +0000</pubDate><guid>https://antonz.ru/similar-words/</guid><description>Фонетика, расстояния и никакого LIKE.</description><content:encoded><![CDATA[<p><em>В этой статье разберемся, как быстро найти похожее слово в огромном словаре. Сначала рассмотрим наивное решение, потом сконструируем быстрое, а в конце посмотрим на готовое.</em></p>
<p>Предположим, мы хотим исправлять опечатки в поисковых запросах или сообщениях чата. Человек вводит «а<span class="color-red">б</span>р<span class="color-red">и</span>виатура», мы исправляем на «аббревиатура», «ра<span class="color-red">сс</span>чет» → «расчет», «доро<span class="color-red">аг</span>» → «дорога». Посмотрим, как решить такую задачу на SQL.</p>
<p>Я буду использовать SQLite. Но аналогичный подход сработает с любой СУБД или языком программирования (если интересно — дайте знать, сделаю примеры на Python).</p>
<h2 id="dictinary">1. Собираем словарь</h2>
<p>Воспользуемся списком русских слов во всех морфологических формах из репозитория <a href="https://github.com/danakt/russian-words">russian-words</a>. Скачаем и сконвертируем в UTF-8:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ wget https://github.com/danakt/russian-words/raw/master/russian.txt
$ iconv -f cp1251 russian.txt &gt; russian.utf.csv
</code></pre></div><p>Загрузим в таблицу <code>words</code>:</p>
<pre tabindex="0"><code>$ sqlite3 dictionary.db
sqlite&gt; create table words(word text);
sqlite&gt; .mode csv
sqlite&gt; .import russian.utf.csv words
sqlite&gt; create unique index words_idx on words(word);
sqlite&gt; select count(*) from words;
1532629
</code></pre><p>Словарь из 1.5 млн слов готов.</p>
<p>Когда человек ввел какое-то слово («абривиатура») — несложно проверить, есть ли оно в словаре:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#a90d91">select</span> <span style="color:#1c01ce">1</span> <span style="color:#a90d91">from</span> <span style="color:#000">words</span> <span style="color:#a90d91">where</span> <span style="color:#000">word</span> <span style="color:#000">=</span> <span style="color:#c41a16">&#39;абривиатура&#39;</span>;
<span style="color:#177500">-- &lt;пусто&gt;
</span></code></pre></div><p>Раз варианта в словаре нет — в слове наверняка опечатка. Чтобы предложить исправление, придется найти максимальное похожее слово в <code>words</code>.</p>
<h2 id="distance">2. Определяем похожесть слов</h2>
<p>Человеку интуитивно понятно, что такое «похожее» или «непохожее» слово, но машине нужен формальный критерий.</p>
<p>Идеально, если бы мы умели измерять <em>расстояние</em> между словами. Функция расстояния принимает на входе два слова и возвращает некоторое число <code>D</code>, которое характеризует похожесть:</p>
<pre tabindex="0"><code>distance(w1, w1) = x
</code></pre><p>Чем меньше <code>D</code>, тем более похожи слова.</p>
<p>Приятно, что специалисты по компьютерным наукам уже придумали великое множество таких функций. Наиболее известная из них — <em>расстояние Левенштейна</em>. Она измеряет, сколько букв надо удалить, добавить или заменить, чтобы перейти от слова <code>w1</code> к слову <code>w2</code>:</p>
<div class="row">
<div class="col-xs-12 col-sm-6">
<figure>
  <img class="img-bordered-thin" alt="Расстояние Левенштейна" src="distance.jpg">
</figure>
</div>
<div class="col-xs-12 col-sm-6">
<p class="figcaption">Расстояние Левенштейна считает количество элементарных замен, которыми можно превратить одно слово в другое.</p>
</div>
</div>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#177500"># одна операция: удалить лишнюю С</span>
<span style="color:#000">levenshtein</span>(<span style="color:#c41a16">&#34;рассчет&#34;</span>, <span style="color:#c41a16">&#34;расчет&#34;</span>) <span style="color:#000">=</span> <span style="color:#1c01ce">1</span>

<span style="color:#177500"># одна операция: добавить недостающую лишнюю Л</span>
<span style="color:#000">levenshtein</span>(<span style="color:#c41a16">&#34;сонце&#34;</span>, <span style="color:#c41a16">&#34;солнце&#34;</span>) <span style="color:#000">=</span> <span style="color:#1c01ce">1</span>

<span style="color:#177500"># две операции: заменить А→Г, заменить Г→А</span>
<span style="color:#000">levenshtein</span>(<span style="color:#c41a16">&#34;дороаг&#34;</span>, <span style="color:#c41a16">&#34;дорога&#34;</span>) <span style="color:#000">=</span> <span style="color:#1c01ce">2</span>
</code></pre></div><p>Пример с «дороаг» → «дорога» может показаться странным: очевидно же, что достаточно переставить буквы местами. Перестановка — одна операция, и расстояние должно быть 1, а не 2. Алгоритм Левенштейна не учитывает такие случаи, поэтому создали улучшенную и дополненную версию — <em>расстояние Дамерау-Левенштейна</em>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#000">dlevenshtein</span>(<span style="color:#c41a16">&#34;дороаг&#34;</span>, <span style="color:#c41a16">&#34;дорога&#34;</span>) <span style="color:#000">=</span> <span style="color:#1c01ce">1</span>
</code></pre></div><p>Его и будем использовать.</p>
<div class="boxed">
<h3>Считаем расстояние в SQLite</h3>
<p>В стандартную поставку SQLite расстояния не входят. Поэтому будем использовать расширение <a href="https://github.com/nalgeon/sqlean/blob/main/docs/fuzzy.md">fuzzy</a>, в котором есть все необходимое:</p>
<pre><code>-- в консоли sqlite
.load ./fuzzy<br>
-- или через select
select load_extension('./fuzzy');
</code></pre>
<p>Расширение умеет работать только с ASCII-строками (латиницей), так что русские слова придется предварительно транслитерировать (перевести в латиницу) функцией <code>translit</code>:</p>
<pre><code>select translit('дорога');
-- doroga<br>
select translit('дороаг');
-- doroag<br>
select dlevenshtein(
  translit('дорога'),
  translit('дороаг')
);
-- 1</code></pre>
</div>
<h2 id="search-distance">3. Ищем похожее слово в словаре</h2>
<p>Чтобы исправить опечатку в слове, достаточно посчитать расстояние от него до каждого слова в словаре и выбрать слово с минимальным расстоянием.</p>
<div class="row">
<div class="col-xs-12 col-sm-6">
<figure>
  <img class="img-bordered-thin" alt="Поиск по расстоянию" src="search-distance.jpg">
</figure>
</div>
<div class="col-xs-12 col-sm-6">
<p class="figcaption">Считаем расстояния между словом с опечаткой и остальными словами → получаем набор расстояний. Выбираем минимальное → получаем слово с исправленной опечаткой.</p>
<p class="figcaption">Отличный был бы алгоритм, если бы не сортировал каждый раз полтора миллиона слов.</p>
</div>
</div>
<p>На SQL:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#a90d91">select</span>
  <span style="color:#000">word</span>,
  <span style="color:#000">dlevenshtein</span>(
    <span style="color:#000">translit</span>(<span style="color:#c41a16">&#39;абривиатура&#39;</span>),
    <span style="color:#000">translit</span>(<span style="color:#000">word</span>)
  ) <span style="color:#a90d91">as</span> <span style="color:#000">distance</span>
<span style="color:#a90d91">from</span> <span style="color:#000">words</span>
<span style="color:#a90d91">order</span> <span style="color:#a90d91">by</span> <span style="color:#000">distance</span>
<span style="color:#a90d91">limit</span> <span style="color:#1c01ce">1</span>;
</code></pre></div><pre tabindex="0"><code>┌──────────────┬──────────┐
│     word     │ distance │
├──────────────┼──────────┤
│ аббревиатура │ 2        │
└──────────────┴──────────┘
Run Time: real 8.145 user 8.055009 sys 0.051747
</code></pre><p>Отлично работает! Одна проблема: расчет занимает 8 секунд. Для исправления опечаток в онлайне не подходит. Нам желательно уложиться в 50–200 мс, чтобы для человека выглядело мгновенным. Исправим это.</p>
<h2 id="phonetics">4. Фонетическое кодирование</h2>
<p>Проблема с расстоянием в том, что его нельзя посчитать заранее — мы же не знаем, какое слово введет человек. Здесь поможет <em>фонетическое кодирование</em>:</p>
<div class="row">
<div class="col-xs-12 col-sm-6">
<figure>
  <img class="img-bordered-thin" alt="Фонетический алгоритм" src="phonetics.jpg">
</figure>
</div>
<div class="col-xs-12 col-sm-6">
<p class="figcaption">Фонетический алгоритм превращает произвольное слово (<code>солнце</code>) в <em>фонетический код</em> (<code>SNTK</code>). При этом созвучные слова получают одинаковые коды, а несозвучные — разные.</p>
</div>
</div>
<p>Теперь мы можем обойтись без расстояния вообще:</p>
<ol>
<li>Заранее посчитать код для каждого слова в словаре.</li>
<li>Посчитать код для слова с опечаткой, которое ввел человек.</li>
<li>Найти слово в словаре по этому коду — это и будет правильный вариант.</li>
</ol>
<div class="row">
<div class="col-xs-12 col-sm-6">
<figure>
  <img class="img-bordered-thin" alt="Поиск по фонетике" src="search-phonetics.jpg">
</figure>
</div>
<div class="col-xs-12 col-sm-6">
<p class="figcaption">Работать должно моментально, потому что по столбцу с кодами можно построить индекс, и искать по нему.</p>
</div>
</div>
<p>Попробуем использовать фонетическое кодирование для исправления опечаток.</p>
<h2 id="search-phonetics">5. Ищем по фонетике</h2>
<p>Фонетические алгоритмы придумывали для английского языка, и на русском они не работают. Нам придется прибегнуть к трюку с транслитерацией.</p>
<p>У транслитерированных слов фонетика сильно отличается от «родной» английской, поэтому многие фонетические алгоритмы плохо работает с транслитом. Мы возьмем функцию <code>caverphone</code> — она на удивление недурна, несмотря на австралийское происхождение:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#000">caverphone</span>(<span style="color:#000">translit</span>(<span style="color:#c41a16">&#34;рассчет&#34;</span>)) <span style="color:#000">=</span> <span style="color:#c41a16">&#34;RSKT111111&#34;</span>
<span style="color:#000">caverphone</span>(<span style="color:#000">translit</span>(<span style="color:#c41a16">&#34;расчет&#34;</span>))  <span style="color:#000">=</span> <span style="color:#c41a16">&#34;RSKT111111&#34;</span>

<span style="color:#000">caverphone</span>(<span style="color:#000">translit</span>(<span style="color:#c41a16">&#34;сонце&#34;</span>))  <span style="color:#000">=</span> <span style="color:#c41a16">&#34;SNTK111111&#34;</span>
<span style="color:#000">caverphone</span>(<span style="color:#000">translit</span>(<span style="color:#c41a16">&#34;солнце&#34;</span>)) <span style="color:#000">=</span> <span style="color:#c41a16">&#34;SNTK111111&#34;</span>

<span style="color:#000">caverphone</span>(<span style="color:#000">translit</span>(<span style="color:#c41a16">&#34;абривиатура&#34;</span>))  <span style="color:#000">=</span> <span style="color:#c41a16">&#34;APRFTRA111&#34;</span>
<span style="color:#000">caverphone</span>(<span style="color:#000">translit</span>(<span style="color:#c41a16">&#34;аббревиатура&#34;</span>)) <span style="color:#000">=</span> <span style="color:#c41a16">&#34;APRFTRA111&#34;</span>
</code></pre></div><p>Рассчитаем коды для слов из словаря и построим индекс:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#a90d91">alter</span> <span style="color:#a90d91">table</span> <span style="color:#000">words</span> <span style="color:#a90d91">add</span> <span style="color:#a90d91">column</span> <span style="color:#000">hash</span> <span style="color:#a90d91">text</span>;
<span style="color:#a90d91">update</span> <span style="color:#000">words</span> <span style="color:#a90d91">set</span> <span style="color:#000">hash</span> <span style="color:#000">=</span> <span style="color:#000">caverphone</span>(<span style="color:#000">translit</span>(<span style="color:#000">word</span>));
<span style="color:#a90d91">create</span> <span style="color:#a90d91">index</span> <span style="color:#000">words_hash_idx</span> <span style="color:#a90d91">on</span> <span style="color:#000">words</span>(<span style="color:#000">hash</span>);
</code></pre></div><p>Исправим опечатку в слове <code>абривиатура</code>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#a90d91">select</span> <span style="color:#000">word</span>
<span style="color:#a90d91">from</span> <span style="color:#000">words</span>
<span style="color:#a90d91">where</span> <span style="color:#000">hash</span> <span style="color:#000">=</span> <span style="color:#000">caverphone</span>(<span style="color:#000">translit</span>(<span style="color:#c41a16">&#39;абривиатура&#39;</span>))
<span style="color:#a90d91">limit</span> <span style="color:#1c01ce">3</span>;
</code></pre></div><pre tabindex="0"><code>┌───────────────┐
│     word      │
├───────────────┤
│ аббревиатура  │
│ аббревиатурой │
│ аббревиатурою │
└───────────────┘
Run Time: real 0.002 user 0.000130 sys 0.000391
</code></pre><p>Замечательно! Запрос выполнился мгновенно и вернул подходящие слова из словаря.</p>
<h2 id="search-combined">6. Ищем по фонетике и расстоянию</h2>
<p>Как удачно все получилось с «аббревиатурой». Проверим на «расчете»:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#a90d91">select</span> <span style="color:#000">word</span>
<span style="color:#a90d91">from</span> <span style="color:#000">words</span>
<span style="color:#a90d91">where</span> <span style="color:#000">hash</span> <span style="color:#000">=</span> <span style="color:#000">caverphone</span>(<span style="color:#000">translit</span>(<span style="color:#c41a16">&#39;рассчет&#39;</span>))
<span style="color:#a90d91">limit</span> <span style="color:#1c01ce">3</span>;
</code></pre></div><pre tabindex="0"><code>┌────────────┐
│    word    │
├────────────┤
│ разжигает  │
│ разжигаете │
│ разжигайте │
└────────────┘
</code></pre><p>Эээ. Совсем не то, чего мы ожидали. Проблема в том, что у «расчета» фонетически похожих слов довольно много:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#a90d91">select</span> <span style="color:#a90d91">count</span>(<span style="color:#000">*</span>)
<span style="color:#a90d91">from</span> <span style="color:#000">words</span>
<span style="color:#a90d91">where</span> <span style="color:#000">hash</span> <span style="color:#000">=</span> <span style="color:#000">caverphone</span>(<span style="color:#000">translit</span>(<span style="color:#c41a16">&#39;рассчет&#39;</span>));
<span style="color:#177500">-- 50
</span></code></pre></div><p>Нам бы как-то найти среди этих пятидесяти самое похожее. Хорошо, что мы уже знаем как это сделать — с помощью расстояния Дамерау-Левенштейна! Будем выбирать слова-кандидаты по фонетическому коду, а наиболее подходящего из кандидатов — по расстоянию:</p>
<figure>
  <img class="img-bordered-thin" alt="Комбинированный поиск" src="search-combined.png">
  <figcaption>Транслитерируем слово, считаем фонетический код, затем ищем по нему кандидатов и выбираем ближайшего по расстоянияю.</figcaption>
</figure>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#177500">-- кандидаты по фонетическому коду
</span><span style="color:#177500"></span><span style="color:#a90d91">with</span> <span style="color:#000">candidates</span> <span style="color:#a90d91">as</span> (
  <span style="color:#a90d91">select</span> <span style="color:#000">word</span>
  <span style="color:#a90d91">from</span> <span style="color:#000">words</span>
  <span style="color:#a90d91">where</span> <span style="color:#000">hash</span> <span style="color:#000">=</span> <span style="color:#000">caverphone</span>(<span style="color:#000">translit</span>(<span style="color:#c41a16">&#39;рассчет&#39;</span>))
)

<span style="color:#177500">-- выбираем кандидата с минимальным расстоянием
</span><span style="color:#177500"></span><span style="color:#a90d91">select</span>
  <span style="color:#000">word</span>,
  <span style="color:#000">dlevenshtein</span>(
    <span style="color:#000">translit</span>(<span style="color:#c41a16">&#39;рассчет&#39;</span>),
    <span style="color:#000">translit</span>(<span style="color:#000">word</span>)
  ) <span style="color:#a90d91">as</span> <span style="color:#000">distance</span>
<span style="color:#a90d91">from</span> <span style="color:#000">candidates</span>
<span style="color:#a90d91">order</span> <span style="color:#a90d91">by</span>
  <span style="color:#000">distance</span>,
  <span style="color:#a90d91">abs</span>(<span style="color:#a90d91">length</span>(<span style="color:#000">word</span>) <span style="color:#000">-</span> <span style="color:#a90d91">length</span>(<span style="color:#c41a16">&#39;рассчет&#39;</span>)),
  <span style="color:#a90d91">length</span>(<span style="color:#000">word</span>)
<span style="color:#a90d91">limit</span> <span style="color:#1c01ce">3</span>;
</code></pre></div><pre tabindex="0"><code>┌──────────┬──────────┐
│   word   │ distance │
├──────────┼──────────┤
│ расчет   │ 1        │
│ расчёт   │ 1        │
│ рассечет │ 1        │
└──────────┴──────────┘
Run Time: real 0.014 user 0.000729 sys 0.003712
</code></pre><p>То что надо! Поиск остался моментальным (благодаря выборке кандидатов по индексу), но стал точным (благодаря честному сравнению расстояния между кандидатами).</p>
<h2 id="other-typos">7. Учитываем нефонетические опечатки</h2>
<p>Все здорово в нашем походе. Кроме одного: не все опечатки фонетические. Если перепутать порядок букв в слове <code>дорога</code>, звучать слова будут совершенно по-разному:</p>
<pre tabindex="0"><code>дорога
дороаг
</code></pre><p>Фонетический алгоритм посчитает такие слова разными (и будет прав):</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#000">caverphone</span>(<span style="color:#c41a16">&#34;doroga&#34;</span>) <span style="color:#000">=</span> <span style="color:#c41a16">&#34;TRKA111111&#34;</span>
<span style="color:#000">caverphone</span>(<span style="color:#c41a16">&#34;doroag&#34;</span>) <span style="color:#000">=</span> <span style="color:#c41a16">&#34;TRK1111111&#34;</span>
</code></pre></div><p>В результате на нефонетических опечатках наш алгоритм будет работать плохо. Для <code>дороаг</code> вернет:</p>
<pre tabindex="0"><code>┌────────┬──────────┐
│  word  │ distance │
├────────┼──────────┤
│ дорог  │ 1        │
│ дороге │ 2        │
│ драг   │ 2        │
└────────┴──────────┘
</code></pre><p>Часть нефонетических опечаток можно исправить. Например, выбирать не по строгому равенству фонетических кодов, а по префиксу (первые 3 символа в данном случае):</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#177500">-- диапазон допустимых фонетических кодов
</span><span style="color:#177500"></span><span style="color:#a90d91">with</span> <span style="color:#000">bounds</span> <span style="color:#a90d91">as</span> (
  <span style="color:#a90d91">select</span>
    <span style="color:#000">substr</span>(<span style="color:#000">caverphone</span>(<span style="color:#000">translit</span>(<span style="color:#c41a16">&#39;дороаг&#39;</span>)), <span style="color:#1c01ce">1</span>, <span style="color:#1c01ce">3</span>) <span style="color:#000">||</span> <span style="color:#c41a16">&#39;1&#39;</span> <span style="color:#a90d91">as</span> <span style="color:#a90d91">left</span>,
    <span style="color:#000">substr</span>(<span style="color:#000">caverphone</span>(<span style="color:#000">translit</span>(<span style="color:#c41a16">&#39;дороаг&#39;</span>)), <span style="color:#1c01ce">1</span>, <span style="color:#1c01ce">3</span>) <span style="color:#000">||</span> <span style="color:#c41a16">&#39;Z&#39;</span> <span style="color:#a90d91">as</span> <span style="color:#a90d91">right</span>
),

<span style="color:#177500">-- кандидаты по фонетическому коду
</span><span style="color:#177500">-- из числа допустимых
</span><span style="color:#177500"></span><span style="color:#000">candidates</span> <span style="color:#a90d91">as</span> (
  <span style="color:#a90d91">select</span> <span style="color:#000">word</span>
  <span style="color:#a90d91">from</span> <span style="color:#000">words</span>, <span style="color:#000">bounds</span>
  <span style="color:#a90d91">where</span> <span style="color:#000">hash</span> <span style="color:#a90d91">between</span> <span style="color:#000">bounds</span>.<span style="color:#a90d91">left</span> <span style="color:#a90d91">and</span> <span style="color:#000">bounds</span>.<span style="color:#a90d91">right</span>
)

<span style="color:#177500">-- выбираем кандидата с минимальным расстоянием
</span><span style="color:#177500"></span><span style="color:#a90d91">select</span>
  <span style="color:#000">word</span>,
  <span style="color:#000">dlevenshtein</span>(<span style="color:#000">translit</span>(<span style="color:#c41a16">&#39;дороаг&#39;</span>), <span style="color:#000">translit</span>(<span style="color:#000">word</span>)) <span style="color:#a90d91">as</span> <span style="color:#000">distance</span>
<span style="color:#a90d91">from</span> <span style="color:#000">candidates</span>
<span style="color:#a90d91">order</span> <span style="color:#a90d91">by</span> <span style="color:#000">distance</span>, <span style="color:#a90d91">abs</span>(<span style="color:#a90d91">length</span>(<span style="color:#000">word</span>) <span style="color:#000">-</span> <span style="color:#a90d91">length</span>(<span style="color:#c41a16">&#39;дороаг&#39;</span>)), <span style="color:#a90d91">length</span>(<span style="color:#000">word</span>)
<span style="color:#a90d91">limit</span> <span style="color:#1c01ce">3</span>;
</code></pre></div><pre tabindex="0"><code>┌────────┬──────────┐
│  word  │ distance │
├────────┼──────────┤
│ дорога │ 1        │
│ дорог  │ 1        │
│ дороге │ 2        │
└────────┴──────────┘
Run Time: real 0.032 user 0.030312 sys 0.000339
</code></pre><p>Такой запрос находит на порядки больше кандидатов (6633 вместо 81 для «дороги»). Из-за этого он намного медленнее работает (хотя 32 мс — все еще очень быстро с точки зрения человека).</p>
<p>Префиксный подход не сработает, если опечатка в самом начале слова. Запрос по <code>одрога</code> не найдет слово <code>дорога</code>:</p>
<pre tabindex="0"><code>┌────────┬──────────┐
│  word  │ distance │
├────────┼──────────┤
│ отрога │ 1        │
│ отроге │ 2        │
│ отроги │ 2        │
└────────┴──────────┘
</code></pre><p>Хоть мой айфон такую опечатку тоже не исправляет, так что может и ничего.</p>
<h2 id="spellfix">8. Готовое решение для SQLite</h2>
<p>Теперь вы знаете, как быстро искать похожие слова в стиле «сделай сам». Описанный алгоритм можно реализовать в любой СУБД, где есть фонетические функции и функции расстояний. Но даже если в вашей базе их нет — то же самое можно сделать на Python, JS или C#, для которых уж точно найдутся подходящие библиотеки.</p>
<p>Если же работаете в SQLite — можно сэкономить время и воспользоваться готовым расширением <a href="https://github.com/nalgeon/sqlean/issues/27#issuecomment-1002297477">spellfix</a>. Под капотом у него фонетика + расстояния, как мы обсуждали, но внешний интерфейс сильно проще:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql">.<span style="color:#a90d91">load</span> .<span style="color:#000">/</span><span style="color:#000">spellfix</span>

<span style="color:#a90d91">create</span> <span style="color:#000">virtual</span> <span style="color:#a90d91">table</span> <span style="color:#a90d91">dictionary</span> <span style="color:#a90d91">using</span> <span style="color:#000">spellfix1</span>;

<span style="color:#a90d91">insert</span> <span style="color:#a90d91">into</span> <span style="color:#a90d91">dictionary</span>(<span style="color:#000">word</span>)
<span style="color:#a90d91">select</span> <span style="color:#000">word</span> <span style="color:#a90d91">from</span> <span style="color:#000">words</span>;

<span style="color:#a90d91">select</span> <span style="color:#000">word</span> <span style="color:#a90d91">from</span> <span style="color:#a90d91">dictionary</span>
<span style="color:#a90d91">where</span> <span style="color:#000">word</span> <span style="color:#a90d91">match</span> <span style="color:#c41a16">&#39;абривиатура&#39;</span>
<span style="color:#a90d91">limit</span> <span style="color:#1c01ce">1</span>;
</code></pre></div><pre tabindex="0"><code>┌──────────────┐
│     word     │
├──────────────┤
│ аббревиатура │
└──────────────┘
Run Time: real 0.182 user 0.112689 sys 0.014142
</code></pre><p>Работает медленнее и местами хуже, чем наше DIY-решение, зато гибче настраивается. Можно добавлять синонимы слов и тюнить расстояние — см. разделы «Dealing With Unusual And Difficult Spellings» и «Configurable Edit Distance» <a href="https://sqlite.org/spellfix1.html">в документации</a>.</p>
<h2 id="9-итоги">9. Итоги</h2>
<p>Теперь вы умеете:</p>
<ul>
<li>Считать расстояние между словами, чтобы понять, насколько они отличаются.</li>
<li>Использовать фонетические алгоритмы, чтобы искать созвучные слова.</li>
<li>Сочетать фонетику и расстояние, чтобы моментально находить похожие слова в миллионном словаре.</li>
</ul>
<p>Конечно, есть и альтернативные подходы к исправлению опечаток. Например:</p>
<ul>
<li>Для каждого слова из словаря заранее сгенерить возможные варианты опечаток и сохранить их в отдельной таблице. Словарь увеличится в десятки, если не сотни раз — зато не нужны фонетика и расстояния.</li>
<li>Обучить нейросеть предсказывать правильное слово по тому, что ввел человек. Заодно получится предиктивно предлагать варианты еще до того, как пользователь дописал слово — так работает ввод в айоси и андроиде.</li>
</ul>
<p>Но это уже совсем другая история ツ А фонетика и расстояния могут вам пригодиться.</p>
<div class="row">
<div class="col-xs-12 col-sm-10 col-md-8"><p><em>И подписывайтесь на канал <span class="nowrap"><i class="fas fa-database"></i> «<a href="https://t.me/sqliter">SQLite на практике</a>»</span></em></p></div>
</div>
]]></content:encoded></item><item><title>Датасет слов английского языка</title><link>https://antonz.ru/words-dataset/</link><pubDate>Wed, 01 Dec 2021 14:50:00 +0000</pubDate><guid>https://antonz.ru/words-dataset/</guid><description>Oxford 5000 и другие наборы с произношением.</description><content:encoded><![CDATA[<p>Обнаружил, что у Оксфордского университета есть списки распространенных слов и выражений английского языка. Доступны в традиционно «удобном» формате — html-амбразуре на сайте либо PDF.</p>
<p>Извлек их и сделал нормальные наборы данных в CSV. Например:</p>
<table>
<thead>
<tr>
<th>word</th>
<th>level</th>
<th>pos</th>
<th>definition_url</th>
<th>voice_url</th>
</tr>
</thead>
<tbody>
<tr>
<td>abandon</td>
<td>b2</td>
<td>verb</td>
<td><a href="https://www.oxfordlearnersdictionaries.com/definition/english/abandon_1">📄</a></td>
<td><a href="https://www.oxfordlearnersdictionaries.com/media/english/us_pron_ogg/a/aba/aband/abandon__us_2.ogg">🗣️</a></td>
</tr>
<tr>
<td>ability</td>
<td>a2</td>
<td>noun</td>
<td><a href="https://www.oxfordlearnersdictionaries.com/definition/english/ability_1">📄</a></td>
<td><a href="https://www.oxfordlearnersdictionaries.com/media/english/us_pron_ogg/a/abi/abili/ability__us_4.ogg">🗣️</a></td>
</tr>
<tr>
<td>able</td>
<td>a2</td>
<td>adjective</td>
<td><a href="https://www.oxfordlearnersdictionaries.com/definition/english/able_1">📄</a></td>
<td><a href="https://www.oxfordlearnersdictionaries.com/media/english/us_pron_ogg/a/abl/able_/able__us_2.ogg">🗣️</a></td>
</tr>
<tr>
<td>abolish</td>
<td>c1</td>
<td>verb</td>
<td><a href="https://www.oxfordlearnersdictionaries.com/definition/english/abolish">📄</a></td>
<td><a href="https://www.oxfordlearnersdictionaries.com/media/english/us_pron_ogg/a/abo/aboli/abolish__us_1.ogg">🗣️</a></td>
</tr>
<tr>
<td>и еще 5000 слов&hellip;</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Атрибутика:</p>
<ul>
<li><code>word</code> — слово</li>
<li><code>pos</code> — часть речи</li>
<li><code>level</code> — уровень (A1, A2, B1, B2, C1)</li>
<li><code>definition_url</code> — ссылка на подробное определение</li>
<li><code>voice_url</code> — ссылка на озвучку в ogg</li>
</ul>
<!-- <p class="big">
<a href="https://github.com/nalgeon/words">github.com/nalgeon/words</a>
</p> -->
<p>Посмотреть и скачать:<br>
<a href="https://github.com/nalgeon/words"><strong>github.com/nalgeon/words</strong></a></p>
<div class="row">
<div class="col-xs-12 col-sm-10 col-md-8"><p><em>Заметка из телеграм-канала <span class="nowrap"><i class="fas fa-database"></i> «<a href="https://t.me/sqliter">SQLite на практике</a>»</span></em></p></div>
</div>
]]></content:encoded></item><item><title>Что нового в SQLite 3.37</title><link>https://antonz.ru/sqlite-3-37/</link><pubDate>Sun, 28 Nov 2021 15:25:00 +0000</pubDate><guid>https://antonz.ru/sqlite-3-37/</guid><description>Строгие таблицы, any-тип и новая прагма.</description><content:encoded><![CDATA[<p>В отличие от <a href="/sqlite-3-35">3.35</a>, релиз 3.37 принес не так много изменений. Но среди них — одно из важнейших за всю историю: «строгий» режим таблиц, в котором движок следит, чтобы данные в столбце соответствовали типу.</p>
<p>Возможно, теперь SQLite перестанут называть «джаваскриптом в мире СУБД» ツ Но давайте по порядку.</p>
<p><a href="https://habr.com/ru/news/t/592085/">подробности на Хабре</a></p>
]]></content:encoded></item><item><title>Скорость алгоритмов и котики</title><link>https://antonz.ru/big-o/</link><pubDate>Thu, 25 Nov 2021 16:30:00 +0000</pubDate><guid>https://antonz.ru/big-o/</guid><description>Разбираем быстрые и медленные алгоритмы на шерстяных жопках.</description><content:encoded><![CDATA[<p>Давайте посмотрим, как программисты оценивают быстрые и медленные алгоритмы. Поскольку тема максимально занудная, разбираться будем на дурацких примерах с котиками.</p>
<h2 id="константное-время-o1">Константное время, O(1)</h2>
<p>Самый лучший вариант, скорость алгоритма не зависит от количества котиков.</p>
<div class="row">
<div class="col-xs-12 col-sm-6 flex">
<div class="boxed">
    <p><strong>🐾 Пример</strong></p>
    <p>Вы — счастливый обладатель <code>N</code> котиков. Каждый котик знает, как его зовут. Если позвать «Клёпа!», то прибежит только он, а остальным <code>N-1</code> жопкам пофиг.</p>
</div>
</div>
<div class="col-xs-12 col-sm-6">
<figure>
  <img alt="Константное время" src="01-constant.jpg" class="img-bordered-thin">
</figure>
</div>
</div>
<h2 id="логарифмическое-время-ologn">Логарифмическое время, O(log n)</h2>
<p>На <code>N</code> котиках алгоритм отрабатывает за <code>log(N)</code> шагов. Это быстро! 1 000 000 котиков → всего 20 операций.</p>
<div class="row">
<div class="col-xs-12 col-sm-6 flex">
<div class="boxed">
    <p><strong>🐾 Пример</strong></p>
    <p>Мисочки у котиков расставлены по алфавиту. Когда у вас появляется новый котик, место для его мисочки находится за <code>log(N)</code> шагов.</p>
</div>
</div>
<div class="col-xs-12 col-sm-6">
<figure>
  <img alt="Логарифмическое время" src="02-log.jpg" class="img-bordered-thin">
</figure>
</div>
</div>
<h2 id="линейное-время-on">Линейное время, O(n)</h2>
<p>На <code>N</code> котиках алгоритм отрабатывает за <code>N</code> шагов. Это значит, каждый раз приходится перебирать всех кошачьих. Ну такое.</p>
<div class="row">
<div class="col-xs-12 col-sm-6 flex">
<div class="boxed">
    <p><strong>🐾 Пример</strong></p>
    <p>Котики взбунтовались и перестали отзываться на клички. Теперь приходится обходить <code>N</code> шубок, чтобы найти нужного.</p>
</div>
</div>
<div class="col-xs-12 col-sm-6">
<figure>
  <img alt="Линейное время" src="03-linear.jpg" class="img-bordered-thin">
</figure>
</div>
</div>
<h2 id="линейно-логарифмическое-время-onlogn">Линейно-логарифмическое время, O(n log n)</h2>
<p>На <code>N</code> котиках алгоритм отрабатывает за <code>N</code> × <code>log(N)</code> шагов. Это дольше, чем за линейное время, но ненамного (логарифм <code>N</code> сильно меньше <code>N</code>, помните?).</p>
<div class="row">
<div class="col-xs-12 col-sm-6 flex">
<div class="boxed">
    <p><strong>🐾 Пример</strong></p>
    <p>К приходу гостей вы решили рассадить котиков по размеру. Алгоритм quick sort справится с этим за <code>N</code> × <code>log(N)</code> шагов.</p>
</div>
</div>
<div class="col-xs-12 col-sm-6">
<figure>
  <img alt="Линейно-логарифмическое время" src="04-log-linear.jpg" class="img-bordered-thin">
</figure>
</div>
</div>
<p>На очереди у нас неторопливые полиномиальные котики и совсем улиточки — суперполиномиальные.</p>
<h2 id="квадратичное-время-on">Квадратичное время O(n²)</h2>
<p>На <code>N</code> котиках алгоритм отрабатывает за <code>N²</code> шагов. Ме-е-едленно.</p>
<div class="row">
<div class="col-xs-12 col-sm-6 flex">
<div class="boxed">
    <p><strong>🐾 Пример</strong></p>
    <p>Конкурент утверждает, что его <code>N</code> котиков более гладкие и довольные, чем ваши. Специальная комиссия попарно сравнит хвостатых и вынесет справедливый вердикт. Понадобится ~ <code>N²</code> сравнений.</p>
</div>
</div>
<div class="col-xs-12 col-sm-6">
<figure>
  <img alt="Квадратичное время" src="05-quadratic.jpg" class="img-bordered-thin">
</figure>
</div>
</div>
<h2 id="полиномиальное-время-onᵏ">Полиномиальное время, O(nᵏ)</h2>
<p>На <code>N</code> котиках алгоритм отрабатывает за <code>N³</code> шагов, <code>N⁴</code> шагов, <code>N⁵</code> шагов, или ещё дольше. Фу таким быть.</p>
<div class="row">
<div class="col-xs-12 col-sm-6 flex">
<div class="boxed">
    <p><strong>🐾 Пример</strong></p>
    <p>Фотосессия! Каждого из <code>N</code> котиков надо попарно отфоткать с другими, причем фотограф делает <code>N</code> снимков на каждую пару. <code>N</code> × <code>N</code> × <code>N</code> ≃ <code>N³</code> шагов.</p>
</div>
</div>
<div class="col-xs-12 col-sm-6">
<figure>
  <img alt="Полиномиальное время" src="06-polinomial.jpg" class="img-bordered-thin">
</figure>
</div>
</div>
<p>Хоть полиномиальные алгоритмы и не славятся быстротой, по сравнению с суперполиномиальными они стремительны как Флеш. Из «суперского» у суперполиномиальных только название, увы. Сейчас покажу.</p>
<h2 id="экспоненциальное-время-o2ⁿ">Экспоненциальное время, O(2ⁿ)</h2>
<p>На <code>N</code> котиках алгоритм отрабатывает за <code>2ⁿ</code> шагов. Это долго, вы вряд ли дождетесь.</p>
<div class="row">
<div class="col-xs-12 col-sm-6 flex">
<div class="boxed">
    <p><strong>🐾 Пример</strong></p>
    <p>Котики отправляются на выставку. Каждого взвесили и оценили в звездах. Но перевозка рассчитана максимум на X килограмм. Как выбрать самый звездный состав? Ответ потребует <code>2ⁿ</code> шагов.</p>
</div>
</div>
<div class="col-xs-12 col-sm-6">
<figure>
  <img alt="Экспоненциальное время" src="07-exponential.jpg" class="img-bordered-thin">
</figure>
</div>
</div>
<h2 id="факториальное-время-on">Факториальное время, O(n!)</h2>
<p>На <code>N</code> котиках алгоритм отработает за <code>N</code> × <code>(N-1)</code> × <code>(N-2)</code> ×… × <code>1</code> шагов. Это жесть! Всего 20 котиков уже дадут нам пару квинтиллионов операций.</p>
<div class="row">
<div class="col-xs-12 col-sm-6 flex">
<div class="boxed">
    <p><strong>🐾 Пример</strong></p>
    <p>Котики расселись по квартире. Вам хочется пожамкать каждого, но ходить лень. Какой кратчайший маршрут, чтобы обойти всех шерстяных жопок? Это ~ <code>N!</code> сравнений.</p>
</div>
</div>
<div class="col-xs-12 col-sm-6">
<figure>
  <img alt="Факториальное время" src="08-factorial.jpg" class="img-bordered-thin">
</figure>
</div>
</div>
<h2 id="резюме">Резюме</h2>
<p>Вот какие алгоритмы мы рассмотрели:</p>
<ul>
<li>Константные <code>O(1)</code></li>
<li>Логарифмические <code>O(log n)</code></li>
<li>Линейные <code>O(n)</code></li>
<li>Линейно-логарифмические <code>O(n log n)</code></li>
<li>Квадратичные <code>O(n²)</code></li>
<li>Полиномиальные <code>O(nᵏ)</code></li>
<li>Экспоненциальные <code>O(2ⁿ)</code></li>
<li>Факториальные <code>O(n!)</code></li>
</ul>
<p>Константный алгоритм — всегда лучший вариант, а логарифмический — почти всегда. С линейными и полиномиальными сложнее — тут все зависит от задачи. Где-то стыдно выбирать <code>O(n)</code>, а где-то и <code>O(n²)</code> будет большим успехом.</p>
<p><code>O(2ⁿ)</code> и <code>O(n!)</code> безумно медленные, поэтому на практике вместо них обычно используют неоптимальные, но быстрые алгоритмы.</p>
<p><em>Всем котиков! И подписывайтесь на <a href="https://twitter.com/nalgeon">@nalgeon</a> в твитере, чтобы не пропустить новые заметки 🚀</em></p>
]]></content:encoded></item><item><title>Как на самом деле устроен список в Python</title><link>https://antonz.ru/list-internals/</link><pubDate>Thu, 11 Nov 2021 16:18:00 +0000</pubDate><guid>https://antonz.ru/list-internals/</guid><description>И где у него константное время, а где линейное.</description><content:encoded><![CDATA[<p><em>Эта заметка посвящена структуре данных номер один в мире — массивам. Если вы еще не гуру алгоритмов и структур данных — гарантирую, что лучше поймете списки в питоне, их преимущества и ограничения. А если и так все знаете — освежите ключевые моменты.</em></p>
<p>Все знают, как работать со списком в питоне:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="color:#000">&gt;&gt;&gt;</span> <span style="color:#000">guests</span> <span style="color:#000">=</span> [<span style="color:#c41a16">&#34;Френк&#34;</span>, <span style="color:#c41a16">&#34;Клер&#34;</span>, <span style="color:#c41a16">&#34;Зоя&#34;</span>]
<span style="color:#000">&gt;&gt;&gt;</span> <span style="color:#000">guests</span>[<span style="color:#1c01ce">1</span>]
<span style="color:#c41a16">&#39;Клер&#39;</span>
</code></pre></div><p>Наверняка вы знаете, что выборка элемента по индексу — <code>guests[idx]</code> — отработает очень быстро даже на списке из миллиона элементов. Более точно, выборка по индексу работает за константное время O(1) — то есть не зависит от количества элементов в списке.</p>
<p>А знаете, за счет чего так быстро работает? Если да — вы в меньшинстве:</p>
<div class="row">
<div class="col-xs-12 col-sm-6">
<figure>
  <img alt="Опрос" src="survey.png">
</figure>
</div>
</div>
<p>Давайте разбираться.</p>
<h2 id="список--массив">Список = массив?</h2>
<p>В основе списка лежит массив. Массив — это набор элементов ① одинакового размера и ② расположенных в памяти подряд друг за другом, без пропусков.</p>
<p>Раз элементы одинаковые и идут подряд, получить элемент массива по индексу несложно — достаточно знать адрес самого первого элемента («головы» массива).</p>
<p>Допустим, голова находится по адресу <code>0×00001234</code>, а каждый элемент занимает 8 байт. Тогда элемент с индексом <code>idx</code> находится по адресу <code>0×00001234 + idx*8</code>:</p>
<div class="row">
<div class="col-xs-12 col-sm-6">
<figure>
  <img alt="Список — массив" src="array-1.png" class="img-bordered-thin">
</figure>
</div>
</div>
<p>Поскольку операция «получить значение по адресу» выполняется за константное время, то и выборка из массива по индексу выполняется за O(1).</p>
<p>Грубо говоря, список в питоне именно так и устроен. Он хранит указатель на голову массива и количество элементов в массиве. Количество хранится отдельно, чтобы функция <code>len()</code> тоже отрабатывала за O(1), а не считала каждый раз фактическое количество элементов списка.</p>
<p>Все хорошо, но есть пара проблем:</p>
<ul>
<li>все элементы массива одного размера, а список умеет хранить разные (true/false, числа, строки разной длины);</li>
<li>массив имеет фиксированную длину, а в список можно добавить сколько угодно элементов.</li>
</ul>
<p>Чуть позже посмотрим, как их решить.</p>
<h2 id="ну-очень-примитивный-список">Ну очень примитивный список</h2>
<p>Лучший способ освоить структуру данных — реализовать ее с нуля. К сожалению, питон плохо подходит для таких низкоуровненых структур как массив, потому что не дает явно работать с указателями (адресами в памяти).</p>
<p>Но кое-что можно сделать:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="color:#a90d91">class</span> <span style="color:#3f6e75">OhMyList</span>:
    <span style="color:#a90d91">def</span> <span style="color:#000">__init__</span>(<span style="color:#5b269a">self</span>):
        <span style="color:#5b269a">self</span><span style="color:#000">.</span><span style="color:#000">length</span> <span style="color:#000">=</span> <span style="color:#1c01ce">0</span>
        <span style="color:#5b269a">self</span><span style="color:#000">.</span><span style="color:#000">capacity</span> <span style="color:#000">=</span> <span style="color:#1c01ce">8</span>
        <span style="color:#5b269a">self</span><span style="color:#000">.</span><span style="color:#000">array</span> <span style="color:#000">=</span> (<span style="color:#5b269a">self</span><span style="color:#000">.</span><span style="color:#000">capacity</span> <span style="color:#000">*</span> <span style="color:#000">ctypes</span><span style="color:#000">.</span><span style="color:#000">py_object</span>)()

    <span style="color:#a90d91">def</span> <span style="color:#000">append</span>(<span style="color:#5b269a">self</span>, <span style="color:#000">item</span>):
        <span style="color:#5b269a">self</span><span style="color:#000">.</span><span style="color:#000">array</span>[<span style="color:#5b269a">self</span><span style="color:#000">.</span><span style="color:#000">length</span>] <span style="color:#000">=</span> <span style="color:#000">item</span>
        <span style="color:#5b269a">self</span><span style="color:#000">.</span><span style="color:#000">length</span> <span style="color:#000">+=</span> <span style="color:#1c01ce">1</span>

    <span style="color:#a90d91">def</span> <span style="color:#000">__len__</span>(<span style="color:#5b269a">self</span>):
        <span style="color:#a90d91">return</span> <span style="color:#5b269a">self</span><span style="color:#000">.</span><span style="color:#000">length</span>

    <span style="color:#a90d91">def</span> <span style="color:#000">__getitem__</span>(<span style="color:#5b269a">self</span>, <span style="color:#000">idx</span>):
        <span style="color:#a90d91">return</span> <span style="color:#5b269a">self</span><span style="color:#000">.</span><span style="color:#000">array</span>[<span style="color:#000">idx</span>]
</code></pre></div><p>Наш самописный список имеет фиксированную вместимость (<code>capacity</code> = 8 элементов) и хранит элементы в массиве <code>array</code>.</p>
<p>Модуль <code>ctypes</code> дает доступ к сишным структурам, на которых построена стандартная библиотека. В даннам случае мы используем его, чтобы создать массив размером в <code>capacity</code> элементов.</p>
<h2 id="список--массив-указателей">Список = массив указателей</h2>
<p>Список моментально выбирает элемент по индексу, потому что внутри у него массив. А массив такой быстрый, потому что все элементы у него одинакового размера.</p>
<p>Но при этом в списке элементы могут быть очень разные:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="color:#000">guests</span> <span style="color:#000">=</span> [<span style="color:#c41a16">&#34;Френк&#34;</span>, <span style="color:#c41a16">&#34;Клер&#34;</span>, <span style="color:#c41a16">&#34;Зоя&#34;</span>, <span style="color:#a90d91">True</span>, <span style="color:#1c01ce">42</span>]
</code></pre></div><p>Чтобы решить эту задачку, придумали хранить в массиве не сами значения, а указатели на них. Элемент массива — адрес в памяти, а если обратиться по адресу — получишь настоящее значение:</p>
<div class="row">
<div class="col-xs-12 col-sm-10">
<figure>
  <img alt="Список — массив указателей" src="array-2.png" class="img-bordered-thin">
  <figcaption>Элементы массива расположены подряд, а сами значения, на которые они ссылаются, могут быть вперемешку где угодно в памяти.</figcaption>
</figure>
</div>
</div>
<p>Поскольку указатели фиксированного размера (8 байт на современных 64-битных процессорах), то все прекрасно работает. Да, получается, что вместо одной операции (получить значение из элемента массива) мы делаем две:</p>
<ol>
<li>Получить адрес из элемента массива.</li>
<li>Получить значение по адресу.</li>
</ol>
<p>Но это все еще константное время O(1).</p>
<h2 id="список--динамический-массив">Список = динамический массив</h2>
<p>Если в массиве под списком остались свободные места, то метод <code>.append(item)</code> выполнится за константное время — достаточно записать новое значение в свободную ячейку и увеличить счетчик элементов на 1:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="color:#a90d91">def</span> <span style="color:#000">append</span>(<span style="color:#5b269a">self</span>, <span style="color:#000">item</span>):
    <span style="color:#5b269a">self</span><span style="color:#000">.</span><span style="color:#000">array</span>[<span style="color:#5b269a">self</span><span style="color:#000">.</span><span style="color:#000">length</span>] <span style="color:#000">=</span> <span style="color:#000">item</span>
    <span style="color:#5b269a">self</span><span style="color:#000">.</span><span style="color:#000">length</span> <span style="color:#000">+=</span> <span style="color:#1c01ce">1</span>
</code></pre></div><p>Но что делать, если массив уже заполнен?</p>
<p>Приходится выделять память под новый массив, побольше, и копировать все элементы старого массива в новый:</p>
<div class="row">
<div class="col-xs-12 col-sm-6">
<figure>
  <img alt="Список — динамический массив" src="array-3.png" class="img-bordered-thin">
  <figcaption>Когда место в старом массиве заканчивается, приходится создавать новый.</figcaption>
</figure>
</div>
</div>
<p>Примерно так:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="color:#a90d91">def</span> <span style="color:#000">append</span>(<span style="color:#5b269a">self</span>, <span style="color:#000">item</span>):
    <span style="color:#a90d91">if</span> <span style="color:#5b269a">self</span><span style="color:#000">.</span><span style="color:#000">length</span> <span style="color:#000">==</span> <span style="color:#5b269a">self</span><span style="color:#000">.</span><span style="color:#000">capacity</span>:
        <span style="color:#5b269a">self</span><span style="color:#000">.</span><span style="color:#000">_resize</span>(<span style="color:#5b269a">self</span><span style="color:#000">.</span><span style="color:#000">capacity</span><span style="color:#000">*</span><span style="color:#1c01ce">2</span>)
    <span style="color:#5b269a">self</span><span style="color:#000">.</span><span style="color:#000">array</span>[<span style="color:#5b269a">self</span><span style="color:#000">.</span><span style="color:#000">length</span>] <span style="color:#000">=</span> <span style="color:#000">item</span>
    <span style="color:#5b269a">self</span><span style="color:#000">.</span><span style="color:#000">length</span> <span style="color:#000">+=</span> <span style="color:#1c01ce">1</span>

<span style="color:#a90d91">def</span> <span style="color:#000">_resize</span>(<span style="color:#5b269a">self</span>, <span style="color:#000">new_cap</span>):
    <span style="color:#000">new_arr</span> <span style="color:#000">=</span> (<span style="color:#000">new_cap</span> <span style="color:#000">*</span> <span style="color:#000">ctypes</span><span style="color:#000">.</span><span style="color:#000">py_object</span>)()
    <span style="color:#a90d91">for</span> <span style="color:#000">idx</span> <span style="color:#000">in</span> <span style="color:#a90d91">range</span>(<span style="color:#5b269a">self</span><span style="color:#000">.</span><span style="color:#000">length</span>):
        <span style="color:#000">new_arr</span>[<span style="color:#000">idx</span>] <span style="color:#000">=</span> <span style="color:#5b269a">self</span><span style="color:#000">.</span><span style="color:#000">array</span>[<span style="color:#000">idx</span>]
    <span style="color:#5b269a">self</span><span style="color:#000">.</span><span style="color:#000">array</span> <span style="color:#000">=</span> <span style="color:#000">new_arr</span>
    <span style="color:#5b269a">self</span><span style="color:#000">.</span><span style="color:#000">capacity</span> <span style="color:#000">=</span> <span style="color:#000">new_cap</span>
</code></pre></div><p><code>._resize()</code> — затратная операция, так что новый массив создают с запасом. В примере выше новый массив в два раза больше старого, а в питоне используют более скромный коэффициент — примерно 1.12.</p>
<p>Если удалить из списка больше половины элементов через <code>.pop()</code>, то питон его скукожит — выделит новый массив поменьше и перенесет элементы в него.</p>
<p>Таким образом, список все время жонглирует массивами, чтобы это не приходилось делать нам ツ</p>
<h2 id="добавление-элемента-в-конец-списка">Добавление элемента в конец списка</h2>
<p>Выборка из списка по индексу работает за O(1) — с этим разобрались. Метод <code>.append(item)</code> тоже отрабатывает за O(1), пока не приходится расширять массив под списком. Но любое расширение массива — это операция O(n). Так за сколько же в итоге отрабатывает <code>.append()</code>?</p>
<p>Оценивать отдельную операцию вставки было бы неправильно — как мы выяснили, она иногда выполняется за O(1), а иногда и за O(n). Поэтому используют амортизационный анализ — оценивают общее время, которое займет последовательность из K операций, затем делят его на K и получают амортизированное время одной операции.</p>
<p>Так вот. Не вдаваясь в подробности скажу, что амортизированное время для <code>.append(item)</code> получается константным — O(1). Так что вставка в конец списка работает очень быстро.</p>
<div class="boxed">
<h3>Почему амортизированное время — O(1)</h3>
<p>Допустим, список пуст и мы хотим добавить в него <code>n</code> элементов. Для простоты будем использовать фактор расширения 2. Посчитаем количество атомарных операций:</p>
<ul>
  <li>первый элемент: 1 (копирование) + 1 (вставка)</li>
  <li>ещё 2: 2 (копирование) + 2 (вставка)</li>
  <li>ещё 4: 4 (копирование) + 4 (вставка)</li>
  <li>ещё 8: 8 (копирование) + 8 (вставка)</li>
  <li>...</li>
</ul>
<p>Итого на <code>n</code> элементов будет <code>n</code> операций вставки.</p>
<p>А при копировании будет</p>
<pre><code>1 + 2 + 4 + ... log(n) = 
= 2**log(n) * 2 - 1 =
= 2n - 1</code></pre>
<p>операций.</p>
<p>Итого на <code>n</code> элементов получилось <code>3n - 1</code> атомарных операций.</p>
<p><code>O((3n - 1) / n)</code> = <code>O(1)</code></p>
</div>
<p>Получается, у списка есть такие гарантированно быстрые операции:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="color:#177500"># O(1)</span>
<span style="color:#000">lst</span>[<span style="color:#000">idx</span>]

<span style="color:#177500"># O(1)</span>
<span style="color:#a90d91">len</span>(<span style="color:#000">lst</span>)

<span style="color:#177500"># амортизированное O(1)</span>
<span style="color:#000">lst</span><span style="color:#000">.</span><span style="color:#000">append</span>(<span style="color:#000">item</span>)
<span style="color:#000">lst</span><span style="color:#000">.</span><span style="color:#000">pop</span>()
</code></pre></div><h2 id="итоги">Итоги</h2>
<p>Как мы выяснили, у списка работают за O(1):</p>
<ul>
<li>выборка по индексу <code>lst[idx]</code></li>
<li>запрос длины <code>len(lst)</code></li>
<li>добавление элемента в конец списка <code>.append(item)</code></li>
<li>удаление элемента из конца списка <code>.pop()</code></li>
</ul>
<p>Остальные операции — «медленные»:</p>
<ul>
<li>Вставка и удаление из произвольной позиции — <code>.insert(idx, item)</code> и <code>.pop(idx)</code> — работают за линейное время O(n), потому что сдвигают все элементы после целевого.</li>
<li>Поиск и удаление элемента по значению — <code>item in lst</code>, <code>.index(item)</code> и <code>.remove(item)</code> — работают за линейное время O(n), потому что перебирают все элементы.</li>
<li>Выборка среза из <code>k</code> элементов — <code>lst[from:to]</code> — работает за O(k).</li>
</ul>
<p>Значит ли это, что «медленные» операции нельзя использовать? Конечно, нет. Если у вас список из 1000 элементов, разница между O(1) и O(n) для единичной операции незаметна.</p>
<p>С другой стороны, если вы миллион раз выполняете «медленную» операцию на списке из 1000 элементов — это уже заметно. Или если список из миллиона элементов — тоже.</p>
<p>Поэтому полезно знать, что у списка работает за константное время, а что за линейное — чтобы осознанно принимать решение в конкретной ситуации.</p>
<div class="row">
<div class="col-xs-12 col-sm-10 col-md-8"><p><em>Заметка из телеграм-канала <span class="nowrap"><i class="fas fa-kiwi-bird"></i> «<a href="https://t.me/ohmypy">Oh My Py</a>»</span></em></p></div>
</div>]]></content:encoded></item><item><title>Табличные выражения SQL</title><link>https://antonz.ru/cte/</link><pubDate>Fri, 05 Nov 2021 11:14:51 +0000</pubDate><guid>https://antonz.ru/cte/</guid><description>Используйте их вместо подзапросов.</description><content:encoded><![CDATA[<p>Прием № 1, чтобы писать хорошие читаемые SQL-запросы — это <em>табличные выражения</em> (CTE). Люди их боятся, а зря. Давайте разберемся за три минуты, читать увесистую книгу по SQL или проходить курсы не придется.</p>
<h2 id="проблема">Проблема</h2>
<p>Допустим, у нас есть таблица продаж по месяцам за два года:</p>
<pre tabindex="0"><code>┌──────┬───────┬───────┬──────────┬─────────┐
│ year │ month │ price │ quantity │ revenue │
├──────┼───────┼───────┼──────────┼─────────┤
│ 2019 │ 1     │ 60    │ 200      │ 12000   │
│ 2019 │ 2     │ 60    │ 660      │ 39600   │
│ 2019 │ 3     │ 60    │ 400      │ 24000   │
│ 2019 │ 4     │ 60    │ 300      │ 18000   │
│ 2019 │ 5     │ 60    │ 440      │ 26400   │
│ 2019 │ 6     │ 60    │ 540      │ 32400   │
│ 2019 │ 7     │ 60    │ 440      │ 26400   │
│ 2019 │ 8     │ 60    │ 440      │ 26400   │
│ 2019 │ 9     │ 60    │ 250      │ 15000   │
│ 2019 │ 10    │ 60    │ 420      │ 25200   │
│ ...  │ ...   │ ...   │ ...      │ ...     │
└──────┴───────┴───────┴──────────┴─────────┘
</code></pre><p><a href="https://sqlime.org/#gist:858c409b81ae3a676580cba6745d68ea">песочница</a></p>
<p>Мы хотим выбрать только те месяцы, выручка за которые превысила среднемесячную за год.</p>
<p>Для начала посчитаем среднемесячную выручку по годам:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#a90d91">select</span>
  <span style="color:#a90d91">year</span>,
  <span style="color:#a90d91">avg</span>(<span style="color:#000">revenue</span>) <span style="color:#a90d91">as</span> <span style="color:#000">avg_rev</span>
<span style="color:#a90d91">from</span> <span style="color:#000">sales</span>
<span style="color:#a90d91">group</span> <span style="color:#a90d91">by</span> <span style="color:#a90d91">year</span>;
</code></pre></div><pre tabindex="0"><code>┌──────┬─────────┐
│ year │ avg_rev │
├──────┼─────────┤
│ 2019 │ 25125.0 │
│ 2020 │ 48625.0 │
└──────┴─────────┘
</code></pre><p>Теперь можно выбрать только те записи, <code>revenue</code> в которых не уступает <code>avg_rev</code>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#a90d91">select</span>
  <span style="color:#000">sales</span>.<span style="color:#a90d91">year</span>,
  <span style="color:#000">sales</span>.<span style="color:#a90d91">month</span>,
  <span style="color:#000">sales</span>.<span style="color:#000">revenue</span>,
  <span style="color:#000">round</span>(<span style="color:#000">totals</span>.<span style="color:#000">avg_rev</span>) <span style="color:#a90d91">as</span> <span style="color:#000">avg_rev</span>
<span style="color:#a90d91">from</span> <span style="color:#000">sales</span>
  <span style="color:#a90d91">join</span> (
    <span style="color:#a90d91">select</span>
      <span style="color:#a90d91">year</span>,
      <span style="color:#a90d91">avg</span>(<span style="color:#000">revenue</span>) <span style="color:#a90d91">as</span> <span style="color:#000">avg_rev</span>
    <span style="color:#a90d91">from</span> <span style="color:#000">sales</span>
    <span style="color:#a90d91">group</span> <span style="color:#a90d91">by</span> <span style="color:#a90d91">year</span>
  ) <span style="color:#a90d91">as</span> <span style="color:#000">totals</span>
  <span style="color:#a90d91">on</span> <span style="color:#000">sales</span>.<span style="color:#a90d91">year</span> <span style="color:#000">=</span> <span style="color:#000">totals</span>.<span style="color:#a90d91">year</span>
<span style="color:#a90d91">where</span> <span style="color:#000">sales</span>.<span style="color:#000">revenue</span> <span style="color:#000">&gt;=</span> <span style="color:#000">totals</span>.<span style="color:#000">avg_rev</span>;
</code></pre></div><pre tabindex="0"><code>┌──────┬───────┬─────────┬─────────┐
│ year │ month │ revenue │ avg_rev │
├──────┼───────┼─────────┼─────────┤
│ 2019 │ 2     │ 39600   │ 25125.0 │
│ 2019 │ 5     │ 26400   │ 25125.0 │
│ 2019 │ 6     │ 32400   │ 25125.0 │
│ 2019 │ 7     │ 26400   │ 25125.0 │
│ ...  │ ...   │ ...     │ ...     │
└──────┴───────┴─────────┴─────────┘
</code></pre><p>Решили с помощью подзапроса:</p>
<ul>
<li>внутренний запрос считает среднемесячную выручку;</li>
<li>внешний соединяется с ним и фильтрует результаты.</li>
</ul>
<p>Запрос в целом получился сложноват. Если вернетесь к нему спустя месяц — наверняка потратите какое-то время на «распутывание». Проблема в том, что такие вложенные запросы приходится читать наоборот:</p>
<ul>
<li>найти самый внутренний запрос, осознать;</li>
<li>мысленно присоединить к более внешнему;</li>
<li>присоединить к следующему внешнему, и так далее.</li>
</ul>
<p>Хорошо, когда вложенных уровня два, как в нашем примере. На практике же я часто встречаю трех- и четырехуровневые подзапросы. Форменное издевательство над читателем.</p>
<h2 id="решение">Решение</h2>
<p>Вместо подзапроса можно использовать <em>табличное выражение</em> (common table expression, CTE). Любой подзапрос <code>X</code>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#a90d91">select</span> <span style="color:#000">a</span>, <span style="color:#000">b</span>, <span style="color:#a90d91">c</span>
<span style="color:#a90d91">from</span> (<span style="color:#000">X</span>)
<span style="color:#a90d91">where</span> <span style="color:#000">e</span> <span style="color:#000">=</span> <span style="color:#000">f</span>
</code></pre></div><p>Механически превращается в CTE:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#a90d91">with</span> <span style="color:#000">cte</span> <span style="color:#a90d91">as</span> (<span style="color:#000">X</span>)
<span style="color:#a90d91">select</span> <span style="color:#000">a</span>, <span style="color:#000">b</span>, <span style="color:#a90d91">c</span>
<span style="color:#a90d91">from</span> <span style="color:#000">cte</span>
<span style="color:#a90d91">where</span> <span style="color:#000">e</span> <span style="color:#000">=</span> <span style="color:#000">f</span>
</code></pre></div><p>В нашем примере:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#a90d91">with</span> <span style="color:#000">totals</span> <span style="color:#a90d91">as</span> (
  <span style="color:#a90d91">select</span>
    <span style="color:#a90d91">year</span>,
    <span style="color:#a90d91">avg</span>(<span style="color:#000">revenue</span>) <span style="color:#a90d91">as</span> <span style="color:#000">avg_rev</span>
  <span style="color:#a90d91">from</span> <span style="color:#000">sales</span>
  <span style="color:#a90d91">group</span> <span style="color:#a90d91">by</span> <span style="color:#a90d91">year</span>
)

<span style="color:#a90d91">select</span>
  <span style="color:#000">sales</span>.<span style="color:#a90d91">year</span>,
  <span style="color:#000">sales</span>.<span style="color:#a90d91">month</span>,
  <span style="color:#000">sales</span>.<span style="color:#000">revenue</span>,
  <span style="color:#000">round</span>(<span style="color:#000">totals</span>.<span style="color:#000">avg_rev</span>) <span style="color:#a90d91">as</span> <span style="color:#000">avg_rev</span>
<span style="color:#a90d91">from</span> <span style="color:#000">sales</span> 
  <span style="color:#a90d91">join</span> <span style="color:#000">totals</span> <span style="color:#a90d91">on</span> <span style="color:#000">totals</span>.<span style="color:#a90d91">year</span> <span style="color:#000">=</span> <span style="color:#000">sales</span>.<span style="color:#a90d91">year</span>
<span style="color:#a90d91">where</span> <span style="color:#000">sales</span>.<span style="color:#000">revenue</span> <span style="color:#000">&gt;=</span> <span style="color:#000">totals</span>.<span style="color:#000">avg_rev</span>;
</code></pre></div><p>С табличным выражением запрос становится одноуровневым — так воспринимать его намного проще. Кроме того, табличное выражение можно переиспользовать в пределах запроса, как будто это обычная таблица:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#a90d91">with</span> <span style="color:#000">totals</span> <span style="color:#a90d91">as</span> (...)
<span style="color:#a90d91">select</span> ... <span style="color:#a90d91">from</span> <span style="color:#000">sales_ru</span> <span style="color:#a90d91">join</span> <span style="color:#000">totals</span> ...
<span style="color:#a90d91">union</span> <span style="color:#a90d91">all</span>
<span style="color:#a90d91">select</span> ... <span style="color:#a90d91">from</span> <span style="color:#000">sales_us</span> <span style="color:#a90d91">join</span> <span style="color:#000">totals</span> ...
</code></pre></div><p>Табличные выражения SQL чем-то похожи на функции в обычном языке программирования — они уменьшают общую сложность:</p>
<ul>
<li>Можно написать нечитаемую простыню кода, а можно разбить код на понятные отдельные функции и составить программу из них.</li>
<li>Можно возвести башню из пяти этажей подзапросов, а можно вынести подзапросы в CTE и составить общий запрос из них.</li>
</ul>
<h2 id="cte-против-подзапроса">CTE против подзапроса</h2>
<p>Существует миф, что «CTE медленные». Он пришел из старых версий PostgreSQL (11 и раньше), которые всегда <em>материализовали</em> CTE — вычисляли полный результат табличного выражения и запоминали до конца запроса.</p>
<p>Обычно это хорошо: один раз вычислил результат, и дальше используешь его несколько раз по ходу основного запроса. Но иногда материализация мешала движку оптимизировать запрос:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#a90d91">with</span> <span style="color:#000">cte</span> <span style="color:#a90d91">as</span> (<span style="color:#a90d91">select</span> <span style="color:#000">*</span> <span style="color:#a90d91">from</span> <span style="color:#000">foo</span>)
<span style="color:#a90d91">select</span> <span style="color:#000">*</span> <span style="color:#a90d91">from</span> <span style="color:#000">cte</span> <span style="color:#a90d91">where</span> <span style="color:#000">id</span> <span style="color:#000">=</span> <span style="color:#1c01ce">500000</span>;
</code></pre></div><p>Здесь выбирается ровно одна запись по идентификатору, но материализация создает в памяти копию <em>всей таблицы</em> — из-за этого запрос отработает очень медленно.</p>
<p>PostgreSQL 12+ и другие современные СУБД поумнели и больше так не делают. Материализация применяется, когда от нее больше пользы, чем вреда. Плюс, многие СУБД позволяют явно управлять этим поведением через инструкции <code>MATERIALIZED</code> / <code>NOT MATERIALIZED</code>.</p>
<p>Так что CTE не медленнее подзапросов. А если сомневаетесь, всегда можно сделать два варианта — подзапрос и табличное выражение — и сравнить план и время выполнения.</p>
<p>Как понять, когда использовать подзапрос, а когда CTE? Я вывел для себя простое правило, которое пока ни разу не подвело:</p>
<blockquote class="big">
<p>Всегда использовать CTE</p>
</blockquote>
<p>Чего и вам желаю.</p>
<div class="row">
<div class="col-xs-12 col-sm-10 col-md-8"><p><em>И подписывайтесь на канал <span class="nowrap"><i class="fas fa-database"></i> «<a href="https://t.me/sqliter">SQLite на практике</a>»</span></em></p></div>
</div>
]]></content:encoded></item><item><title>Справочник адресов России</title><link>https://antonz.ru/fias/</link><pubDate>Sun, 24 Oct 2021 17:02:08 +0000</pubDate><guid>https://antonz.ru/fias/</guid><description>Который ведет налоговая.</description><content:encoded><![CDATA[<p>Не все знают, что в России есть Великий Справочник Адресов, в который свято веруют все чиновники (да и не только они). Расскажу о нём немного. Без официальной нуднятины, только задорные факты из жизни.</p>
<p>Справочник адресов называется «ФИАС» (федеральная информационная адресная система) или «ГАР» (государственный адресный реестр) — это одно и то же. Раньше назывался «КЛАДР» (классификатор адресов). Технически поддерживает его налоговая, а данные о домах и улицах вносят местные чиновники по всей стране. У справочника даже есть сайт (не читайте его): <a href="https://fias.nalog.ru">fias.nalog.ru</a></p>
<p>Вот как видит нашу родину налоговая служба:</p>
<ul>
<li>86 регионов</li>
<li>3 тыс. городов</li>
<li>300 тыс. населённых пунктов</li>
<li>1 млн улиц</li>
<li>31 млн домов</li>
<li>52 млн квартир</li>
</ul>
<p>У каждого адреса есть тип и название. Скажем, тип = «город», название = «Самара». Или тип = «республика», название = «Бурятия». Но если вам повезло жить в республике Чувашия, то тип = «Чувашия», название = «Чувашская республика». Потому что пошёл ты нахер, вот почему.</p>
<p>ФИАС — истина в последней инстанции для всех гос. органов. Если вы живёте в Кабардино-Балкарии на Моздокской улице, а у налоговой она значится как «МосдоГская» (в честь знаменитых кабардино-балкарских догов, видимо), то ни одному чиновнику вы свою правоту не докажете.</p>
<figure>
  <img alt="Странные дома" src="fias-house-zero.png">
  <figcaption>Дурная фантазия чиновников безгранична</figcaption>
</figure>
<p>Или ещё был случай. В 2018 году питерским чиновникам стало скучно, и они домам приделали «литеру А». Был «Невский проспект, дом 41», а стал «дом 41 литер А». И так со всеми домами в городе. На табличках нормально написано, а в голове у чиновников — с литерами. Deal with it.</p>
<p>Справочник полон милых идиотизмов. Однажды перестали помещаться гаражи и садовые товарищества, и налоговая додумалась добавить новый «уровень» адреса для них. Загадочно назвали его «планировочная структура». Но забыли рассказать местным чиновникам, что это такое и зачем. Поэтому теперь в «планировочных структурах» лежит всё от жилых кварталов до районов городов и международных трасс. Бадум-тсс!</p>
<p>Ах да. Если вы думаете, что живёте в городе, то разочарую. На самом деле это не «город», а «городской округ». Это называется «муниципальное деление»: городские округа вместо городов, сельские поселения вместо сёл, и так далее. Ну, чтобы никто не догадался.</p>
<p>Налоговая любит внезапно менять справочник. То все дома в городе потеряет, то битых улиц насыпет, то просто два месяца не обновляет. Объяснений и анонсов, конечно же, никто не делает. Сами разберётесь, не маленькие.</p>
<p>Но. Хоть я и ворчу, ФИАС — большое благо! Это структурированный, регулярно обновляемый справочник адресов, доступный всем желающим. У большинства стран такого нет, так что пусть завидуют 👌</p>
<p><em>Подписывайтесь на <a href="https://twitter.com/nalgeon">@nalgeon</a> в твитере, чтобы не пропустить новые заметки</em></p>
]]></content:encoded></item><item><title>Вы являетесь дизайнеру в страшном сне</title><link>https://antonz.ru/tinkoff-signin/</link><pubDate>Thu, 07 Oct 2021 13:49:33 +0000</pubDate><guid>https://antonz.ru/tinkoff-signin/</guid><description>Помогаем Тинькову избавиться от косноязычия на форме входа.</description><content:encoded><![CDATA[<p>Интернет-банк Тинькова при входе встречает многозначительной надписью:</p>
<figure>
  <img alt="Вы являетесь держателем" src="tinkoff-signin-1.png">
</figure>
<blockquote class="big">
Вы являетесь держателем продуктов Тинькофф Банка. При входе по номеру телефона, в целях безопасности, введите пароль.
</blockquote>
<p>Я, конечно, не UX-писатель, но это жуть какая кривая формулировка. Давайте попробуем улучшить.</p>
<h2 id="1-формулируем-по-человечески">1. Формулируем по-человечески</h2>
<p>Меняем суконный язык банковских безопасников на нормальную речь.</p>
<blockquote class="big">
Вы являетесь держателем продуктов Тинькофф Банка. При входе по номеру телефона, в целях безопасности, введите пароль.<br>↓
</blockquote>
<blockquote class="big">
Вы — клиент Тинькофф Банка. Введите пароль, чтобы войти.
</blockquote>
<h2 id="2-убираем-лишнее">2. Убираем лишнее</h2>
<p>Зачем писать человеку, что он клиент? Я и так это знаю, потому и пытаюсь войти в интернет-банк. Убираем.</p>
<blockquote class="big">
Вы — клиент Тинькофф Банка. Введите пароль, чтобы войти.<br>↓
</blockquote>
<blockquote class="big">Введите пароль, чтобы войти.</blockquote>
<h2 id="3-убираем-очевидное">3. Убираем очевидное</h2>
<p>На этой же форме огроменное поле ПАРОЛЬ и кнопка ВОЙТИ. Спорим, человек догадается, чего от него хотят?</p>
<blockquote class="big">Введите пароль, чтобы войти.<br>↓</blockquote>
<blockquote class="big">Ø</blockquote>
<p>Что осталось:</p>
<figure>
  <img alt="Больше не являетесь" src="tinkoff-signin-2.png">
</figure>
<h2 id="qa">Q&amp;A</h2>
<blockquote>
<p>А это не юридический затык? У Тинькофа вроде всё хорошо с ux-райтингом во всех других местах.</p>
</blockquote>
<p>У Тинькова есть некоторое количество сотрудников, которые умеют писать нормальный текст, и огромная армия тех, кто делать этого не умеет и не желает. Вторые иногда прорываются. Хотя первые в целом отлично справляются, да.</p>
<blockquote>
<p>Мне кажется, предполагать, что человек сразу поймет, куда он входит, слишком смело.</p>
</blockquote>
<p>Действительно, он зашел на сайт Тинькова, нажал на «Войти», указал номер телефона. Конечно, он понятия не имеет, что делает.</p>
<blockquote>
<p>А может это было сделано по требованиям accessibility? Чтобы читалка озвучила, например.</p>
</blockquote>
<p>Это делается иначе.</p>
<blockquote>
<p>Не уверен, что насчет этого можно сразу рассуждать предположениями. Как реально юзеры реагируют на такую форму можно понять только через исследования.</p>
</blockquote>
<p>Не надо проводить исследования, чтобы исправить очевидные проблемы. Исследования не заменяют головной мозг, пользуйтесь им.</p>
<div class="row">
<div class="col-xs-12 col-sm-10 col-md-8"><p><em>Заметка из телеграм-канала <span class="nowrap"><i class="far fa-star color-sin"></i> «<a href="https://t.me/dangry">Интерфейсы без шелухи</a>»</span></em></p></div>
</div>
]]></content:encoded></item></channel></rss>