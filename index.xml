<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Антон Жиянов</title><description>Разработка софта, продуктоводство и здравый смысл</description><link>https://antonz.ru/</link><image><url>https://antonz.ru/assets/favicon/favicon.png</url><title>Антон Жиянов</title><link>https://antonz.ru/</link></image><generator>Hugo -- gohugo.io</generator><language>ru-ru</language><lastBuildDate>Fri, 13 May 2022 20:25:00 +0000</lastBuildDate><atom:link href="https://antonz.ru/index.xml" rel="self" type="application/rss+xml"/><item><title>Компактные объекты в Python</title><link>https://antonz.ru/compact-objects/</link><pubDate>Fri, 13 May 2022 20:25:00 +0000</pubDate><guid>https://antonz.ru/compact-objects/</guid><description>Кортеж против датакласса, пока не вмешается numpy</description><content:encoded><![CDATA[<p>Питон — объектный язык. Это здорово и удобно, пока не придется создать 10 млн объектов в памяти, которые благополучно ее и съедят. Поговорим о том, как уменьшить аппетит.</p>
<h2 id="кортеж">Кортеж</h2>
<p>Допустим, есть у вас простенький объект «питомец» с атрибутами «имя» (строка) и «стоимость» (целое). Интуитивно кажется, что самое компактное предоставление — в виде кортежа:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">(<span style="color:#c41a16">&#34;Frank the Pigeon&#34;</span>, <span style="color:#1c01ce">50000</span>)
</code></pre></div><p>Замерим, сколько займет в памяти один такой красавчик:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#a90d91">import</span> <span style="color:#000">random</span>
<span style="color:#a90d91">from</span> <span style="color:#000">pympler.asizeof</span> <span style="color:#a90d91">import</span> <span style="color:#000">asizeof</span>

<span style="color:#a90d91">def</span> <span style="color:#000">fields</span>():
    <span style="color:#000">name_gen</span> <span style="color:#000">=</span> (<span style="color:#000">random</span><span style="color:#000">.</span><span style="color:#000">choice</span>(<span style="color:#000">string</span><span style="color:#000">.</span><span style="color:#000">ascii_uppercase</span>) <span style="color:#a90d91">for</span> <span style="color:#000">_</span> <span style="color:#000">in</span> <span style="color:#a90d91">range</span>(<span style="color:#1c01ce">10</span>))
    <span style="color:#000">name</span> <span style="color:#000">=</span> <span style="color:#c41a16">&#34;&#34;</span><span style="color:#000">.</span><span style="color:#000">join</span>(<span style="color:#000">name_gen</span>)
    <span style="color:#000">price</span> <span style="color:#000">=</span> <span style="color:#000">random</span><span style="color:#000">.</span><span style="color:#000">randint</span>(<span style="color:#1c01ce">10000</span>, <span style="color:#1c01ce">99999</span>)
    <span style="color:#a90d91">return</span> (<span style="color:#000">name</span>, <span style="color:#000">price</span>)

<span style="color:#a90d91">def</span> <span style="color:#000">measure</span>(<span style="color:#000">name</span>, <span style="color:#000">fn</span>, <span style="color:#000">n</span><span style="color:#000">=</span><span style="color:#1c01ce">10_000</span>):
    <span style="color:#000">pets</span> <span style="color:#000">=</span> [<span style="color:#000">fn</span>() <span style="color:#a90d91">for</span> <span style="color:#000">_</span> <span style="color:#000">in</span> <span style="color:#a90d91">range</span>(<span style="color:#000">n</span>)]
    <span style="color:#000">size</span> <span style="color:#000">=</span> <span style="color:#a90d91">round</span>(<span style="color:#000">asizeof</span>(<span style="color:#000">pets</span>) <span style="color:#000">/</span> <span style="color:#000">n</span>)
    <span style="color:#a90d91">print</span>(<span style="color:#c41a16">f</span><span style="color:#c41a16">&#34;Pet size (</span><span style="color:#c41a16">{</span><span style="color:#000">name</span><span style="color:#c41a16">}</span><span style="color:#c41a16">) = </span><span style="color:#c41a16">{</span><span style="color:#000">size</span><span style="color:#c41a16">}</span><span style="color:#c41a16"> bytes&#34;</span>)
    <span style="color:#a90d91">return</span> <span style="color:#000">size</span>

<span style="color:#000">baseline</span> <span style="color:#000">=</span> <span style="color:#000">measure</span>(<span style="color:#c41a16">&#34;tuple&#34;</span>, <span style="color:#000">fields</span>)
</code></pre></div><pre tabindex="0"><code>Pet size (tuple) = 161 bytes
</code></pre><p>161 байт. Будем использовать как основу для сравнения.</p>
<h2 id="датакласс-против-именованного-кортежа">Датакласс против именованного кортежа</h2>
<p>С чистыми кортежами, конечно, работать неудобно. Наверняка вы используете датакласс:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#a90d91">from</span> <span style="color:#000">dataclasses</span> <span style="color:#a90d91">import</span> <span style="color:#000">dataclass</span>

<span style="color:#000">@dataclass</span>
<span style="color:#a90d91">class</span> <span style="color:#3f6e75">PetData</span>:
    <span style="color:#000">name</span>: <span style="color:#a90d91">str</span>
    <span style="color:#000">price</span>: <span style="color:#a90d91">int</span>

<span style="color:#000">fn</span> <span style="color:#000">=</span> <span style="color:#a90d91">lambda</span>: <span style="color:#000">PetData</span>(<span style="color:#000">*</span><span style="color:#000">fields</span>())
<span style="color:#000">measure</span>(<span style="color:#c41a16">&#34;dataclass&#34;</span>, <span style="color:#000">fn</span>)
</code></pre></div><pre tabindex="0"><code>Pet size (dataclass) = 257 bytes
x1.60 to baseline
</code></pre><p>Ого, какой толстенький!</p>
<p>Попробуем использовать именованный кортеж:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#a90d91">from</span> <span style="color:#000">typing</span> <span style="color:#a90d91">import</span> <span style="color:#000">NamedTuple</span>

<span style="color:#a90d91">class</span> <span style="color:#3f6e75">PetTuple</span>(<span style="color:#000">NamedTuple</span>):
    <span style="color:#000">name</span>: <span style="color:#a90d91">str</span>
    <span style="color:#000">price</span>: <span style="color:#a90d91">int</span>


<span style="color:#000">fn</span> <span style="color:#000">=</span> <span style="color:#a90d91">lambda</span>: <span style="color:#000">PetTuple</span>(<span style="color:#000">*</span><span style="color:#000">fields</span>())
<span style="color:#000">measure</span>(<span style="color:#c41a16">&#34;named tuple&#34;</span>, <span style="color:#000">fn</span>)
</code></pre></div><pre tabindex="0"><code>Pet size (named tuple) = 161 bytes
x1.00 to baseline
</code></pre><p>Теперь вы понимаете, за что я его <a href="/namedtuple/">так люблю</a>. Удобный интерфейс как у датакласса — а вес как у кортежа. Идеально. Или нет?</p>
<h2 id="слоты">Слоты</h2>
<p>В Python 3.10 приехали датаклассы со слотами:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#000">@dataclass</span>(<span style="color:#000">slots</span><span style="color:#000">=</span><span style="color:#a90d91">True</span>)
<span style="color:#a90d91">class</span> <span style="color:#3f6e75">PetData</span>:
    <span style="color:#000">name</span>: <span style="color:#a90d91">str</span>
    <span style="color:#000">price</span>: <span style="color:#a90d91">int</span>


<span style="color:#000">fn</span> <span style="color:#000">=</span> <span style="color:#a90d91">lambda</span>: <span style="color:#000">PetData</span>(<span style="color:#000">*</span><span style="color:#000">fields</span>())
<span style="color:#000">measure</span>(<span style="color:#c41a16">&#34;dataclass w/slots&#34;</span>, <span style="color:#000">fn</span>)
</code></pre></div><pre tabindex="0"><code>Pet size (dataclass w/slots) = 153 bytes
x0.95 to baseline
</code></pre><p>Ого! Магия слотов создает специальные худощавые объекты, у которых внутри нет словаря, в отличие от обычных питонячих объектов. И такой датакласс ничуть не уступает кортежу.</p>
<p>Что делать, если 3.10 вам еще не завезли? Использовать <code>NamedTuple</code>. Или прописывать слоты вручную:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#000">@dataclass</span>
<span style="color:#a90d91">class</span> <span style="color:#3f6e75">PetData</span>:
    <span style="color:#000">__slots__</span> <span style="color:#000">=</span> (<span style="color:#c41a16">&#34;name&#34;</span>, <span style="color:#c41a16">&#34;price&#34;</span>)
    <span style="color:#000">name</span>: <span style="color:#a90d91">str</span>
    <span style="color:#000">price</span>: <span style="color:#a90d91">int</span>
</code></pre></div><p>У слотовых объектов есть свои недостатки. Но они отлично подходят для простых случаев (без наследования и прочих наворотов).</p>
<h2 id="другие-варианты">Другие варианты</h2>
<p>Для объективности рассмотрим и альтернативы.</p>
<p>Обычный класс по размеру не отличается от датакласса:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#a90d91">class</span> <span style="color:#3f6e75">PetClass</span>:
    <span style="color:#a90d91">def</span> <span style="color:#000">__init__</span>(<span style="color:#5b269a">self</span>, <span style="color:#000">name</span>: <span style="color:#a90d91">str</span>, <span style="color:#000">price</span>: <span style="color:#a90d91">int</span>):
        <span style="color:#5b269a">self</span><span style="color:#000">.</span><span style="color:#000">name</span> <span style="color:#000">=</span> <span style="color:#000">name</span>
        <span style="color:#5b269a">self</span><span style="color:#000">.</span><span style="color:#000">price</span> <span style="color:#000">=</span> <span style="color:#000">price</span>
</code></pre></div><pre tabindex="0"><code>Pet size (class) = 257 bytes
x1.60 to baseline
</code></pre><p>И «замороженный» (неизменяемый) датакласс тоже:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#000">@dataclass</span>(<span style="color:#000">frozen</span><span style="color:#000">=</span><span style="color:#a90d91">True</span>)
<span style="color:#a90d91">class</span> <span style="color:#3f6e75">PetDataFrozen</span>:
    <span style="color:#000">name</span>: <span style="color:#a90d91">str</span>
    <span style="color:#000">price</span>: <span style="color:#a90d91">int</span>
</code></pre></div><pre tabindex="0"><code>Pet size (frozen dataclass) = 257 bytes
x1.60 to baseline
</code></pre><p>Pydantic-модель ставит антирекорд (неудивительно, она ведь использует наследование):</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#a90d91">from</span> <span style="color:#000">pydantic</span> <span style="color:#a90d91">import</span> <span style="color:#000">BaseModel</span>

<span style="color:#a90d91">class</span> <span style="color:#3f6e75">PetModel</span>(<span style="color:#000">BaseModel</span>):
    <span style="color:#000">name</span>: <span style="color:#a90d91">str</span>
    <span style="color:#000">price</span>: <span style="color:#a90d91">int</span>
</code></pre></div><pre tabindex="0"><code>Pet size (pydantic) = 385 bytes
x2.39 to baseline
</code></pre><h2 id="настоящий-победитель">Настоящий победитель</h2>
<p>Конечно, настоящий победитель — numpy-массив. Но с ним неинтересно соревноваться ツ</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#a90d91">import</span> <span style="color:#000">string</span>
<span style="color:#a90d91">import</span> <span style="color:#000">numpy</span> <span style="color:#a90d91">as</span> <span style="color:#000">np</span>

<span style="color:#000">PetNumpy</span> <span style="color:#000">=</span> <span style="color:#000">np</span><span style="color:#000">.</span><span style="color:#000">dtype</span>([(<span style="color:#c41a16">&#34;name&#34;</span>, <span style="color:#c41a16">&#34;S10&#34;</span>), (<span style="color:#c41a16">&#34;price&#34;</span>, <span style="color:#c41a16">&#34;i4&#34;</span>)])
<span style="color:#000">generator</span> <span style="color:#000">=</span> (<span style="color:#000">fields</span>() <span style="color:#a90d91">for</span> <span style="color:#000">_</span> <span style="color:#000">in</span> <span style="color:#a90d91">range</span>(<span style="color:#000">n</span>))
<span style="color:#000">pets</span> <span style="color:#000">=</span> <span style="color:#000">np</span><span style="color:#000">.</span><span style="color:#000">fromiter</span>(<span style="color:#000">generator</span>, <span style="color:#000">dtype</span><span style="color:#000">=</span><span style="color:#000">PetNumpy</span>)
<span style="color:#000">size</span> <span style="color:#000">=</span> <span style="color:#a90d91">round</span>(<span style="color:#000">asizeof</span>(<span style="color:#000">pets</span>) <span style="color:#000">/</span> <span style="color:#000">n</span>)
</code></pre></div><pre tabindex="0"><code>Pet size (structured array) = 14 bytes
x0.09 to baseline
</code></pre><p>А я все равно предпочитаю именованные кортежи.</p>
<p><a href="https://colab.research.google.com/drive/1oKl4rda2apWORLxYYtN9J49r3Mj3L6J9?usp=sharing">песочница</a></p>
<div class="row">
<div class="col-xs-12 col-sm-4">
<figure><img alt="Кортеж" src="tuple.png"></figure>
</div>
<div class="col-xs-12 col-sm-4">
<figure><img alt="Датакласс" src="dataclass.png"></figure>
</div>
<div class="col-xs-12 col-sm-4">
<figure><img alt="Именованный кортеж" src="named-tuple.png"></figure>
</div>
</div>
<div class="row">
<div class="col-xs-12 col-sm-4">
<figure><img alt="Датакласс со слотами" src="dataclass-slots.png"></figure>
</div>
<div class="col-xs-12 col-sm-4">
<figure><img alt="Ручные слоты" src="manual-slots.png"></figure>
</div>
<div class="col-xs-12 col-sm-4">
<figure><img alt="numpy-массив" src="np-array.png"></figure>
</div>
</div>
]]></content:encoded></item><item><title>Новости стандартной библиотеки Python</title><link>https://antonz.ru/python-stdlib-changes/</link><pubDate>Wed, 11 May 2022 12:40:00 +0000</pubDate><guid>https://antonz.ru/python-stdlib-changes/</guid><description>17 модулей с новыми фичами и доработками.</description><content:encoded><![CDATA[<p>Когда выходит очередная версия Python, все внимание достается новым фичам языка: моржовому оператору, слиянию словарей, паттерн-матчингу. Еще много пишут об изменениях в асинхронной работе (модуль <code>asyncio</code>) и типизации (модуль <code>typing</code>) — эти модули на виду и бурно развиваются.</p>
<p>Остальным модулям стандартной библиотеки достается незаслуженно мало внимания. Хочу это исправить и рассказать, что интересного появилось в версиях 3.8–3.10.</p>
<p>Планировал небольшую заметку, но не преуспел: получилась здоровенная статья. Старался выбрать только самое интересное, но все равно в обзор попали аж 17 модулей. Питон, он такой 😁</p>
<p><a href="https://habr.com/ru/post/665020/">продолжение на хабре</a></p>
]]></content:encoded></item><item><title>Вычисляемые столбцы в SQLite</title><link>https://antonz.ru/generated-columns/</link><pubDate>Sat, 07 May 2022 17:10:00 +0000</pubDate><guid>https://antonz.ru/generated-columns/</guid><description>Чтобы не повторять сложные выражения в каждом запросе.</description><content:encoded><![CDATA[<p>Иногда поле в запросе рассчитывают на основе других столбцов таблицы. Например, есть столбец <code>income</code> с годовым доходом и <code>tax_rate</code> с налоговой ставкой:</p>
<pre tabindex="0"><code>┌────────┬──────────┐
│ income │ tax_rate │
├────────┼──────────┤
│ 70     │ 0.22     │
│ 84     │ 0.22     │
│ 90     │ 0.24     │
└────────┴──────────┘
</code></pre><p>Можно посчитать годовой налог:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#a90d91">select</span>
  <span style="color:#000">id</span>,
  <span style="color:#000">income</span> <span style="color:#000">*</span> <span style="color:#000">tax_rate</span> <span style="color:#a90d91">as</span> <span style="color:#000">tax</span>
<span style="color:#a90d91">from</span> <span style="color:#000">people</span>;
</code></pre></div><p>А чтобы не таскать везде это выражение, удобно создать виртуальный <em>вычисляемый столбец</em> (generated column):</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#a90d91">alter</span> <span style="color:#a90d91">table</span> <span style="color:#000">people</span>
<span style="color:#a90d91">add</span> <span style="color:#a90d91">column</span> <span style="color:#000">tax</span> <span style="color:#a90d91">real</span> <span style="color:#a90d91">as</span> (
  <span style="color:#000">income</span> <span style="color:#000">*</span> <span style="color:#000">tax_rate</span>
);
</code></pre></div><p>После этого столбец можно использовать в запросах точно так же, как обычные столбцы:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#a90d91">select</span> <span style="color:#000">id</span>, <span style="color:#000">tax</span>
<span style="color:#a90d91">from</span> <span style="color:#000">people</span>;
</code></pre></div><p>Виртуальные столбцы не хранятся в базе и рассчитываются «на лету». Но по ним вполне можно построить индекс, чтобы ускорить выборку.</p>
<blockquote>
<p>Строго говоря, в SQLite есть <em>виртуальные</em> (virtual) вычисляемые столбцы и <em>хранимые</em> (stored). Хранимые сохраняются на диске, но создать их через <code>alter table</code> невозможно, поэтому в основном пользуются виртуальными.</p>
</blockquote>
<p>В общем виде синтаксис вычисляемых столбцов такой:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#a90d91">alter</span> <span style="color:#a90d91">table</span> <span style="color:#000">ТАБЛИЦА</span>
<span style="color:#a90d91">add</span> <span style="color:#a90d91">column</span> <span style="color:#000">СТОЛБЕЦ</span> <span style="color:#000">ТИП</span> <span style="color:#a90d91">as</span> (<span style="color:#000">ВЫРАЖЕНИЕ</span>);
</code></pre></div><p>Вычисляемые столбцы могут использовать любые колонки таблицы, но не другие таблицы и не результаты подзапросов. Оно и к лучшему: для более сложных комбинаций есть <em>представления</em> (views) и <em>временные таблицы</em> (temp tables). Но о них как-нибудь в другой раз.</p>
<p><a href="https://sqlite.org/gencol.html">документация</a> • <a href="https://sqlime.org/#gist:5208177f89a0e38ccfae8ead90a35631">песочница</a></p>
]]></content:encoded></item><item><title>Постраничный итератор в Python</title><link>https://antonz.ru/page-iterator/</link><pubDate>Mon, 02 May 2022 13:00:00 +0000</pubDate><guid>https://antonz.ru/page-iterator/</guid><description>Обходим датасет страницами для быстрой пакетной обработки.</description><content:encoded><![CDATA[<p>Предположим, вы считаете статистику по огромному датасету игрушек, проданных по всей стране за прошлый год:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#000">reader</span> <span style="color:#000">=</span> <span style="color:#000">fetch_toys</span>()
<span style="color:#a90d91">for</span> <span style="color:#000">item</span> <span style="color:#000">in</span> <span style="color:#000">reader</span>:
    <span style="color:#000">process_single</span>(<span style="color:#000">item</span>)
</code></pre></div><p><code>process_single()</code> занимает 10 мс, так что 400 млн игрушек обработаются за 46 дней 😱</p>
<p>В результате оживленного диалога вам удается убедить разработчиков, что так не очень быстро. На свет появляется функция <code>process_batch()</code>, которая обрабатывает 10000 игрушек за 1 сек. Это уже 11 часов на все игрушки, что значительно приятнее.</p>
<p>Как бы теперь пройти по датасету пакетами по 10 тысяч записей? Тут и пригодится постраничный итератор!</p>
<h2 id="наивный-постраничник">Наивный постраничник</h2>
<p>Пройдем по исходной последовательности, постепенно заполняя страницу. Как заполнится — отдадим через <code>yield</code> и начнем заполнять следующую. Будем продолжать, пока исходная последовательность не закончится:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#a90d91">def</span> <span style="color:#000">paginate</span>(<span style="color:#000">iterable</span>, <span style="color:#000">page_size</span>):
    <span style="color:#000">page</span> <span style="color:#000">=</span> []
    <span style="color:#a90d91">for</span> <span style="color:#000">item</span> <span style="color:#000">in</span> <span style="color:#000">iterable</span>:
        <span style="color:#000">page</span><span style="color:#000">.</span><span style="color:#000">append</span>(<span style="color:#000">item</span>)
        <span style="color:#a90d91">if</span> <span style="color:#a90d91">len</span>(<span style="color:#000">page</span>) <span style="color:#000">==</span> <span style="color:#000">page_size</span>:
            <span style="color:#a90d91">yield</span> <span style="color:#000">page</span>
            <span style="color:#000">page</span> <span style="color:#000">=</span> []
    <span style="color:#a90d91">yield</span> <span style="color:#000">page</span>
</code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#000">reader</span> <span style="color:#000">=</span> <span style="color:#000">fetch_toys</span>()
<span style="color:#000">page_size</span> <span style="color:#000">=</span> <span style="color:#1c01ce">10_000</span>
<span style="color:#a90d91">for</span> <span style="color:#000">page</span> <span style="color:#000">in</span> <span style="color:#000">paginate</span>(<span style="color:#000">reader</span>, <span style="color:#000">page_size</span>):
    <span style="color:#000">process_batch</span>(<span style="color:#000">page</span>)
</code></pre></div><p>Реализация рабочая, но есть проблемка. Такой постраничный обход заметно медленнее обычного итерирования по одной записи.</p>
<h2 id="скорость-обхода">Скорость обхода</h2>
<p>Сравним два обхода — одиночный и постраничный:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#a90d91">def</span> <span style="color:#000">one_by_one</span>(<span style="color:#000">a</span>, <span style="color:#000">b</span>):
    <span style="color:#c41a16">&#34;&#34;&#34;Processes records one-by-one, without pagination&#34;&#34;&#34;</span>
    <span style="color:#000">rdr</span> <span style="color:#000">=</span> <span style="color:#000">reader</span>(<span style="color:#000">a</span>, <span style="color:#000">b</span>)
    <span style="color:#a90d91">for</span> <span style="color:#000">record</span> <span style="color:#000">in</span> <span style="color:#000">rdr</span>:
        <span style="color:#000">process_single</span>(<span style="color:#000">record</span>)

<span style="color:#a90d91">def</span> <span style="color:#000">batch</span>(<span style="color:#000">page_size</span>, <span style="color:#000">a</span>, <span style="color:#000">b</span>):
    <span style="color:#c41a16">&#34;&#34;&#34;Processes records in batches, with pagination&#34;&#34;&#34;</span>
    <span style="color:#000">rdr</span> <span style="color:#000">=</span> <span style="color:#000">reader</span>(<span style="color:#000">a</span>, <span style="color:#000">b</span>)
    <span style="color:#a90d91">for</span> <span style="color:#000">page</span> <span style="color:#000">in</span> <span style="color:#000">paginate</span>(<span style="color:#000">rdr</span>, <span style="color:#000">page_size</span>):
        <span style="color:#000">process_batch</span>(<span style="color:#000">page</span>)

<span style="color:#000">times</span> <span style="color:#000">=</span> <span style="color:#1c01ce">10</span>

<span style="color:#000">page_size</span> <span style="color:#000">=</span> <span style="color:#1c01ce">10_000</span>
<span style="color:#000">a</span> <span style="color:#000">=</span> <span style="color:#1c01ce">1_000_000</span>
<span style="color:#000">b</span> <span style="color:#000">=</span> <span style="color:#1c01ce">2_000_000</span>

<span style="color:#000">fn</span> <span style="color:#000">=</span> <span style="color:#a90d91">lambda</span>: <span style="color:#000">one_by_one</span>(<span style="color:#000">a</span>, <span style="color:#000">b</span>)
<span style="color:#000">total</span> <span style="color:#000">=</span> <span style="color:#000">timeit</span><span style="color:#000">.</span><span style="color:#000">timeit</span>(<span style="color:#000">fn</span>, <span style="color:#000">number</span><span style="color:#000">=</span><span style="color:#000">times</span>)
<span style="color:#000">it_time</span> <span style="color:#000">=</span> <span style="color:#a90d91">round</span>(<span style="color:#000">total</span> <span style="color:#000">*</span> <span style="color:#1c01ce">1000</span> <span style="color:#000">/</span> <span style="color:#000">times</span>)
<span style="color:#a90d91">print</span>(<span style="color:#c41a16">f</span><span style="color:#c41a16">&#34;One-by-one (baseline): </span><span style="color:#c41a16">{</span><span style="color:#000">it_time</span><span style="color:#c41a16">}</span><span style="color:#c41a16"> ms&#34;</span>)

<span style="color:#000">fn</span> <span style="color:#000">=</span> <span style="color:#a90d91">lambda</span>: <span style="color:#000">batch</span>(<span style="color:#000">page_size</span>, <span style="color:#000">a</span>, <span style="color:#000">b</span>)
<span style="color:#000">total</span> <span style="color:#000">=</span> <span style="color:#000">timeit</span><span style="color:#000">.</span><span style="color:#000">timeit</span>(<span style="color:#000">fn</span>, <span style="color:#000">number</span><span style="color:#000">=</span><span style="color:#000">times</span>)
<span style="color:#000">it_time</span> <span style="color:#000">=</span> <span style="color:#a90d91">round</span>(<span style="color:#000">total</span> <span style="color:#000">*</span> <span style="color:#1c01ce">1000</span> <span style="color:#000">/</span> <span style="color:#000">times</span>)
<span style="color:#a90d91">print</span>(<span style="color:#c41a16">f</span><span style="color:#c41a16">&#34;Fill page with append(): </span><span style="color:#c41a16">{</span><span style="color:#000">it_time</span><span style="color:#c41a16">}</span><span style="color:#c41a16"> ms&#34;</span>)
</code></pre></div><p>Вот результат на 1 млн записей и странице размером в 10 тысяч:</p>
<pre tabindex="0"><code>One-by-one (baseline):   161 ms
Fill page with append(): 227 ms
</code></pre><p>Постраничный обход медленнее почти в полтора раза!</p>
<p>Дело в том, что на каждой итерации цикла мы создаем новый пустой список и затем постепенно заполняем его. Питону приходится постоянно увеличивать размер массива под списком, а это затратная операция — O(n) от количества элементов в списке.</p>
<h2 id="фиксированная-страница">Фиксированная страница</h2>
<p>Попробуем заранее создать список нужной длины и использовать его для всех страниц.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#a90d91">def</span> <span style="color:#000">paginate</span>(<span style="color:#000">iterable</span>, <span style="color:#000">page_size</span>):
    <span style="color:#000">page</span> <span style="color:#000">=</span> [<span style="color:#a90d91">None</span>] <span style="color:#000">*</span> <span style="color:#000">page_size</span>
    <span style="color:#000">idx</span> <span style="color:#000">=</span> <span style="color:#1c01ce">0</span>
    <span style="color:#a90d91">for</span> <span style="color:#000">item</span> <span style="color:#000">in</span> <span style="color:#000">iterable</span>:
        <span style="color:#000">page</span>[<span style="color:#000">idx</span>] <span style="color:#000">=</span> <span style="color:#000">item</span>
        <span style="color:#000">idx</span> <span style="color:#000">+=</span> <span style="color:#1c01ce">1</span>
        <span style="color:#a90d91">if</span> <span style="color:#000">idx</span> <span style="color:#000">==</span> <span style="color:#000">page_size</span>:
            <span style="color:#a90d91">yield</span> <span style="color:#000">page</span>
            <span style="color:#000">idx</span> <span style="color:#000">=</span> <span style="color:#1c01ce">0</span>
    <span style="color:#a90d91">yield</span> <span style="color:#000">page</span>[:<span style="color:#000">idx</span>]
</code></pre></div><p>Повторим сравнение:</p>
<pre tabindex="0"><code>One-by-one (baseline):   161 ms
Fill page with append(): 227 ms
Use fixed-size page:     162 ms
</code></pre><p>Заметно быстрее! Скорость сравнялась с обычным итерированим по одной записи.</p>
<h2 id="итерация-срезами">Итерация срезами</h2>
<p>Можно ли ещё быстрее? Алгоритмически — нет. А вот практически — да, если перенести как можно больше действий из кода на питоне в библиотечный код на си. В этом поможет модуль <code>itertools()</code> и его функция <code>islice()</code>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#a90d91">def</span> <span style="color:#000">paginate</span>(<span style="color:#000">iterable</span>, <span style="color:#000">page_size</span>):
    <span style="color:#000">it</span> <span style="color:#000">=</span> <span style="color:#a90d91">iter</span>(<span style="color:#000">iterable</span>)
    <span style="color:#000">slicer</span> <span style="color:#000">=</span> <span style="color:#a90d91">lambda</span>: <span style="color:#a90d91">list</span>(<span style="color:#000">itertools</span><span style="color:#000">.</span><span style="color:#000">islice</span>(<span style="color:#000">it</span>, <span style="color:#000">page_size</span>))
    <span style="color:#a90d91">return</span> <span style="color:#a90d91">iter</span>(<span style="color:#000">slicer</span>, [])
</code></pre></div><p>Вот что здесь происходит:</p>
<ul>
<li><code>islice()</code> создаёт итератор (назовем его слайсером), который обходит переданную ему последовательность, пока не выберет из нее <code>page_size</code> элементов;</li>
<li><code>list()</code> выбирает все элементы из этого маленького итератора — получается страница;</li>
<li>поскольку <code>islice()</code> работает поверх основного итератора, при следующем вызове он продолжит с того же места, где остановился до этого;</li>
<li>конструкция <code>iter(slicer, [])</code> создает итератор, который на каждом шаге вызывает слайсер;</li>
<li>таким образом, функция <code>paginate()</code> возвращает итератор, который на каждом шаге выбирает очередную страницу через слайсер, провигаясь по основной последовательности — пока она не закончится.</li>
</ul>
<p>Посмотрите, до чего хорош такой вариант:</p>
<pre tabindex="0"><code>One-by-one (baseline):   161 ms
Fill page with append(): 227 ms
Use fixed-size page:     162 ms
Use islice:               93 ms
</code></pre><p>На 40% быстрее обычного итератора по одной записи!</p>
<h2 id="итого">Итого</h2>
<p>Постраничный обход отлично работает везде, где пакетная операция выполняется сильно быстрее набора одиночных. Чтобы не писать такой обход каждый раз с нуля, удобно использовать универсальный <em>постраничный итератор</em>.</p>
<p>Постраничный итератор, который динамически заполняет список, работает медленно — из-за постоянного изменения размера массива. Лучше использовать список фиксированного размера, а еще лучше — итерацию на основе <code>itertools.islice()</code></p>
<p>Рекомендую!</p>
<p><a href="https://replit.com/@antonz/page-iterator#main.py">песочница</a></p>
]]></content:encoded></item><item><title>Многострочные запросы в консоли SQLite</title><link>https://antonz.ru/sqlite-multiline/</link><pubDate>Sun, 24 Apr 2022 21:30:00 +0000</pubDate><guid>https://antonz.ru/sqlite-multiline/</guid><description>Как отредактировать большой запрос за один раз</description><content:encoded><![CDATA[<p>Стоило написать, что отлаживать многострочные запросы <a href="/sqlite-history/">в консоли SQLite</a> неудобно, как вычитал на sqlite-форуме классный трюк:</p>
<p>Достаточно вместо <code>Enter</code> использовать для перехода на новую строку сочетание <code>Ctrl+V</code>, <code>Ctrl+J</code> — и многострочный запрос редактируется одним куском!</p>
<div class="row">
<div class="col-xs-12 col-sm-7">
<figure>
  <img alt="Консоль SQLite" src="multiline.png" class="img-bordered-thin">
</figure>
</div>
</div>
<p>Еще несколько способов, которые используют люди:</p>
<ul>
<li>Внешний редактор (<code>.shell &lt;editor&gt; &lt;file&gt;</code>)</li>
<li>Запуск из файла (<code>.read &lt;file&gt;</code>)</li>
<li>DBeaver, DataGrip или аналоги</li>
</ul>
]]></content:encoded></item><item><title>Закешировать результат вычислений в Python</title><link>https://antonz.ru/functools-cache/</link><pubDate>Wed, 20 Apr 2022 21:40:00 +0000</pubDate><guid>https://antonz.ru/functools-cache/</guid><description>С помощью декоратора @functools.lru_cache</description><content:encoded><![CDATA[<p>Предположим, написали вы функцию, которая возвращает емейл пользователя:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#a90d91">def</span> <span style="color:#000">get_user_email</span>(<span style="color:#000">user_id</span>):
    <span style="color:#000">user</span> <span style="color:#000">=</span> <span style="color:#000">find_by_id</span>(<span style="color:#000">user_id</span>)
    <span style="color:#a90d91">return</span> <span style="color:#000">user</span>[<span style="color:#c41a16">&#34;email&#34;</span>]
</code></pre></div><p>Одна беда: функция <code>find_by_id()</code> лезет в уж-ж-жасно медленную легаси-систему:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#a90d91">def</span> <span style="color:#000">find_by_id</span>(<span style="color:#000">user_id</span>):
    <span style="color:#177500"># представьте здесь медленный запрос по сети,</span>
    <span style="color:#177500"># который возвращает пользователя</span>
    <span style="color:#000">time</span><span style="color:#000">.</span><span style="color:#000">sleep</span>(<span style="color:#1c01ce">1</span>)
    <span style="color:#a90d91">return</span> { <span style="color:#c41a16">&#34;email&#34;</span>: <span style="color:#c41a16">&#34;...&#34;</span> }
</code></pre></div><p>Если 100 раз вызвать <code>get_user_email(42)</code> — будет 100 медленных запросов. Хотя по уму хватило бы и одного. Что ж, давайте приделаем простенький кеш:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#000">cache</span> <span style="color:#000">=</span> {}

<span style="color:#a90d91">def</span> <span style="color:#000">get_user_email</span>(<span style="color:#000">user_id</span>):
    <span style="color:#a90d91">if</span> <span style="color:#000">user_id</span> <span style="color:#000">not</span> <span style="color:#000">in</span> <span style="color:#000">cache</span>:
        <span style="color:#000">user</span> <span style="color:#000">=</span> <span style="color:#000">find_by_id</span>(<span style="color:#000">user_id</span>)
        <span style="color:#000">cache</span>[<span style="color:#000">user_id</span>] <span style="color:#000">=</span> <span style="color:#000">user</span>[<span style="color:#c41a16">&#34;email&#34;</span>]
    <span style="color:#a90d91">return</span> <span style="color:#000">cache</span>[<span style="color:#000">user_id</span>]
</code></pre></div><p>Вроде ничего сложного (не считая вопроса устаревания кеша, но об этом в другой раз). Но представьте, что медленных функций много, и в каждую придется приделывать такую штуку. Не слишком вдохновляет.</p>
<p>К счастью, в модуле <code>functools</code> есть декоратор <code>@lru_cache</code>. Он-то нам и пригодится. Добавляем одну строчку к исходной функции, и готово:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#000">@functools</span><span style="color:#000">.</span><span style="color:#000">lru_cache</span>(<span style="color:#000">maxsize</span><span style="color:#000">=</span><span style="color:#1c01ce">256</span>)
<span style="color:#a90d91">def</span> <span style="color:#000">get_user_email</span>(<span style="color:#000">user_id</span>):
    <span style="color:#000">user</span> <span style="color:#000">=</span> <span style="color:#000">find_by_id</span>(<span style="color:#000">user_id</span>)
    <span style="color:#a90d91">return</span> <span style="color:#000">user</span>[<span style="color:#c41a16">&#34;email&#34;</span>]
</code></pre></div><p>Теперь повторные вызовы <code>get_user_email()</code> с одним и тем же <code>user_id</code> вернут результат из кеша, не запрашивая <code>find_by_id()</code>.</p>
<p><code>@lru_cache</code> прекрасен еще тем, что автоматически вытесняет старые записи из кеша, когда их становится больше <code>maxsize</code>. Так что всю память не съест.</p>
<p>В Python 3.9 добавили еще один декоратор — <code>@functools.cache</code>. Он такой же как <code>@lru_cache</code>, только безразмерный (благодаря чему работает чуть быстрее).</p>
<p>Кешем можно управлять — посмотреть статистику хитов и промахов или почистить.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#177500"># управляем кешем</span>

<span style="color:#000">stats</span> <span style="color:#000">=</span> <span style="color:#000">get_user_email</span><span style="color:#000">.</span><span style="color:#000">cache_info</span>()
<span style="color:#a90d91">print</span>(<span style="color:#000">stats</span>)
<span style="color:#177500"># CacheInfo(hits=2, misses=3, maxsize=256, currsize=3)</span>

<span style="color:#000">get_user_email</span><span style="color:#000">.</span><span style="color:#000">cache_clear</span>()
<span style="color:#177500"># CacheInfo(hits=0, misses=0, maxsize=256, currsize=0)</span>
</code></pre></div><p>Работает кеш внутри процесса, и погибнет вместе с ним. Так что если нужно что-то более масштабируемое — посмотрите на Redis или аналоги.</p>
<p><a href="https://devdocs.io/python/library/functools#functools.lru_cache">документация</a> •
<a href="https://replit.com/@antonz/functools-cache#main.py">песочница</a></p>
]]></content:encoded></item><item><title>История команд SQLite</title><link>https://antonz.ru/sqlite-history/</link><pubDate>Sun, 17 Apr 2022 14:50:00 +0000</pubDate><guid>https://antonz.ru/sqlite-history/</guid><description>Помогает найти запрос, чтобы не вводить заново.</description><content:encoded><![CDATA[<p>Если вы используете консоль SQLite (<code>sqlite3</code> или <code>sqlite3.exe</code>), то она помнит последние 2000 выполненных команд. Чтобы повторить последнюю команду, достаточно нажать клавишу <code>↑</code>, а поиск работает по сочетанию <code>Ctrl+R</code>.</p>
<div class="row">
<div class="col-xs-12 col-sm-8">
<figure>
  <img alt="Поиск по истории" src="search.jpg">
  <figcaption>Быстрее найти старый запрос, чем вбивать заново</figcaption>
</figure>
</div>
</div>
<p>По умолчанию файл истории хранится в каталоге пользователя и называется <code>.sqlite_history</code>. Он текстовый, так что можно просматривать хоть в редакторе. Если хотите сохранить в другом месте — укажите полный путь в переменной окружения <code>SQLITE_HISTORY</code>.</p>
<div class="row">
<div class="col-xs-12 col-sm-8">
<figure>
  <img alt="Файл истории" src="history.jpg">
  <figcaption>Синхронизируйте файл истории через Яндекс-диск или Дропбокс, чтобы искать запросы на всех устройствах</figcaption>
</figure>
</div>
</div>
<p>История записывается в файл при штатном выходе из консоли, так что если «моргнет» электричество или еще что — команды, выполненные с последнего запуска sqlite3, потеряются.</p>
<p>Конечно, запись истории — не единственная фича консоли. Например, через нее удобно <a href="https://stepik.org/lesson/469658/step/1?unit=460482">импортировать и экспортировать данные</a> или работать с несколькими базами одновременно. А вот отлаживать <a href="/sqlite-multiline/">многострочные запросы</a> — не слишком удобно 🤷‍♀️</p>
]]></content:encoded></item><item><title>Гибкие типы данных в SQLite</title><link>https://antonz.ru/sqlite-types/</link><pubDate>Wed, 12 Jan 2022 15:15:00 +0000</pubDate><guid>https://antonz.ru/sqlite-types/</guid><description>Почему sqlite называют «джаваскриптом в мире баз данных».</description><content:encoded><![CDATA[<p>Люди часто не понимают, что за ерунда происходит в SQLite с типами данных. Давайте разберемся.</p>
<p>SQLite использует пять типов:</p>
<ul>
<li><code>INTEGER</code> — целые числа,</li>
<li><code>REAL</code> — действительные числа,</li>
<li><code>TEXT</code> — строки,</li>
<li><code>BLOB</code> — бинарные данные,</li>
<li><code>NULL</code> — пустое значение.</li>
</ul>
<p>Пока ничего необычного (только типов маловато по сравнению с другими СУБД).</p>
<p>А как вам такое:</p>
<blockquote>
<p>SQLite может хранить данные любого типа — вне зависимости от того, какой тип указан на столбце.</p>
</blockquote>
<p>Хотите записать число <code>3.14</code> в integer-поле? Пожалуйста (и никакого округления). Или, может быть, <code>'привет'</code> в поле типа real? Без проблем.</p>
<p>Дело в том, что SQLite хранит тип не только на столбце, но и на каждом значении в таблице. Именно поэтому в одном столбце без проблем хранятся значения разных типов. Тип на столбце используется как рекомендация: при вставке SQLite пытается привести значение к рекомендуемому типу, но если не получилось — сохраняет «как есть».</p>
<p>Это удобно для анализа данных — можно сначала все загрузить, а потом средствами SQL разбираться с проблемными значениями. Любая другая СУБД выдаст ошибку при импорте и заставит вас «шерстить» файл скриптами или вручную.</p>
<p>С другой стороны, это неожиданное поведение, за которое многие недолюбливают SQLite и даже прозвали его «JavaScript в мире баз данных». Со временем разработчики SQLite прислушались и сделали альтернативный механизм «строгих» таблиц — но о нем в другой раз.</p>
]]></content:encoded></item><item><title>Все расширения для SQLite</title><link>https://antonz.ru/sqlean/</link><pubDate>Tue, 04 Jan 2022 11:30:00 +0000</pubDate><guid>https://antonz.ru/sqlean/</guid><description>Регулярки, статистика, файлы и еще 100+ функций.</description><content:encoded><![CDATA[<p>Мне очень нравится SQLite. Это миниатюрная встраиваемая база, которая отлично подходит как для исследовательского анализа данных, так и в качестве хранилища для небольших приложений (<a href="https://habr.com/ru/post/547448/">писал об этом</a>, не буду повторяться).</p>
<p>Но есть у нее один недостаток: маловато встроенных функций по сравнению с PostgreSQL или Oracle. К счастью, авторы заложили в SQLite механизм расширений, на котором можно сделать почти все что угодно. В результате интернет заполнен обрывочными расширениями, которые добавляют функцию-другую.</p>
<p>Мне хотелось большой системности. В результате появился проект <strong>sqlean</strong> — в нем я собираю вместе недостающие в SQLite функции, распределяю их по модулям, рефакторю код, пишу тесты и документацию. Получается что-то вроде стандартной библиотеки, как в Python или Go, только для SQLite.</p>
<p>Я планирую подробно написать про каждый модуль в отдельной статье, а пока — вот краткий обзор.</p>
<h2 id="основной-набор">Основной набор</h2>
<p>Это самые популярные функции, которых не хватало в SQLite:</p>
<ul>
<li><a href="https://github.com/nalgeon/sqlean/blob/main/docs/crypto.md">crypto</a>: криптографические хеш-функции вроде MD5, SHA-1 и SHA-256.</li>
<li><a href="https://github.com/nalgeon/sqlean/blob/main/docs/fileio.md">fileio</a>: работа с файловой системой — чтение и запись файлов, создание каталогов.</li>
<li><a href="https://github.com/nalgeon/sqlean/blob/main/docs/fuzzy.md">fuzzy</a>: нечеткое сравнение строк, фонетические алгоритмы, транслитерация.</li>
<li><a href="https://github.com/nalgeon/sqlean/blob/main/docs/ipaddr.md">ipaddr</a>: манипуляция IP-адресами и подсетями.</li>
<li><a href="https://github.com/nalgeon/sqlean/blob/main/docs/json1.md">json1</a>: работа с JSON.</li>
<li><a href="https://github.com/nalgeon/sqlean/blob/main/docs/math.md">math</a>: математические функции.</li>
<li><a href="https://github.com/nalgeon/sqlean/blob/main/docs/re.md">re</a>: регулярные выражения.</li>
<li><a href="https://github.com/nalgeon/sqlean/blob/main/docs/stats.md">stats</a>: статистика — медиана, процентили, стандартное отклонение.</li>
<li><a href="https://github.com/nalgeon/sqlean/blob/main/docs/text.md">text</a>: работа со строками.</li>
<li><a href="https://github.com/nalgeon/sqlean/blob/main/docs/unicode.md">unicode</a>: поддержка юникода для функций <code>upper()</code>, <code>lower()</code> и <code>LIKE</code>.</li>
<li><a href="https://github.com/nalgeon/sqlean/blob/main/docs/uuid.md">uuid</a>: генерация уникальных идентификаторов.</li>
<li><a href="https://github.com/nalgeon/sqlean/blob/main/docs/vsv.md">vsv</a>: работа с CSV-файлами как с таблицами базы.</li>
</ul>
<p>Все расширения можно <a href="https://github.com/nalgeon/sqlean/releases/latest">скачать</a> для Windows, Linix и macOS.</p>
<h2 id="инкубатор">Инкубатор</h2>
<p>Функции, которые пока не вошли в основной набор. Эти расширения могут быть плохо структурированы, но я их постепенно рефакторю и переношу в основные.</p>
<ul>
<li><a href="https://github.com/nalgeon/sqlean/issues/27#issuecomment-1004109889">array</a>: работа с массивами (почти как в постгресе).</li>
<li><a href="https://github.com/nalgeon/sqlean/issues/27#issuecomment-999732640">besttype</a>: преобразует строку в подходящий числовой тип.</li>
<li><a href="https://github.com/nalgeon/sqlean/issues/27#issuecomment-1002267134">bloom</a>: быстрый вероятностный способ понять, есть значение в таблице или нет.</li>
<li><a href="https://github.com/nalgeon/sqlean/issues/27#issuecomment-996605444">cbrt</a>: кубический корень из числа.</li>
<li><a href="https://github.com/nalgeon/sqlean/issues/27#issuecomment-1001239676">classifier</a>: бинарный классификатор на логистической регрессии.</li>
<li><a href="https://github.com/nalgeon/sqlean/issues/27#issuecomment-1000937999">compress</a> и <a href="https://github.com/nalgeon/sqlean/issues/27#issuecomment-1000938046">sqlar</a>: архивация и распаковка данных.</li>
<li><a href="https://github.com/nalgeon/sqlean/issues/27#issuecomment-997427979">cron</a>: проверяет даты по cron-шаблонам.</li>
<li><a href="https://github.com/nalgeon/sqlean/issues/27#issuecomment-1004347222">define</a>: динамически создает скалярные и табличные функции прямо из SQL.</li>
<li><a href="https://github.com/nalgeon/sqlean/issues/27#issuecomment-997423609">envfuncs</a>: читает переменные среды.</li>
<li><a href="https://github.com/nalgeon/sqlean/issues/27#issuecomment-996432840">eval</a>: выполняет произвольные SQL-запросы.</li>
<li><a href="https://github.com/nalgeon/sqlean/issues/27#issuecomment-997482625">fcmp</a>: сравнение и округление десятичных дробей.</li>
<li><a href="https://github.com/nalgeon/sqlean/issues/27#issuecomment-998138191">isodate</a>: дополнительные функции для работы с датами.</li>
<li><a href="https://github.com/nalgeon/sqlean/issues/27#issuecomment-999128539">math2</a>: больше математических функций и битовой арифметики.</li>
<li><a href="https://github.com/nalgeon/sqlean/issues/27#issuecomment-997417836">pearson</a>: корреляция Пирсона между двумя наборами данных.</li>
<li><a href="https://github.com/nalgeon/sqlean/issues/27#issuecomment-997052157">pivotvtab</a>: сводные таблицы.</li>
<li><a href="https://github.com/nalgeon/sqlean/issues/27#issuecomment-999732907">recsize</a>: считает размер записи в таблице.</li>
<li><a href="https://github.com/nalgeon/sqlean/issues/27#issuecomment-1002297477">spellfix</a>: быстрый поиск похожих слов в словаре.</li>
<li><a href="https://github.com/nalgeon/sqlean/issues/27#issuecomment-1000902666">stats2</a> и <a href="https://github.com/nalgeon/sqlean/issues/27#issuecomment-1002703581">stats3</a>: еще больше матстатистики.</li>
<li><a href="https://github.com/nalgeon/sqlean/issues/27#issuecomment-1003105288">text2</a>: еще больше функций для работы со строками.</li>
<li><a href="https://github.com/nalgeon/sqlean/issues/27#issuecomment-1001232670">uint</a>: натуральная сортировка и сравнение строк, содержащих числа (natsort).</li>
<li><a href="https://github.com/nalgeon/sqlean/issues/27#issuecomment-997432989">unhex</a>: преобразует строку в бинарные данные (обратная операция для <code>hex()</code>).</li>
<li><a href="https://github.com/nalgeon/sqlean/issues/27#issuecomment-997018486">xmltojson</a>: преобразует XML в JSON.</li>
<li><a href="https://github.com/nalgeon/sqlean/issues/27#issuecomment-1001190336">zipfile</a>: читает и пишет zip-архивы.</li>
</ul>
<p><a href="https://github.com/nalgeon/sqlean/issues/27">Голосуйте</a> за расширения в инкубаторе! Чем популярнее расширение, тем быстрее оно попадет в основной набор.</p>
<p>Инкубаторные расширения тоже можно <a href="https://github.com/nalgeon/sqlean/releases/tag/incubator">скачать</a>.</p>
<h2 id="как-подключить-расширение">Как подключить расширение</h2>
<p>Есть три способа. Если работаете с командной строкой SQLite (<code>sqlite.exe</code>):</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#000">sqlite</span><span style="color:#000">&gt;</span> .<span style="color:#a90d91">load</span> .<span style="color:#000">/</span><span style="color:#000">stats</span>
<span style="color:#000">sqlite</span><span style="color:#000">&gt;</span> <span style="color:#a90d91">select</span> <span style="color:#000">median</span>(<span style="color:#000">value</span>) <span style="color:#a90d91">from</span> <span style="color:#000">generate_series</span>(<span style="color:#1c01ce">1</span>, <span style="color:#1c01ce">99</span>);
</code></pre></div><p>Если используете инструмент вроде DB Browser for SQLite, SQLite Expert или DBeaver:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#a90d91">select</span> <span style="color:#000">load_extension</span>(<span style="color:#c41a16">&#39;c:\Users\anton\sqlite\stats.dll&#39;</span>);
<span style="color:#a90d91">select</span> <span style="color:#000">median</span>(<span style="color:#000">value</span>) <span style="color:#a90d91">from</span> <span style="color:#000">generate_series</span>(<span style="color:#1c01ce">1</span>, <span style="color:#1c01ce">99</span>);
</code></pre></div><p>Если работаете из Python (в других языках аналогично):</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#a90d91">import</span> <span style="color:#000">sqlite3</span>

<span style="color:#000">connection</span> <span style="color:#000">=</span> <span style="color:#000">sqlite3</span><span style="color:#000">.</span><span style="color:#000">connect</span>(<span style="color:#c41a16">&#34;:memory:&#34;</span>)
<span style="color:#000">connection</span><span style="color:#000">.</span><span style="color:#000">enable_load_extension</span>(<span style="color:#a90d91">True</span>)
<span style="color:#000">connection</span><span style="color:#000">.</span><span style="color:#000">load_extension</span>(<span style="color:#c41a16">&#34;./stats.so&#34;</span>)
<span style="color:#000">connection</span><span style="color:#000">.</span><span style="color:#000">execute</span>(<span style="color:#c41a16">&#34;select median(value) from generate_series(1, 99)&#34;</span>)
<span style="color:#000">connection</span><span style="color:#000">.</span><span style="color:#000">close</span>()
</code></pre></div><h2 id="что-дальше">Что дальше</h2>
<p>Если почувствуете, что в SQLite вам не хватает какой-то функции — приходите в репозиторий <a href="https://github.com/nalgeon/sqlean"><strong>sqlean</strong></a>, там наверняка найдется.</p>
<p>Я продолжаю добавлять новые расширения в инкубатор, а расширения из инкубатора рефакторю и переношу в основные. По каждому основному модулю планирую написать отдельную статью с примерами.</p>
<p>А если захотите поучаствовать — присылайте <a href="https://github.com/nalgeon/sqlean/blob/incubator/docs/submit.md">свои</a> или <a href="https://github.com/nalgeon/sqlean/blob/incubator/docs/external.md">чужие</a> расширения.</p>
<p>Всем SQLite!</p>
]]></content:encoded></item><item><title>2022</title><link>https://antonz.ru/2022/</link><pubDate>Sat, 01 Jan 2022 00:00:00 +0000</pubDate><guid>https://antonz.ru/2022/</guid><description/><content:encoded></content:encoded></item></channel></rss>