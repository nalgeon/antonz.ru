<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Антон Жиянов</title><description>Разработка софта, продуктоводство и здравый смысл</description><link>https://antonz.ru/</link><image><url>https://antonz.ru/assets/favicon/favicon.png</url><title>Антон Жиянов</title><link>https://antonz.ru/</link></image><generator>Hugo -- gohugo.io</generator><language>ru-ru</language><lastBuildDate>Mon, 23 May 2022 15:30:00 +0000</lastBuildDate><atom:link href="https://antonz.ru/index.xml" rel="self" type="application/rss+xml"/><item><title>Случайные числа и последовательности в Python</title><link>https://antonz.ru/random/</link><pubDate>Mon, 23 May 2022 15:30:00 +0000</pubDate><guid>https://antonz.ru/random/</guid><description>Там намного больше, чем просто randint()</description><content:encoded><![CDATA[<p>Все знают про <code>random.randint(a, b)</code>, который возвращает случайное число в указанном диапазоне:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#000">random</span><span style="color:#000">.</span><span style="color:#000">randint</span>(<span style="color:#1c01ce">10</span>, <span style="color:#1c01ce">99</span>)
<span style="color:#177500"># 59</span>
</code></pre></div><p>Но модуль <code>random</code> предоставляет намного больше возможностей. Так много, что одной заметкой и не охватишь.</p>
<p>Например, можно выбрать из диапазона <strong>с шагом</strong>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#000">random</span><span style="color:#000">.</span><span style="color:#000">randrange</span>(<span style="color:#1c01ce">10</span>, <span style="color:#1c01ce">99</span>, <span style="color:#1c01ce">3</span>)
<span style="color:#177500"># 91</span>
</code></pre></div><p>Или случайный <strong>элемент последовательности</strong>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#000">numbers</span> <span style="color:#000">=</span> [<span style="color:#1c01ce">7</span>, <span style="color:#1c01ce">9</span>, <span style="color:#1c01ce">13</span>, <span style="color:#1c01ce">42</span>, <span style="color:#1c01ce">64</span>, <span style="color:#1c01ce">99</span>]
<span style="color:#000">random</span><span style="color:#000">.</span><span style="color:#000">choice</span>(<span style="color:#000">numbers</span>)
<span style="color:#177500"># 42</span>
</code></pre></div><p>А то и <strong>несколько</strong> элементов:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#000">numbers</span> <span style="color:#000">=</span> <span style="color:#a90d91">range</span>(<span style="color:#1c01ce">99</span>, <span style="color:#1c01ce">10</span>, <span style="color:#000">-</span><span style="color:#1c01ce">1</span>)
<span style="color:#000">random</span><span style="color:#000">.</span><span style="color:#000">choices</span>(<span style="color:#000">numbers</span>, <span style="color:#000">k</span><span style="color:#000">=</span><span style="color:#1c01ce">3</span>)
<span style="color:#177500"># [32, 62, 76]</span>
</code></pre></div><p>Можно еще и <strong>веса</strong> элементам назначить — чтобы одни выбирались чаще других:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#000">numbers</span> <span style="color:#000">=</span> [<span style="color:#1c01ce">7</span>, <span style="color:#1c01ce">9</span>, <span style="color:#1c01ce">13</span>, <span style="color:#1c01ce">42</span>, <span style="color:#1c01ce">64</span>, <span style="color:#1c01ce">99</span>]
<span style="color:#000">weights</span> <span style="color:#000">=</span> [<span style="color:#1c01ce">10</span>, <span style="color:#1c01ce">1</span>, <span style="color:#1c01ce">1</span>, <span style="color:#1c01ce">1</span>, <span style="color:#1c01ce">1</span>, <span style="color:#1c01ce">1</span>]

<span style="color:#000">random</span><span style="color:#000">.</span><span style="color:#000">choices</span>(<span style="color:#000">numbers</span>, <span style="color:#000">weights</span>, <span style="color:#000">k</span><span style="color:#000">=</span><span style="color:#1c01ce">3</span>)
<span style="color:#177500"># [42, 13, 7]</span>

<span style="color:#000">random</span><span style="color:#000">.</span><span style="color:#000">choices</span>(<span style="color:#000">numbers</span>, <span style="color:#000">weights</span>, <span style="color:#000">k</span><span style="color:#000">=</span><span style="color:#1c01ce">3</span>)
<span style="color:#177500"># [7, 7, 7]</span>

<span style="color:#000">random</span><span style="color:#000">.</span><span style="color:#000">choices</span>(<span style="color:#000">numbers</span>, <span style="color:#000">weights</span>, <span style="color:#000">k</span><span style="color:#000">=</span><span style="color:#1c01ce">3</span>)
<span style="color:#177500"># [13, 7, 7]</span>
</code></pre></div><p>Хотите выборку <strong>без повторений</strong>? Нет проблем:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#000">numbers</span> <span style="color:#000">=</span> [<span style="color:#1c01ce">7</span>, <span style="color:#1c01ce">9</span>, <span style="color:#1c01ce">13</span>, <span style="color:#1c01ce">42</span>, <span style="color:#1c01ce">64</span>, <span style="color:#1c01ce">99</span>]
<span style="color:#000">random</span><span style="color:#000">.</span><span style="color:#000">sample</span>(<span style="color:#000">numbers</span>, <span style="color:#000">k</span><span style="color:#000">=</span><span style="color:#1c01ce">3</span>)
<span style="color:#177500"># [42, 99, 7]</span>
</code></pre></div><p>Или можно всю последовательность <strong>перемешать</strong>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#000">numbers</span> <span style="color:#000">=</span> [<span style="color:#1c01ce">1</span>, <span style="color:#1c01ce">2</span>, <span style="color:#1c01ce">3</span>, <span style="color:#1c01ce">4</span>, <span style="color:#1c01ce">5</span>]
<span style="color:#000">random</span><span style="color:#000">.</span><span style="color:#000">shuffle</span>(<span style="color:#000">numbers</span>)
<span style="color:#177500"># [3, 2, 1, 5, 4]</span>
</code></pre></div><p>Еще есть вещественные распределения вроде <code>uniform()</code>, <code>gauss()</code>, <code>expovariate()</code>, <code>paretovariate()</code> и их многочисленных друзей. Не буду сейчас вдаваться в подробности — <a href="https://docs.python.org/3/library/random.html#real-valued-distributions">убедитесь сами</a>, если вы поклонник матстата.</p>
<p>И напоследок. Если используете случайные числа в тестах, всегда <strong>инициализируйте</strong> генератор константой, чтобы он давал воспроизводимые результаты:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#000">random</span><span style="color:#000">.</span><span style="color:#000">seed</span>(<span style="color:#1c01ce">42</span>)
</code></pre></div><p>А в продакшене, наоборот, вызывайте <code>seed()</code> без параметров — так питон использует генератор шума операционной системы (или текущее время, если его нет).</p>
]]></content:encoded></item><item><title>Временные таблицы в SQLite</title><link>https://antonz.ru/temp-tables/</link><pubDate>Wed, 18 May 2022 21:30:00 +0000</pubDate><guid>https://antonz.ru/temp-tables/</guid><description>Для быстрого исследовательского анализа данных.</description><content:encoded><![CDATA[<p>Бывает, хочется собрать данные из нескольких таблиц в одну, и дальше с ними поработать. Например, выбрать вакансии вместе с работодателями и регионами:</p>
<p><img src="combine-then-query.png" alt="Сводный датасет"></p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#a90d91">select</span> <span style="color:#000">v</span>.<span style="color:#000">*</span>, <span style="color:#000">e</span>.<span style="color:#000">name</span>, <span style="color:#000">a</span>.<span style="color:#000">name</span>
<span style="color:#a90d91">from</span> <span style="color:#000">vacancy</span> <span style="color:#a90d91">as</span> <span style="color:#000">v</span>
  <span style="color:#a90d91">join</span> <span style="color:#000">employer</span> <span style="color:#a90d91">as</span> <span style="color:#000">e</span> <span style="color:#a90d91">on</span> <span style="color:#000">e</span>.<span style="color:#000">id</span> <span style="color:#000">=</span> <span style="color:#000">v</span>.<span style="color:#000">employer_id</span>
  <span style="color:#a90d91">join</span> <span style="color:#000">area</span> <span style="color:#a90d91">as</span> <span style="color:#000">a</span> <span style="color:#a90d91">on</span> <span style="color:#000">a</span>.<span style="color:#000">id</span> <span style="color:#000">=</span> <span style="color:#000">v</span>.<span style="color:#000">area_id</span>
</code></pre></div><p>Вопрос, как дальше запускать запросы по сводным данным. Есть три способа это сделать:</p>
<ol>
<li>Табличное выражение (CTE)</li>
<li>Представление (view)</li>
<li>Временная таблица (temporary table)</li>
</ol>
<p><img src="cte.png" alt="CTE"></p>
<p><strong>Табличное выражение</strong> — это подзапрос с именем:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#a90d91">with</span> <span style="color:#000">combined_cte</span> <span style="color:#a90d91">as</span> (
  <span style="color:#a90d91">select</span> <span style="color:#000">v</span>.<span style="color:#000">*</span>, <span style="color:#000">e</span>.<span style="color:#000">name</span>, <span style="color:#000">a</span>.<span style="color:#000">name</span>
  <span style="color:#a90d91">from</span> <span style="color:#000">vacancy</span> <span style="color:#a90d91">as</span> <span style="color:#000">v</span>
    <span style="color:#a90d91">join</span> <span style="color:#000">employer</span> <span style="color:#a90d91">as</span> <span style="color:#000">e</span> <span style="color:#a90d91">on</span> <span style="color:#000">e</span>.<span style="color:#000">id</span> <span style="color:#000">=</span> <span style="color:#000">v</span>.<span style="color:#000">employer_id</span>
    <span style="color:#a90d91">join</span> <span style="color:#000">area</span> <span style="color:#a90d91">as</span> <span style="color:#000">a</span> <span style="color:#a90d91">on</span> <span style="color:#000">a</span>.<span style="color:#000">id</span> <span style="color:#000">=</span> <span style="color:#000">v</span>.<span style="color:#000">area_id</span>
)
<span style="color:#a90d91">select</span> ...
<span style="color:#a90d91">from</span> <span style="color:#000">combined_cte</span>
<span style="color:#a90d91">where</span> ...
<span style="color:#a90d91">group</span> <span style="color:#a90d91">by</span> ...
<span style="color:#a90d91">order</span> <span style="color:#a90d91">by</span> ...
</code></pre></div><p>Я подробно описывал CTE <a href="/cte/">в отдельной заметке</a>, так что не буду повторяться. Важно, что CTE каждый раз вычисляется заново, так что если наш сводный селект не особо быстрый — запросы по нему будут тормозить.</p>
<p><img src="view.png" alt="Представление"></p>
<p><strong>Представление</strong> работает как CTE, но к нему можно обращаться как к обычной таблице и не повторять каждый раз подзапрос. Как и CTE, представление тоже вычисляется на лету.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#177500">-- 1) create once
</span><span style="color:#177500"></span><span style="color:#a90d91">create</span> <span style="color:#a90d91">view</span> <span style="color:#000">combined_view</span> <span style="color:#a90d91">as</span>
<span style="color:#a90d91">select</span> <span style="color:#000">v</span>.<span style="color:#000">*</span>, <span style="color:#000">e</span>.<span style="color:#000">name</span>, <span style="color:#000">a</span>.<span style="color:#000">name</span>
<span style="color:#a90d91">from</span> <span style="color:#000">vacancy</span> <span style="color:#a90d91">as</span> <span style="color:#000">v</span>
  <span style="color:#a90d91">join</span> <span style="color:#000">employer</span> <span style="color:#a90d91">as</span> <span style="color:#000">e</span> <span style="color:#a90d91">on</span> <span style="color:#000">e</span>.<span style="color:#000">id</span> <span style="color:#000">=</span> <span style="color:#000">v</span>.<span style="color:#000">employer_id</span>
  <span style="color:#a90d91">join</span> <span style="color:#000">area</span> <span style="color:#a90d91">as</span> <span style="color:#000">a</span> <span style="color:#a90d91">on</span> <span style="color:#000">a</span>.<span style="color:#000">id</span> <span style="color:#000">=</span> <span style="color:#000">v</span>.<span style="color:#000">area_id</span>;

<span style="color:#177500">-- 2) use everywhere
</span><span style="color:#177500"></span><span style="color:#a90d91">select</span> ...
<span style="color:#a90d91">from</span> <span style="color:#000">combined_view</span>
<span style="color:#a90d91">where</span> ...
<span style="color:#a90d91">group</span> <span style="color:#a90d91">by</span> ...
<span style="color:#a90d91">order</span> <span style="color:#a90d91">by</span> ...
</code></pre></div><p>В PostgreSQL и других СУБД есть материализованные представления, которые сохраняют данные на диск. Но не в SQLite.</p>
<p><img src="temp-table.png" alt="Временная таблица"></p>
<p><strong>Временная таблица</strong> — такая же, как настоящая: хранит данные на диске, можно построить индексы. Но существует она, только пока открыто соединение с базой данных.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#177500">-- 1) create once
</span><span style="color:#177500"></span><span style="color:#a90d91">create</span> <span style="color:#000">temp</span> <span style="color:#a90d91">table</span> <span style="color:#000">combined_temp</span> <span style="color:#a90d91">as</span>
<span style="color:#a90d91">select</span> <span style="color:#000">v</span>.<span style="color:#000">*</span>, <span style="color:#000">e</span>.<span style="color:#000">name</span>, <span style="color:#000">a</span>.<span style="color:#000">name</span>
<span style="color:#a90d91">from</span> <span style="color:#000">vacancy</span> <span style="color:#a90d91">as</span> <span style="color:#000">v</span>
  <span style="color:#a90d91">join</span> <span style="color:#000">employer</span> <span style="color:#a90d91">as</span> <span style="color:#000">e</span> <span style="color:#a90d91">on</span> <span style="color:#000">e</span>.<span style="color:#000">id</span> <span style="color:#000">=</span> <span style="color:#000">v</span>.<span style="color:#000">employer_id</span>
  <span style="color:#a90d91">join</span> <span style="color:#000">area</span> <span style="color:#a90d91">as</span> <span style="color:#000">a</span> <span style="color:#a90d91">on</span> <span style="color:#000">a</span>.<span style="color:#000">id</span> <span style="color:#000">=</span> <span style="color:#000">v</span>.<span style="color:#000">area_id</span>;

<span style="color:#177500">-- 2) use everywhere
</span><span style="color:#177500"></span><span style="color:#a90d91">select</span> ...
<span style="color:#a90d91">from</span> <span style="color:#000">combined_temp</span>
<span style="color:#a90d91">where</span> ...
<span style="color:#a90d91">group</span> <span style="color:#a90d91">by</span> ...
<span style="color:#a90d91">order</span> <span style="color:#a90d91">by</span> ...
</code></pre></div><p>Технически, SQLite хранит временные таблицы в специальной <code>temp</code>-базе. Она лежит в отдельном файле на диске и видна только тому соединению БД, в котором была создана. Как только соединение закрывается, SQLite автоматически удаляет временную базу.</p>
<div class="boxed">
<p><strong>Где находится временная база</strong></p>
<p>На юниксо-подобных системах временная база лежит в одном из следующих каталогов:</p>
<ol>
<li>Каталог, заданный настройкой <code>PRAGMA temp_store_directory</code> (объявлена устаревшей)</li>
<li>Переменная окружения <code>SQLITE_TMPDIR</code></li>
<li>Переменная окружения <code>TMPDIR</code></li>
<li><code>/var/tmp</code></li>
<li><code>/usr/tmp</code></li>
<li><code>/tmp</code></li>
<li>Текущий рабочий каталог (<code>.</code>)</li>
</ol>
<p>SQLite выбирает первый вариант из списка, для которого есть разрешения на запись (write) и исполнение (execute).</p>
<p>Чтобы хранить временную базу в памяти, задайте настройку <code>PRAGMA temp_store = MEMORY</code>.</p>
<p><a href="https://sqlite.org/tempfiles.html">документация</a></p>
</div>
<p>Временные таблицы отлично подходят для экспериментов, когда вы только знакомитесь с данными. Можно позволить себе любые безумства — ведь после отключения от базы все будет забыто ツ</p>
]]></content:encoded></item><item><title>JSON и виртуальные столбцы в SQLite</title><link>https://antonz.ru/json-virtual-columns/</link><pubDate>Sun, 15 May 2022 11:25:00 +0000</pubDate><guid>https://antonz.ru/json-virtual-columns/</guid><description>Строим NoSQL-базу на минималках.</description><content:encoded><![CDATA[<p>У <a href="/generated-columns/">вычисляемых столбцов</a> есть еще одно чрезвычайно полезное применение.</p>
<p><img src="json-data.png" alt="JSON-данные"></p>
<p>Допустим, вы решили вести журнал событий, которые происходят в системе. События бывают разных типов, у каждого свой набор полей. Например, вход в систему:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
    <span style="color:#000">&#34;timestamp&#34;</span>: <span style="color:#c41a16">&#34;2022-05-15T09:31:00Z&#34;</span>,
    <span style="color:#000">&#34;object&#34;</span>: <span style="color:#c41a16">&#34;user&#34;</span>,
    <span style="color:#000">&#34;object_id&#34;</span>: <span style="color:#1c01ce">11</span>,
    <span style="color:#000">&#34;action&#34;</span>: <span style="color:#c41a16">&#34;login&#34;</span>,
    <span style="color:#000">&#34;details&#34;</span>: {
        <span style="color:#000">&#34;ip&#34;</span>: <span style="color:#c41a16">&#34;192.168.0.1&#34;</span>
    }
}
</code></pre></div><p>Или пополнение счета:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-json" data-lang="json">{
    <span style="color:#000">&#34;timestamp&#34;</span>: <span style="color:#c41a16">&#34;2022-05-15T09:32:00Z&#34;</span>,
    <span style="color:#000">&#34;object&#34;</span>: <span style="color:#c41a16">&#34;account&#34;</span>,
    <span style="color:#000">&#34;object_id&#34;</span>: <span style="color:#1c01ce">12</span>,
    <span style="color:#000">&#34;action&#34;</span>: <span style="color:#c41a16">&#34;deposit&#34;</span>,
    <span style="color:#000">&#34;details&#34;</span>: {
        <span style="color:#000">&#34;amount&#34;</span>: <span style="color:#c41a16">&#34;1000&#34;</span>,
        <span style="color:#000">&#34;currency&#34;</span>: <span style="color:#c41a16">&#34;USD&#34;</span>
    }
}
</code></pre></div><p><img src="json-functions.png" alt="JSON-функции"></p>
<p>Вы решаете не заниматься нормализацией по таблицам, а хранить прямо в JSON. Заводите таблицу <code>events</code> с единственным полем <code>value</code>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#a90d91">select</span> <span style="color:#000">value</span> <span style="color:#a90d91">from</span> <span style="color:#000">events</span>;
</code></pre></div><pre tabindex="0"><code>{&quot;timestamp&quot;:&quot;2022-05-15T09:31:00Z&quot;,&quot;object&quot;:&quot;user&quot;,&quot;object_id&quot;:11,&quot;action&quot;:&quot;login&quot;,&quot;details&quot;:{&quot;ip&quot;:&quot;192.168.0.1&quot;}}
{&quot;timestamp&quot;:&quot;2022-05-15T09:32:00Z&quot;,&quot;object&quot;:&quot;account&quot;,&quot;object_id&quot;:12,&quot;action&quot;:&quot;deposit&quot;,&quot;details&quot;:{&quot;amount&quot;:&quot;1000&quot;,&quot;currency&quot;:&quot;USD&quot;}}
{&quot;timestamp&quot;:&quot;2022-05-15T09:33:00Z&quot;,&quot;object&quot;:&quot;company&quot;,&quot;object_id&quot;:13,&quot;action&quot;:&quot;edit&quot;,&quot;details&quot;:{&quot;fields&quot;:[&quot;address&quot;,&quot;phone&quot;]}}
</code></pre><p>И выбираете события по конкретному объекту:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#a90d91">select</span>
  <span style="color:#000">json_extract</span>(<span style="color:#000">value</span>, <span style="color:#c41a16">&#39;$.object&#39;</span>) <span style="color:#a90d91">as</span> <span style="color:#a90d91">object</span>,
  <span style="color:#000">json_extract</span>(<span style="color:#000">value</span>, <span style="color:#c41a16">&#39;$.action&#39;</span>) <span style="color:#a90d91">as</span> <span style="color:#000">action</span>
<span style="color:#a90d91">from</span> <span style="color:#000">events</span>
<span style="color:#a90d91">where</span> <span style="color:#000">json_extract</span>(<span style="color:#000">value</span>, <span style="color:#c41a16">&#39;$.object_id&#39;</span>) <span style="color:#000">=</span> <span style="color:#1c01ce">11</span>;
</code></pre></div><pre tabindex="0"><code>┌────────┬────────┐
│ object │ action │
├────────┼────────┤
│ user   │ login  │
└────────┴────────┘
</code></pre><p>Все здорово, но <code>json_extract()</code> при вызове каждый раз парсит текст, так что на сотне тысяч записей запрос будет работать медленно. Что делать?</p>
<p><img src="json-columns.png" alt="JSON-столбцы"></p>
<p>Создать виртуальные столбцы:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#a90d91">alter</span> <span style="color:#a90d91">table</span> <span style="color:#000">events</span>
<span style="color:#a90d91">add</span> <span style="color:#a90d91">column</span> <span style="color:#000">object_id</span> <span style="color:#a90d91">integer</span>
<span style="color:#a90d91">as</span> (<span style="color:#000">json_extract</span>(<span style="color:#000">value</span>, <span style="color:#c41a16">&#39;$.object_id&#39;</span>));

<span style="color:#a90d91">alter</span> <span style="color:#a90d91">table</span> <span style="color:#000">events</span>
<span style="color:#a90d91">add</span> <span style="color:#a90d91">column</span> <span style="color:#a90d91">object</span> <span style="color:#a90d91">text</span>
<span style="color:#a90d91">as</span> (<span style="color:#000">json_extract</span>(<span style="color:#000">value</span>, <span style="color:#c41a16">&#39;$.object&#39;</span>));

<span style="color:#a90d91">alter</span> <span style="color:#a90d91">table</span> <span style="color:#000">events</span>
<span style="color:#a90d91">add</span> <span style="color:#a90d91">column</span> <span style="color:#000">action</span> <span style="color:#a90d91">text</span>
<span style="color:#a90d91">as</span> (<span style="color:#000">json_extract</span>(<span style="color:#000">value</span>, <span style="color:#c41a16">&#39;$.action&#39;</span>));
</code></pre></div><p>Построить индекс:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#a90d91">create</span> <span style="color:#a90d91">index</span> <span style="color:#000">events_object_id</span> <span style="color:#a90d91">on</span> <span style="color:#000">events</span>(<span style="color:#000">object_id</span>);
</code></pre></div><p>Теперь запрос работает моментально:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#a90d91">select</span> <span style="color:#a90d91">object</span>, <span style="color:#000">action</span>
<span style="color:#a90d91">from</span> <span style="color:#000">events</span>
<span style="color:#a90d91">where</span> <span style="color:#000">object_id</span> <span style="color:#000">=</span> <span style="color:#1c01ce">11</span>;
</code></pre></div><p>Благодаря виртуальным столбцам получилась практически NoSQL база данных ツ</p>
<p><a href="https://sqlime.org/#gist:c284f7c22684eb74b5dab92d98f7d773">песочница</a></p>
]]></content:encoded></item><item><title>Компактные объекты в Python</title><link>https://antonz.ru/compact-objects/</link><pubDate>Fri, 13 May 2022 20:25:00 +0000</pubDate><guid>https://antonz.ru/compact-objects/</guid><description>Кортеж против датакласса, пока не вмешается numpy</description><content:encoded><![CDATA[<p>Питон — объектный язык. Это здорово и удобно, пока не придется создать 10 млн объектов в памяти, которые благополучно ее и съедят. Поговорим о том, как уменьшить аппетит.</p>
<p><em>Используйте <a href="https://colab.research.google.com/drive/16GK-Xbv_kOvDC9Hfa_0O8E0Nyo4L9JwO?usp=sharing">песочницу</a>, чтобы попробовать примеры</em></p>
<h2 id="кортеж">Кортеж</h2>
<p>Допустим, есть у вас простенький объект «питомец» с атрибутами «имя» (строка) и «стоимость» (целое). Интуитивно кажется, что самое компактное предоставление — в виде кортежа:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">(<span style="color:#c41a16">&#34;Frank the Pigeon&#34;</span>, <span style="color:#1c01ce">50000</span>)
</code></pre></div><p>Замерим, сколько займет в памяти один такой красавчик:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#a90d91">import</span> <span style="color:#000">random</span>
<span style="color:#a90d91">from</span> <span style="color:#000">pympler.asizeof</span> <span style="color:#a90d91">import</span> <span style="color:#000">asizeof</span>

<span style="color:#a90d91">def</span> <span style="color:#000">fields</span>():
    <span style="color:#000">name_gen</span> <span style="color:#000">=</span> (<span style="color:#000">random</span><span style="color:#000">.</span><span style="color:#000">choice</span>(<span style="color:#000">string</span><span style="color:#000">.</span><span style="color:#000">ascii_uppercase</span>) <span style="color:#a90d91">for</span> <span style="color:#000">_</span> <span style="color:#000">in</span> <span style="color:#a90d91">range</span>(<span style="color:#1c01ce">10</span>))
    <span style="color:#000">name</span> <span style="color:#000">=</span> <span style="color:#c41a16">&#34;&#34;</span><span style="color:#000">.</span><span style="color:#000">join</span>(<span style="color:#000">name_gen</span>)
    <span style="color:#000">price</span> <span style="color:#000">=</span> <span style="color:#000">random</span><span style="color:#000">.</span><span style="color:#000">randint</span>(<span style="color:#1c01ce">10000</span>, <span style="color:#1c01ce">99999</span>)
    <span style="color:#a90d91">return</span> (<span style="color:#000">name</span>, <span style="color:#000">price</span>)

<span style="color:#a90d91">def</span> <span style="color:#000">measure</span>(<span style="color:#000">name</span>, <span style="color:#000">fn</span>, <span style="color:#000">n</span><span style="color:#000">=</span><span style="color:#1c01ce">10_000</span>):
    <span style="color:#000">pets</span> <span style="color:#000">=</span> [<span style="color:#000">fn</span>() <span style="color:#a90d91">for</span> <span style="color:#000">_</span> <span style="color:#000">in</span> <span style="color:#a90d91">range</span>(<span style="color:#000">n</span>)]
    <span style="color:#000">size</span> <span style="color:#000">=</span> <span style="color:#a90d91">round</span>(<span style="color:#000">asizeof</span>(<span style="color:#000">pets</span>) <span style="color:#000">/</span> <span style="color:#000">n</span>)
    <span style="color:#a90d91">print</span>(<span style="color:#c41a16">f</span><span style="color:#c41a16">&#34;Pet size (</span><span style="color:#c41a16">{</span><span style="color:#000">name</span><span style="color:#c41a16">}</span><span style="color:#c41a16">) = </span><span style="color:#c41a16">{</span><span style="color:#000">size</span><span style="color:#c41a16">}</span><span style="color:#c41a16"> bytes&#34;</span>)
    <span style="color:#a90d91">return</span> <span style="color:#000">size</span>

<span style="color:#000">baseline</span> <span style="color:#000">=</span> <span style="color:#000">measure</span>(<span style="color:#c41a16">&#34;tuple&#34;</span>, <span style="color:#000">fields</span>)
</code></pre></div><pre tabindex="0"><code>Pet size (tuple) = 161 bytes
</code></pre><p>161 байт. Будем использовать как основу для сравнения.</p>
<h2 id="датакласс-против-именованного-кортежа">Датакласс против именованного кортежа</h2>
<p>С чистыми кортежами, конечно, работать неудобно. Наверняка вы используете датакласс:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#a90d91">from</span> <span style="color:#000">dataclasses</span> <span style="color:#a90d91">import</span> <span style="color:#000">dataclass</span>

<span style="color:#000">@dataclass</span>
<span style="color:#a90d91">class</span> <span style="color:#3f6e75">PetData</span>:
    <span style="color:#000">name</span>: <span style="color:#a90d91">str</span>
    <span style="color:#000">price</span>: <span style="color:#a90d91">int</span>

<span style="color:#000">fn</span> <span style="color:#000">=</span> <span style="color:#a90d91">lambda</span>: <span style="color:#000">PetData</span>(<span style="color:#000">*</span><span style="color:#000">fields</span>())
<span style="color:#000">measure</span>(<span style="color:#c41a16">&#34;dataclass&#34;</span>, <span style="color:#000">fn</span>)
</code></pre></div><pre tabindex="0"><code>Pet size (dataclass) = 257 bytes
x1.60 to baseline
</code></pre><p>Ого, какой толстенький!</p>
<p>Попробуем использовать именованный кортеж:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#a90d91">from</span> <span style="color:#000">typing</span> <span style="color:#a90d91">import</span> <span style="color:#000">NamedTuple</span>

<span style="color:#a90d91">class</span> <span style="color:#3f6e75">PetTuple</span>(<span style="color:#000">NamedTuple</span>):
    <span style="color:#000">name</span>: <span style="color:#a90d91">str</span>
    <span style="color:#000">price</span>: <span style="color:#a90d91">int</span>


<span style="color:#000">fn</span> <span style="color:#000">=</span> <span style="color:#a90d91">lambda</span>: <span style="color:#000">PetTuple</span>(<span style="color:#000">*</span><span style="color:#000">fields</span>())
<span style="color:#000">measure</span>(<span style="color:#c41a16">&#34;named tuple&#34;</span>, <span style="color:#000">fn</span>)
</code></pre></div><pre tabindex="0"><code>Pet size (named tuple) = 161 bytes
x1.00 to baseline
</code></pre><p>Теперь вы понимаете, за что я его <a href="/namedtuple/">так люблю</a>. Удобный интерфейс как у датакласса — а вес как у кортежа. Идеально. Или нет?</p>
<h2 id="слоты">Слоты</h2>
<p>В Python 3.10 приехали датаклассы со слотами:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#000">@dataclass</span>(<span style="color:#000">slots</span><span style="color:#000">=</span><span style="color:#a90d91">True</span>)
<span style="color:#a90d91">class</span> <span style="color:#3f6e75">PetData</span>:
    <span style="color:#000">name</span>: <span style="color:#a90d91">str</span>
    <span style="color:#000">price</span>: <span style="color:#a90d91">int</span>


<span style="color:#000">fn</span> <span style="color:#000">=</span> <span style="color:#a90d91">lambda</span>: <span style="color:#000">PetData</span>(<span style="color:#000">*</span><span style="color:#000">fields</span>())
<span style="color:#000">measure</span>(<span style="color:#c41a16">&#34;dataclass w/slots&#34;</span>, <span style="color:#000">fn</span>)
</code></pre></div><pre tabindex="0"><code>Pet size (dataclass w/slots) = 153 bytes
x0.95 to baseline
</code></pre><p>Ого! Магия слотов создает специальные худощавые объекты, у которых внутри нет словаря, в отличие от обычных питонячих объектов. И такой датакласс ничуть не уступает кортежу.</p>
<p>Что делать, если 3.10 вам еще не завезли? Использовать <code>NamedTuple</code>. Или прописывать слоты вручную:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#000">@dataclass</span>
<span style="color:#a90d91">class</span> <span style="color:#3f6e75">PetData</span>:
    <span style="color:#000">__slots__</span> <span style="color:#000">=</span> (<span style="color:#c41a16">&#34;name&#34;</span>, <span style="color:#c41a16">&#34;price&#34;</span>)
    <span style="color:#000">name</span>: <span style="color:#a90d91">str</span>
    <span style="color:#000">price</span>: <span style="color:#a90d91">int</span>
</code></pre></div><p>У слотовых объектов есть свои недостатки. Но они отлично подходят для простых случаев (без наследования и прочих наворотов).</p>
<h2 id="numpy-массив">numpy-массив</h2>
<p>Конечно, настоящий победитель — numpy-массив:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#a90d91">import</span> <span style="color:#000">string</span>
<span style="color:#a90d91">import</span> <span style="color:#000">numpy</span> <span style="color:#a90d91">as</span> <span style="color:#000">np</span>

<span style="color:#000">PetNumpy</span> <span style="color:#000">=</span> <span style="color:#000">np</span><span style="color:#000">.</span><span style="color:#000">dtype</span>([(<span style="color:#c41a16">&#34;name&#34;</span>, <span style="color:#c41a16">&#34;S10&#34;</span>), (<span style="color:#c41a16">&#34;price&#34;</span>, <span style="color:#c41a16">&#34;i4&#34;</span>)])
<span style="color:#000">generator</span> <span style="color:#000">=</span> (<span style="color:#000">fields</span>() <span style="color:#a90d91">for</span> <span style="color:#000">_</span> <span style="color:#000">in</span> <span style="color:#a90d91">range</span>(<span style="color:#000">n</span>))
<span style="color:#000">pets</span> <span style="color:#000">=</span> <span style="color:#000">np</span><span style="color:#000">.</span><span style="color:#000">fromiter</span>(<span style="color:#000">generator</span>, <span style="color:#000">dtype</span><span style="color:#000">=</span><span style="color:#000">PetNumpy</span>)
<span style="color:#000">size</span> <span style="color:#000">=</span> <span style="color:#a90d91">round</span>(<span style="color:#000">asizeof</span>(<span style="color:#000">pets</span>) <span style="color:#000">/</span> <span style="color:#000">n</span>)
</code></pre></div><pre tabindex="0"><code>Pet size (numpy array) = 14 bytes
x0.09 to baseline
</code></pre><p>Но это не чистая победа. Если строки юникодные (тип <code>U</code> вместо <code>S</code>), выигрыш будет не таким впечатляющим:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#000">PetNumpy</span> <span style="color:#000">=</span> <span style="color:#000">np</span><span style="color:#000">.</span><span style="color:#000">dtype</span>([(<span style="color:#c41a16">&#34;name&#34;</span>, <span style="color:#c41a16">&#34;U10&#34;</span>), (<span style="color:#c41a16">&#34;price&#34;</span>, <span style="color:#c41a16">&#34;i4&#34;</span>)])
</code></pre></div><pre tabindex="0"><code>Pet size (numpy U10) = 44 bytes
x0.27 to baseline
</code></pre><p>А если длина имени не строго 10 символов, а варьируется, скажем, до 50 символов (<code>U50</code> вместо <code>U10</code>) — преимущества и вовсе сходят на нет:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#a90d91">def</span> <span style="color:#000">fields</span>():
    <span style="color:#000">name_len</span> <span style="color:#000">=</span> <span style="color:#000">random</span><span style="color:#000">.</span><span style="color:#000">randint</span>(<span style="color:#1c01ce">10</span>, <span style="color:#1c01ce">50</span>)
    <span style="color:#000">name_gen</span> <span style="color:#000">=</span> (<span style="color:#000">random</span><span style="color:#000">.</span><span style="color:#000">choice</span>(<span style="color:#000">string</span><span style="color:#000">.</span><span style="color:#000">ascii_uppercase</span>) <span style="color:#a90d91">for</span> <span style="color:#000">_</span> <span style="color:#000">in</span> <span style="color:#a90d91">range</span>(<span style="color:#000">name_len</span>))
    <span style="color:#177500"># ...</span>

<span style="color:#000">PetNumpy</span> <span style="color:#000">=</span> <span style="color:#000">np</span><span style="color:#000">.</span><span style="color:#000">dtype</span>([(<span style="color:#c41a16">&#34;name&#34;</span>, <span style="color:#c41a16">&#34;U50&#34;</span>), (<span style="color:#c41a16">&#34;price&#34;</span>, <span style="color:#c41a16">&#34;i4&#34;</span>)])
</code></pre></div><pre tabindex="0"><code>Pet size (tuple) = 179 bytes

Pet size (numpy U50) = 204 bytes
x1.14 to baseline
</code></pre><h2 id="другие-варианты">Другие варианты</h2>
<p>Для объективности рассмотрим и альтернативы.</p>
<p><strong>Обычный класс</strong> по размеру не отличается от датакласса:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#a90d91">class</span> <span style="color:#3f6e75">PetClass</span>:
    <span style="color:#a90d91">def</span> <span style="color:#000">__init__</span>(<span style="color:#5b269a">self</span>, <span style="color:#000">name</span>: <span style="color:#a90d91">str</span>, <span style="color:#000">price</span>: <span style="color:#a90d91">int</span>):
        <span style="color:#5b269a">self</span><span style="color:#000">.</span><span style="color:#000">name</span> <span style="color:#000">=</span> <span style="color:#000">name</span>
        <span style="color:#5b269a">self</span><span style="color:#000">.</span><span style="color:#000">price</span> <span style="color:#000">=</span> <span style="color:#000">price</span>
</code></pre></div><pre tabindex="0"><code>Pet size (class) = 257 bytes
x1.60 to baseline
</code></pre><p>И «<strong>замороженный</strong>» (неизменяемый) датакласс тоже:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#000">@dataclass</span>(<span style="color:#000">frozen</span><span style="color:#000">=</span><span style="color:#a90d91">True</span>)
<span style="color:#a90d91">class</span> <span style="color:#3f6e75">PetDataFrozen</span>:
    <span style="color:#000">name</span>: <span style="color:#a90d91">str</span>
    <span style="color:#000">price</span>: <span style="color:#a90d91">int</span>
</code></pre></div><pre tabindex="0"><code>Pet size (frozen dataclass) = 257 bytes
x1.60 to baseline
</code></pre><p><strong>Словарь</strong> еще хуже:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#000">names</span> <span style="color:#000">=</span> (<span style="color:#c41a16">&#34;name&#34;</span>, <span style="color:#c41a16">&#34;price&#34;</span>)
<span style="color:#000">fn</span> <span style="color:#000">=</span> <span style="color:#a90d91">lambda</span>: <span style="color:#a90d91">dict</span>(<span style="color:#a90d91">zip</span>(<span style="color:#000">names</span>, <span style="color:#000">fields</span>()))
<span style="color:#000">measure</span>(<span style="color:#c41a16">&#34;dict&#34;</span>, <span style="color:#000">fn</span>)
</code></pre></div><pre tabindex="0"><code>Pet size (dict) = 355 bytes
x1.98 to baseline
</code></pre><p><strong>Pydantic-модель</strong> ставит антирекорд (неудивительно, она ведь использует наследование):</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#a90d91">from</span> <span style="color:#000">pydantic</span> <span style="color:#a90d91">import</span> <span style="color:#000">BaseModel</span>

<span style="color:#a90d91">class</span> <span style="color:#3f6e75">PetModel</span>(<span style="color:#000">BaseModel</span>):
    <span style="color:#000">name</span>: <span style="color:#a90d91">str</span>
    <span style="color:#000">price</span>: <span style="color:#a90d91">int</span>
</code></pre></div><pre tabindex="0"><code>Pet size (pydantic) = 385 bytes
x2.39 to baseline
</code></pre><p class="align-center">⌘&nbsp;⌘&nbsp;⌘</p>
<p>Компактные (и не очень) объекты в Python:</p>
<div class="row">
<div class="col-xs-12 col-sm-4">
<figure><img alt="Кортеж" src="tuple.png"></figure>
</div>
<div class="col-xs-12 col-sm-4">
<figure><img alt="Датакласс" src="dataclass.png"></figure>
</div>
<div class="col-xs-12 col-sm-4">
<figure><img alt="Именованный кортеж" src="named-tuple.png"></figure>
</div>
</div>
<div class="row">
<div class="col-xs-12 col-sm-4">
<figure><img alt="Датакласс со слотами" src="dataclass-slots.png"></figure>
</div>
<div class="col-xs-12 col-sm-4">
<figure><img alt="Ручные слоты" src="manual-slots.png"></figure>
</div>
<div class="col-xs-12 col-sm-4">
<figure><img alt="numpy-массив" src="np-array.png"></figure>
</div>
</div>
]]></content:encoded></item><item><title>Новости стандартной библиотеки Python</title><link>https://antonz.ru/python-stdlib-changes/</link><pubDate>Wed, 11 May 2022 12:40:00 +0000</pubDate><guid>https://antonz.ru/python-stdlib-changes/</guid><description>17 модулей с новыми фичами и доработками.</description><content:encoded><![CDATA[<p>Когда выходит очередная версия Python, все внимание достается новым фичам языка: моржовому оператору, слиянию словарей, паттерн-матчингу. Еще много пишут об изменениях в асинхронной работе (модуль <code>asyncio</code>) и типизации (модуль <code>typing</code>) — эти модули на виду и бурно развиваются.</p>
<p>Остальным модулям стандартной библиотеки достается незаслуженно мало внимания. Хочу это исправить и рассказать, что интересного появилось в версиях 3.8–3.10.</p>
<p>Планировал небольшую заметку, но не преуспел: получилась здоровенная статья. Старался выбрать только самое интересное, но все равно в обзор попали аж 17 модулей. Питон, он такой 😁</p>
<p><a href="https://habr.com/ru/post/665020/">продолжение на хабре</a></p>
]]></content:encoded></item><item><title>Вычисляемые столбцы в SQLite</title><link>https://antonz.ru/generated-columns/</link><pubDate>Sat, 07 May 2022 17:10:00 +0000</pubDate><guid>https://antonz.ru/generated-columns/</guid><description>Чтобы не повторять сложные выражения в каждом запросе.</description><content:encoded><![CDATA[<p>Иногда поле в запросе рассчитывают на основе других столбцов таблицы. Например, есть столбец <code>income</code> с годовым доходом и <code>tax_rate</code> с налоговой ставкой:</p>
<pre tabindex="0"><code>┌────────┬──────────┐
│ income │ tax_rate │
├────────┼──────────┤
│ 70     │ 0.22     │
│ 84     │ 0.22     │
│ 90     │ 0.24     │
└────────┴──────────┘
</code></pre><p>Можно посчитать годовой налог:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#a90d91">select</span>
  <span style="color:#000">id</span>,
  <span style="color:#000">income</span> <span style="color:#000">*</span> <span style="color:#000">tax_rate</span> <span style="color:#a90d91">as</span> <span style="color:#000">tax</span>
<span style="color:#a90d91">from</span> <span style="color:#000">people</span>;
</code></pre></div><p>А чтобы не таскать везде это выражение, удобно создать виртуальный <em>вычисляемый столбец</em> (generated column):</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#a90d91">alter</span> <span style="color:#a90d91">table</span> <span style="color:#000">people</span>
<span style="color:#a90d91">add</span> <span style="color:#a90d91">column</span> <span style="color:#000">tax</span> <span style="color:#a90d91">real</span> <span style="color:#a90d91">as</span> (
  <span style="color:#000">income</span> <span style="color:#000">*</span> <span style="color:#000">tax_rate</span>
);
</code></pre></div><p>После этого столбец можно использовать в запросах точно так же, как обычные столбцы:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#a90d91">select</span> <span style="color:#000">id</span>, <span style="color:#000">tax</span>
<span style="color:#a90d91">from</span> <span style="color:#000">people</span>;
</code></pre></div><p>Виртуальные столбцы не хранятся в базе и рассчитываются «на лету». Но по ним вполне можно построить индекс, чтобы ускорить выборку.</p>
<blockquote>
<p>Строго говоря, в SQLite есть <em>виртуальные</em> (virtual) вычисляемые столбцы и <em>хранимые</em> (stored). Хранимые сохраняются на диске, но создать их через <code>alter table</code> невозможно, поэтому в основном пользуются виртуальными.</p>
</blockquote>
<p>В общем виде синтаксис вычисляемых столбцов такой:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#a90d91">alter</span> <span style="color:#a90d91">table</span> <span style="color:#000">ТАБЛИЦА</span>
<span style="color:#a90d91">add</span> <span style="color:#a90d91">column</span> <span style="color:#000">СТОЛБЕЦ</span> <span style="color:#000">ТИП</span> <span style="color:#a90d91">as</span> (<span style="color:#000">ВЫРАЖЕНИЕ</span>);
</code></pre></div><p>Вычисляемые столбцы могут использовать любые колонки таблицы, но не другие таблицы и не результаты подзапросов. Оно и к лучшему: для более сложных комбинаций есть <em>представления</em> (views) и <em>временные таблицы</em> (temp tables). Но о них как-нибудь в другой раз.</p>
<p><a href="https://sqlite.org/gencol.html">документация</a> • <a href="https://sqlime.org/#gist:5208177f89a0e38ccfae8ead90a35631">песочница</a></p>
]]></content:encoded></item><item><title>Постраничный итератор в Python</title><link>https://antonz.ru/page-iterator/</link><pubDate>Mon, 02 May 2022 13:00:00 +0000</pubDate><guid>https://antonz.ru/page-iterator/</guid><description>Обходим датасет страницами для быстрой пакетной обработки.</description><content:encoded><![CDATA[<p>Предположим, вы считаете статистику по огромному датасету игрушек, проданных по всей стране за прошлый год:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#000">reader</span> <span style="color:#000">=</span> <span style="color:#000">fetch_toys</span>()
<span style="color:#a90d91">for</span> <span style="color:#000">item</span> <span style="color:#000">in</span> <span style="color:#000">reader</span>:
    <span style="color:#000">process_single</span>(<span style="color:#000">item</span>)
</code></pre></div><p><code>process_single()</code> занимает 10 мс, так что 400 млн игрушек обработаются за 46 дней 😱</p>
<p>В результате оживленного диалога вам удается убедить разработчиков, что так не очень быстро. На свет появляется функция <code>process_batch()</code>, которая обрабатывает 10000 игрушек за 1 сек. Это уже 11 часов на все игрушки, что значительно приятнее.</p>
<p>Как бы теперь пройти по датасету пакетами по 10 тысяч записей? Тут и пригодится постраничный итератор!</p>
<h2 id="наивный-постраничник">Наивный постраничник</h2>
<p>Пройдем по исходной последовательности, постепенно заполняя страницу. Как заполнится — отдадим через <code>yield</code> и начнем заполнять следующую. Будем продолжать, пока исходная последовательность не закончится:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#a90d91">def</span> <span style="color:#000">paginate</span>(<span style="color:#000">iterable</span>, <span style="color:#000">page_size</span>):
    <span style="color:#000">page</span> <span style="color:#000">=</span> []
    <span style="color:#a90d91">for</span> <span style="color:#000">item</span> <span style="color:#000">in</span> <span style="color:#000">iterable</span>:
        <span style="color:#000">page</span><span style="color:#000">.</span><span style="color:#000">append</span>(<span style="color:#000">item</span>)
        <span style="color:#a90d91">if</span> <span style="color:#a90d91">len</span>(<span style="color:#000">page</span>) <span style="color:#000">==</span> <span style="color:#000">page_size</span>:
            <span style="color:#a90d91">yield</span> <span style="color:#000">page</span>
            <span style="color:#000">page</span> <span style="color:#000">=</span> []
    <span style="color:#a90d91">yield</span> <span style="color:#000">page</span>
</code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#000">reader</span> <span style="color:#000">=</span> <span style="color:#000">fetch_toys</span>()
<span style="color:#000">page_size</span> <span style="color:#000">=</span> <span style="color:#1c01ce">10_000</span>
<span style="color:#a90d91">for</span> <span style="color:#000">page</span> <span style="color:#000">in</span> <span style="color:#000">paginate</span>(<span style="color:#000">reader</span>, <span style="color:#000">page_size</span>):
    <span style="color:#000">process_batch</span>(<span style="color:#000">page</span>)
</code></pre></div><p>Реализация рабочая, но есть проблемка. Такой постраничный обход заметно медленнее обычного итерирования по одной записи.</p>
<h2 id="скорость-обхода">Скорость обхода</h2>
<p>Сравним два обхода — одиночный и постраничный:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#a90d91">def</span> <span style="color:#000">one_by_one</span>(<span style="color:#000">a</span>, <span style="color:#000">b</span>):
    <span style="color:#c41a16">&#34;&#34;&#34;Processes records one-by-one, without pagination&#34;&#34;&#34;</span>
    <span style="color:#000">rdr</span> <span style="color:#000">=</span> <span style="color:#000">reader</span>(<span style="color:#000">a</span>, <span style="color:#000">b</span>)
    <span style="color:#a90d91">for</span> <span style="color:#000">record</span> <span style="color:#000">in</span> <span style="color:#000">rdr</span>:
        <span style="color:#000">process_single</span>(<span style="color:#000">record</span>)

<span style="color:#a90d91">def</span> <span style="color:#000">batch</span>(<span style="color:#000">page_size</span>, <span style="color:#000">a</span>, <span style="color:#000">b</span>):
    <span style="color:#c41a16">&#34;&#34;&#34;Processes records in batches, with pagination&#34;&#34;&#34;</span>
    <span style="color:#000">rdr</span> <span style="color:#000">=</span> <span style="color:#000">reader</span>(<span style="color:#000">a</span>, <span style="color:#000">b</span>)
    <span style="color:#a90d91">for</span> <span style="color:#000">page</span> <span style="color:#000">in</span> <span style="color:#000">paginate</span>(<span style="color:#000">rdr</span>, <span style="color:#000">page_size</span>):
        <span style="color:#000">process_batch</span>(<span style="color:#000">page</span>)

<span style="color:#000">times</span> <span style="color:#000">=</span> <span style="color:#1c01ce">10</span>

<span style="color:#000">page_size</span> <span style="color:#000">=</span> <span style="color:#1c01ce">10_000</span>
<span style="color:#000">a</span> <span style="color:#000">=</span> <span style="color:#1c01ce">1_000_000</span>
<span style="color:#000">b</span> <span style="color:#000">=</span> <span style="color:#1c01ce">2_000_000</span>

<span style="color:#000">fn</span> <span style="color:#000">=</span> <span style="color:#a90d91">lambda</span>: <span style="color:#000">one_by_one</span>(<span style="color:#000">a</span>, <span style="color:#000">b</span>)
<span style="color:#000">total</span> <span style="color:#000">=</span> <span style="color:#000">timeit</span><span style="color:#000">.</span><span style="color:#000">timeit</span>(<span style="color:#000">fn</span>, <span style="color:#000">number</span><span style="color:#000">=</span><span style="color:#000">times</span>)
<span style="color:#000">it_time</span> <span style="color:#000">=</span> <span style="color:#a90d91">round</span>(<span style="color:#000">total</span> <span style="color:#000">*</span> <span style="color:#1c01ce">1000</span> <span style="color:#000">/</span> <span style="color:#000">times</span>)
<span style="color:#a90d91">print</span>(<span style="color:#c41a16">f</span><span style="color:#c41a16">&#34;One-by-one (baseline): </span><span style="color:#c41a16">{</span><span style="color:#000">it_time</span><span style="color:#c41a16">}</span><span style="color:#c41a16"> ms&#34;</span>)

<span style="color:#000">fn</span> <span style="color:#000">=</span> <span style="color:#a90d91">lambda</span>: <span style="color:#000">batch</span>(<span style="color:#000">page_size</span>, <span style="color:#000">a</span>, <span style="color:#000">b</span>)
<span style="color:#000">total</span> <span style="color:#000">=</span> <span style="color:#000">timeit</span><span style="color:#000">.</span><span style="color:#000">timeit</span>(<span style="color:#000">fn</span>, <span style="color:#000">number</span><span style="color:#000">=</span><span style="color:#000">times</span>)
<span style="color:#000">it_time</span> <span style="color:#000">=</span> <span style="color:#a90d91">round</span>(<span style="color:#000">total</span> <span style="color:#000">*</span> <span style="color:#1c01ce">1000</span> <span style="color:#000">/</span> <span style="color:#000">times</span>)
<span style="color:#a90d91">print</span>(<span style="color:#c41a16">f</span><span style="color:#c41a16">&#34;Fill page with append(): </span><span style="color:#c41a16">{</span><span style="color:#000">it_time</span><span style="color:#c41a16">}</span><span style="color:#c41a16"> ms&#34;</span>)
</code></pre></div><p>Вот результат на 1 млн записей и странице размером в 10 тысяч:</p>
<pre tabindex="0"><code>One-by-one (baseline):   161 ms
Fill page with append(): 227 ms
</code></pre><p>Постраничный обход медленнее почти в полтора раза!</p>
<p>Дело в том, что на каждой итерации цикла мы создаем новый пустой список и затем постепенно заполняем его. Питону приходится постоянно увеличивать размер массива под списком, а это затратная операция — O(n) от количества элементов в списке.</p>
<h2 id="фиксированная-страница">Фиксированная страница</h2>
<p>Попробуем заранее создать список нужной длины и использовать его для всех страниц.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#a90d91">def</span> <span style="color:#000">paginate</span>(<span style="color:#000">iterable</span>, <span style="color:#000">page_size</span>):
    <span style="color:#000">page</span> <span style="color:#000">=</span> [<span style="color:#a90d91">None</span>] <span style="color:#000">*</span> <span style="color:#000">page_size</span>
    <span style="color:#000">idx</span> <span style="color:#000">=</span> <span style="color:#1c01ce">0</span>
    <span style="color:#a90d91">for</span> <span style="color:#000">item</span> <span style="color:#000">in</span> <span style="color:#000">iterable</span>:
        <span style="color:#000">page</span>[<span style="color:#000">idx</span>] <span style="color:#000">=</span> <span style="color:#000">item</span>
        <span style="color:#000">idx</span> <span style="color:#000">+=</span> <span style="color:#1c01ce">1</span>
        <span style="color:#a90d91">if</span> <span style="color:#000">idx</span> <span style="color:#000">==</span> <span style="color:#000">page_size</span>:
            <span style="color:#a90d91">yield</span> <span style="color:#000">page</span>
            <span style="color:#000">idx</span> <span style="color:#000">=</span> <span style="color:#1c01ce">0</span>
    <span style="color:#a90d91">yield</span> <span style="color:#000">page</span>[:<span style="color:#000">idx</span>]
</code></pre></div><p>Повторим сравнение:</p>
<pre tabindex="0"><code>One-by-one (baseline):   161 ms
Fill page with append(): 227 ms
Use fixed-size page:     162 ms
</code></pre><p>Заметно быстрее! Скорость сравнялась с обычным итерированим по одной записи.</p>
<h2 id="итерация-срезами">Итерация срезами</h2>
<p>Можно ли ещё быстрее? Алгоритмически — нет. А вот практически — да, если перенести как можно больше действий из кода на питоне в библиотечный код на си. В этом поможет модуль <code>itertools()</code> и его функция <code>islice()</code>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#a90d91">def</span> <span style="color:#000">paginate</span>(<span style="color:#000">iterable</span>, <span style="color:#000">page_size</span>):
    <span style="color:#000">it</span> <span style="color:#000">=</span> <span style="color:#a90d91">iter</span>(<span style="color:#000">iterable</span>)
    <span style="color:#000">slicer</span> <span style="color:#000">=</span> <span style="color:#a90d91">lambda</span>: <span style="color:#a90d91">list</span>(<span style="color:#000">itertools</span><span style="color:#000">.</span><span style="color:#000">islice</span>(<span style="color:#000">it</span>, <span style="color:#000">page_size</span>))
    <span style="color:#a90d91">return</span> <span style="color:#a90d91">iter</span>(<span style="color:#000">slicer</span>, [])
</code></pre></div><p>Вот что здесь происходит:</p>
<ul>
<li><code>islice()</code> создаёт итератор (назовем его слайсером), который обходит переданную ему последовательность, пока не выберет из нее <code>page_size</code> элементов;</li>
<li><code>list()</code> выбирает все элементы из этого маленького итератора — получается страница;</li>
<li>поскольку <code>islice()</code> работает поверх основного итератора, при следующем вызове он продолжит с того же места, где остановился до этого;</li>
<li>конструкция <code>iter(slicer, [])</code> создает итератор, который на каждом шаге вызывает слайсер;</li>
<li>таким образом, функция <code>paginate()</code> возвращает итератор, который на каждом шаге выбирает очередную страницу через слайсер, провигаясь по основной последовательности — пока она не закончится.</li>
</ul>
<p>Посмотрите, до чего хорош такой вариант:</p>
<pre tabindex="0"><code>One-by-one (baseline):   161 ms
Fill page with append(): 227 ms
Use fixed-size page:     162 ms
Use islice:               93 ms
</code></pre><p>На 40% быстрее обычного итератора по одной записи!</p>
<h2 id="итого">Итого</h2>
<p>Постраничный обход отлично работает везде, где пакетная операция выполняется сильно быстрее набора одиночных. Чтобы не писать такой обход каждый раз с нуля, удобно использовать универсальный <em>постраничный итератор</em>.</p>
<p>Постраничный итератор, который динамически заполняет список, работает медленно — из-за постоянного изменения размера массива. Лучше использовать список фиксированного размера, а еще лучше — итерацию на основе <code>itertools.islice()</code></p>
<p>Рекомендую!</p>
<p><a href="https://replit.com/@antonz/page-iterator#main.py">песочница</a></p>
]]></content:encoded></item><item><title>Многострочные запросы в консоли SQLite</title><link>https://antonz.ru/sqlite-multiline/</link><pubDate>Sun, 24 Apr 2022 21:30:00 +0000</pubDate><guid>https://antonz.ru/sqlite-multiline/</guid><description>Как отредактировать большой запрос за один раз</description><content:encoded><![CDATA[<p>Стоило написать, что отлаживать многострочные запросы <a href="/sqlite-history/">в консоли SQLite</a> неудобно, как вычитал на sqlite-форуме классный трюк:</p>
<p>Достаточно вместо <code>Enter</code> использовать для перехода на новую строку сочетание <code>Ctrl+V</code>, <code>Ctrl+J</code> — и многострочный запрос редактируется одним куском!</p>
<div class="row">
<div class="col-xs-12 col-sm-7">
<figure>
  <img alt="Консоль SQLite" src="multiline.png" class="img-bordered-thin">
</figure>
</div>
</div>
<p>Еще несколько способов, которые используют люди:</p>
<ul>
<li>Внешний редактор (<code>.shell &lt;editor&gt; &lt;file&gt;</code>)</li>
<li>Запуск из файла (<code>.read &lt;file&gt;</code>)</li>
<li>DBeaver, DataGrip или аналоги</li>
</ul>
]]></content:encoded></item><item><title>Закешировать результат вычислений в Python</title><link>https://antonz.ru/functools-cache/</link><pubDate>Wed, 20 Apr 2022 21:40:00 +0000</pubDate><guid>https://antonz.ru/functools-cache/</guid><description>С помощью декоратора @functools.lru_cache</description><content:encoded><![CDATA[<p>Предположим, написали вы функцию, которая возвращает емейл пользователя:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#a90d91">def</span> <span style="color:#000">get_user_email</span>(<span style="color:#000">user_id</span>):
    <span style="color:#000">user</span> <span style="color:#000">=</span> <span style="color:#000">find_by_id</span>(<span style="color:#000">user_id</span>)
    <span style="color:#a90d91">return</span> <span style="color:#000">user</span>[<span style="color:#c41a16">&#34;email&#34;</span>]
</code></pre></div><p>Одна беда: функция <code>find_by_id()</code> лезет в уж-ж-жасно медленную легаси-систему:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#a90d91">def</span> <span style="color:#000">find_by_id</span>(<span style="color:#000">user_id</span>):
    <span style="color:#177500"># представьте здесь медленный запрос по сети,</span>
    <span style="color:#177500"># который возвращает пользователя</span>
    <span style="color:#000">time</span><span style="color:#000">.</span><span style="color:#000">sleep</span>(<span style="color:#1c01ce">1</span>)
    <span style="color:#a90d91">return</span> { <span style="color:#c41a16">&#34;email&#34;</span>: <span style="color:#c41a16">&#34;...&#34;</span> }
</code></pre></div><p>Если 100 раз вызвать <code>get_user_email(42)</code> — будет 100 медленных запросов. Хотя по уму хватило бы и одного. Что ж, давайте приделаем простенький кеш:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#000">cache</span> <span style="color:#000">=</span> {}

<span style="color:#a90d91">def</span> <span style="color:#000">get_user_email</span>(<span style="color:#000">user_id</span>):
    <span style="color:#a90d91">if</span> <span style="color:#000">user_id</span> <span style="color:#000">not</span> <span style="color:#000">in</span> <span style="color:#000">cache</span>:
        <span style="color:#000">user</span> <span style="color:#000">=</span> <span style="color:#000">find_by_id</span>(<span style="color:#000">user_id</span>)
        <span style="color:#000">cache</span>[<span style="color:#000">user_id</span>] <span style="color:#000">=</span> <span style="color:#000">user</span>[<span style="color:#c41a16">&#34;email&#34;</span>]
    <span style="color:#a90d91">return</span> <span style="color:#000">cache</span>[<span style="color:#000">user_id</span>]
</code></pre></div><p>Вроде ничего сложного (не считая вопроса устаревания кеша, но об этом в другой раз). Но представьте, что медленных функций много, и в каждую придется приделывать такую штуку. Не слишком вдохновляет.</p>
<p>К счастью, в модуле <code>functools</code> есть декоратор <code>@lru_cache</code>. Он-то нам и пригодится. Добавляем одну строчку к исходной функции, и готово:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#000">@functools</span><span style="color:#000">.</span><span style="color:#000">lru_cache</span>(<span style="color:#000">maxsize</span><span style="color:#000">=</span><span style="color:#1c01ce">256</span>)
<span style="color:#a90d91">def</span> <span style="color:#000">get_user_email</span>(<span style="color:#000">user_id</span>):
    <span style="color:#000">user</span> <span style="color:#000">=</span> <span style="color:#000">find_by_id</span>(<span style="color:#000">user_id</span>)
    <span style="color:#a90d91">return</span> <span style="color:#000">user</span>[<span style="color:#c41a16">&#34;email&#34;</span>]
</code></pre></div><p>Теперь повторные вызовы <code>get_user_email()</code> с одним и тем же <code>user_id</code> вернут результат из кеша, не запрашивая <code>find_by_id()</code>.</p>
<p><code>@lru_cache</code> прекрасен еще тем, что автоматически вытесняет старые записи из кеша, когда их становится больше <code>maxsize</code>. Так что всю память не съест.</p>
<p>В Python 3.9 добавили еще один декоратор — <code>@functools.cache</code>. Он такой же как <code>@lru_cache</code>, только безразмерный (благодаря чему работает чуть быстрее).</p>
<p>Кешем можно управлять — посмотреть статистику хитов и промахов или почистить.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#177500"># управляем кешем</span>

<span style="color:#000">stats</span> <span style="color:#000">=</span> <span style="color:#000">get_user_email</span><span style="color:#000">.</span><span style="color:#000">cache_info</span>()
<span style="color:#a90d91">print</span>(<span style="color:#000">stats</span>)
<span style="color:#177500"># CacheInfo(hits=2, misses=3, maxsize=256, currsize=3)</span>

<span style="color:#000">get_user_email</span><span style="color:#000">.</span><span style="color:#000">cache_clear</span>()
<span style="color:#177500"># CacheInfo(hits=0, misses=0, maxsize=256, currsize=0)</span>
</code></pre></div><p>Работает кеш внутри процесса, и погибнет вместе с ним. Так что если нужно что-то более масштабируемое — посмотрите на Redis или аналоги.</p>
<p><a href="https://devdocs.io/python/library/functools#functools.lru_cache">документация</a> •
<a href="https://replit.com/@antonz/functools-cache#main.py">песочница</a></p>
]]></content:encoded></item><item><title>История команд SQLite</title><link>https://antonz.ru/sqlite-history/</link><pubDate>Sun, 17 Apr 2022 14:50:00 +0000</pubDate><guid>https://antonz.ru/sqlite-history/</guid><description>Помогает найти запрос, чтобы не вводить заново.</description><content:encoded><![CDATA[<p>Если вы используете консоль SQLite (<code>sqlite3</code> или <code>sqlite3.exe</code>), то она помнит последние 2000 выполненных команд. Чтобы повторить последнюю команду, достаточно нажать клавишу <code>↑</code>, а поиск работает по сочетанию <code>Ctrl+R</code>.</p>
<div class="row">
<div class="col-xs-12 col-sm-8">
<figure>
  <img alt="Поиск по истории" src="search.jpg">
  <figcaption>Быстрее найти старый запрос, чем вбивать заново</figcaption>
</figure>
</div>
</div>
<p>По умолчанию файл истории хранится в каталоге пользователя и называется <code>.sqlite_history</code>. Он текстовый, так что можно просматривать хоть в редакторе. Если хотите сохранить в другом месте — укажите полный путь в переменной окружения <code>SQLITE_HISTORY</code>.</p>
<div class="row">
<div class="col-xs-12 col-sm-8">
<figure>
  <img alt="Файл истории" src="history.jpg">
  <figcaption>Синхронизируйте файл истории через Яндекс-диск или Дропбокс, чтобы искать запросы на всех устройствах</figcaption>
</figure>
</div>
</div>
<p>История записывается в файл при штатном выходе из консоли, так что если «моргнет» электричество или еще что — команды, выполненные с последнего запуска sqlite3, потеряются.</p>
<p>Конечно, запись истории — не единственная фича консоли. Например, через нее удобно <a href="https://stepik.org/lesson/469658/step/1?unit=460482">импортировать и экспортировать данные</a> или работать с несколькими базами одновременно. А вот отлаживать <a href="/sqlite-multiline/">многострочные запросы</a> — не слишком удобно 🤷‍♀️</p>
]]></content:encoded></item></channel></rss>