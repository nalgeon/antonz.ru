<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Антон Жиянов</title><description>Разработка софта, продуктоводство и здравый смысл</description><link>https://antonz.ru/</link><image><url>https://antonz.ru/assets/favicon/favicon.png</url><title>Антон Жиянов</title><link>https://antonz.ru/</link></image><generator>Hugo -- gohugo.io</generator><language>ru-ru</language><lastBuildDate>Thu, 02 Dec 2021 13:30:00 +0000</lastBuildDate><atom:link href="https://antonz.ru/index.xml" rel="self" type="application/rss+xml"/><item><title>Быстрый поиск похожих слов на SQL</title><link>https://antonz.ru/similar-words/</link><pubDate>Thu, 02 Dec 2021 13:30:00 +0000</pubDate><guid>https://antonz.ru/similar-words/</guid><description>Фонетика, расстояния и никакого LIKE.</description><content:encoded><![CDATA[<p><em>В этой статье разберемся, как быстро найти похожее слово в огромном словаре. Сначала рассмотрим наивное решение, потом сконструируем быстрое, а в конце посмотрим на готовое.</em></p>
<p>Предположим, мы хотим исправлять опечатки в поисковых запросах или сообщениях чата. Человек вводит «а<span class="color-red">б</span>р<span class="color-red">и</span>виатура», мы исправляем на «аббревиатура», «ра<span class="color-red">сс</span>чет» → «расчет», «доро<span class="color-red">аг</span>» → «дорога». Посмотрим, как решить такую задачу на SQL.</p>
<p>Я буду использовать SQLite. Но аналогичный подход сработает с любой СУБД или языком программирования (если интересно — дайте знать, сделаю примеры на Python).</p>
<h2 id="dictinary">1. Собираем словарь</h2>
<p>Воспользуемся списком русских слов во всех морфологических формах из репозитория <a href="https://github.com/danakt/russian-words">russian-words</a>. Скачаем и сконвертируем в UTF-8:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ wget https://github.com/danakt/russian-words/raw/master/russian.txt
$ iconv -f cp1251 russian.txt &gt; russian.utf.csv
</code></pre></div><p>Загрузим в таблицу <code>words</code>:</p>
<pre tabindex="0"><code>$ sqlite3 dictionary.db
sqlite&gt; create table words(word text);
sqlite&gt; .mode csv
sqlite&gt; .import russian.utf.csv words
sqlite&gt; create unique index words_idx on words(word);
sqlite&gt; select count(*) from words;
1532629
</code></pre><p>Словарь из 1.5 млн слов готов.</p>
<p>Когда человек ввел какое-то слово («абривиатура») — несложно проверить, есть ли оно в словаре:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#a90d91">select</span> <span style="color:#1c01ce">1</span> <span style="color:#a90d91">from</span> <span style="color:#000">words</span> <span style="color:#a90d91">where</span> <span style="color:#000">word</span> <span style="color:#000">=</span> <span style="color:#c41a16">&#39;абривиатура&#39;</span>;
<span style="color:#177500">-- &lt;пусто&gt;
</span></code></pre></div><p>Раз варианта в словаре нет — в слове наверняка опечатка. Чтобы предложить исправление, придется найти максимальное похожее слово в <code>words</code>.</p>
<h2 id="distance">2. Определяем похожесть слов</h2>
<p>Человеку интуитивно понятно, что такое «похожее» или «непохожее» слово, но машине нужен формальный критерий.</p>
<p>Идеально, если бы мы умели измерять <em>расстояние</em> между словами. Функция расстояния принимает на входе два слова и возвращает некоторое число <code>D</code>, которое характеризует похожесть:</p>
<pre tabindex="0"><code>distance(w1, w1) = x
</code></pre><p>Чем меньше <code>D</code>, тем более похожи слова.</p>
<p>Приятно, что специалисты по компьютерным наукам уже придумали великое множество таких функций. Наиболее известная из них — <em>расстояние Левенштейна</em>. Она измеряет, сколько букв надо удалить, добавить или заменить, чтобы перейти от слова <code>w1</code> к слову <code>w2</code>:</p>
<div class="row">
<div class="col-xs-12 col-sm-6">
<figure>
  <img class="img-bordered-thin" alt="Расстояние Левенштейна" src="distance.jpg">
</figure>
</div>
<div class="col-xs-12 col-sm-6">
<p class="figcaption">Расстояние Левенштейна считает количество элементарных замен, которыми можно превратить одно слово в другое.</p>
</div>
</div>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#177500"># одна операция: удалить лишнюю С</span>
<span style="color:#000">levenshtein</span>(<span style="color:#c41a16">&#34;рассчет&#34;</span>, <span style="color:#c41a16">&#34;расчет&#34;</span>) <span style="color:#000">=</span> <span style="color:#1c01ce">1</span>

<span style="color:#177500"># одна операция: добавить недостающую лишнюю Л</span>
<span style="color:#000">levenshtein</span>(<span style="color:#c41a16">&#34;сонце&#34;</span>, <span style="color:#c41a16">&#34;солнце&#34;</span>) <span style="color:#000">=</span> <span style="color:#1c01ce">1</span>

<span style="color:#177500"># две операции: заменить А→Г, заменить Г→А</span>
<span style="color:#000">levenshtein</span>(<span style="color:#c41a16">&#34;дороаг&#34;</span>, <span style="color:#c41a16">&#34;дорога&#34;</span>) <span style="color:#000">=</span> <span style="color:#1c01ce">2</span>
</code></pre></div><p>Пример с «дороаг» → «дорога» может показаться странным: очевидно же, что достаточно переставить буквы местами. Перестановка — одна операция, и расстояние должно быть 1, а не 2. Алгоритм Левенштейна не учитывает такие случаи, поэтому создали улучшенную и дополненную версию — <em>расстояние Дамерау-Левенштейна</em>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#000">dlevenshtein</span>(<span style="color:#c41a16">&#34;дороаг&#34;</span>, <span style="color:#c41a16">&#34;дорога&#34;</span>) <span style="color:#000">=</span> <span style="color:#1c01ce">1</span>
</code></pre></div><p>Его и будем использовать.</p>
<div class="boxed">
<h3>Считаем расстояние в SQLite</h3>
<p>В стандартную поставку SQLite расстояния не входят. Поэтому будем использовать расширение <a href="https://github.com/nalgeon/sqlean/blob/main/docs/fuzzy.md">fuzzy</a>, в котором есть все необходимое:</p>
<pre><code>-- в консоли sqlite
.load ./fuzzy<br>
-- или через select
select load_extension('./fuzzy');
</code></pre>
<p>Расширение умеет работать только с ASCII-строками (латиницей), так что русские слова придется предварительно транслитерировать (перевести в латиницу) функцией <code>translit</code>:</p>
<pre><code>select translit('дорога');
-- doroga<br>
select translit('дороаг');
-- doroag<br>
select dlevenshtein(
  translit('дорога'),
  translit('дороаг')
);
-- 1</code></pre>
</div>
<h2 id="search-distance">3. Ищем похожее слово в словаре</h2>
<p>Чтобы исправить опечатку в слове, достаточно посчитать расстояние от него до каждого слова в словаре и выбрать слово с минимальным расстоянием.</p>
<div class="row">
<div class="col-xs-12 col-sm-6">
<figure>
  <img class="img-bordered-thin" alt="Поиск по расстоянию" src="search-distance.jpg">
</figure>
</div>
<div class="col-xs-12 col-sm-6">
<p class="figcaption">Считаем расстояния между словом с опечаткой и остальными словами → получаем набор расстояний. Выбираем минимальное → получаем слово с исправленной опечаткой.</p>
<p class="figcaption">Отличный был бы алгоритм, если бы не сортировал каждый раз полтора миллиона слов.</p>
</div>
</div>
<p>На SQL:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#a90d91">select</span>
  <span style="color:#000">word</span>,
  <span style="color:#000">dlevenshtein</span>(
    <span style="color:#000">translit</span>(<span style="color:#c41a16">&#39;абривиатура&#39;</span>),
    <span style="color:#000">translit</span>(<span style="color:#000">word</span>)
  ) <span style="color:#a90d91">as</span> <span style="color:#000">distance</span>
<span style="color:#a90d91">from</span> <span style="color:#000">words</span>
<span style="color:#a90d91">order</span> <span style="color:#a90d91">by</span> <span style="color:#000">distance</span>
<span style="color:#a90d91">limit</span> <span style="color:#1c01ce">1</span>;
</code></pre></div><pre tabindex="0"><code>┌──────────────┬──────────┐
│     word     │ distance │
├──────────────┼──────────┤
│ аббревиатура │ 2        │
└──────────────┴──────────┘
Run Time: real 8.145 user 8.055009 sys 0.051747
</code></pre><p>Отлично работает! Одна проблема: расчет занимает 8 секунд. Для исправления опечаток в онлайне не подходит. Нам желательно уложиться в 50–200 мс, чтобы для человека выглядело мгновенным. Исправим это.</p>
<h2 id="phonetics">4. Фонетическое кодирование</h2>
<p>Проблема с расстоянием в том, что его нельзя посчитать заранее — мы же не знаем, какое слово введет человек. Здесь поможет <em>фонетическое кодирование</em>:</p>
<div class="row">
<div class="col-xs-12 col-sm-6">
<figure>
  <img class="img-bordered-thin" alt="Фонетический алгоритм" src="phonetics.jpg">
</figure>
</div>
<div class="col-xs-12 col-sm-6">
<p class="figcaption">Фонетический алгоритм превращает произвольное слово (<code>солнце</code>) в <em>фонетический код</em> (<code>SNTK</code>). При этом созвучные слова получают одинаковые коды, а несозвучные — разные.</p>
</div>
</div>
<p>Теперь мы можем обойтись без расстояния вообще:</p>
<ol>
<li>Заранее посчитать код для каждого слова в словаре.</li>
<li>Посчитать код для слова с опечаткой, которое ввел человек.</li>
<li>Найти слово в словаре по этому коду — это и будет правильный вариант.</li>
</ol>
<div class="row">
<div class="col-xs-12 col-sm-6">
<figure>
  <img class="img-bordered-thin" alt="Поиск по фонетике" src="search-phonetics.jpg">
</figure>
</div>
<div class="col-xs-12 col-sm-6">
<p class="figcaption">Работать должно моментально, потому что по столбцу с кодами можно построить индекс, и искать по нему.</p>
</div>
</div>
<p>Попробуем использовать фонетическое кодирование для исправления опечаток.</p>
<h2 id="search-phonetics">5. Ищем по фонетике</h2>
<p>Фонетические алгоритмы придумывали для английского языка, и на русском они не работают. Нам придется прибегнуть к трюку с транслитерацией.</p>
<p>У транслитерированных слов фонетика сильно отличается от «родной» английской, поэтому многие фонетические алгоритмы плохо работает с транслитом. Мы возьмем функцию <code>caverphone</code> — она на удивление недурна, несмотря на австралийское происхождение:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#000">caverphone</span>(<span style="color:#000">translit</span>(<span style="color:#c41a16">&#34;рассчет&#34;</span>)) <span style="color:#000">=</span> <span style="color:#c41a16">&#34;RSKT111111&#34;</span>
<span style="color:#000">caverphone</span>(<span style="color:#000">translit</span>(<span style="color:#c41a16">&#34;расчет&#34;</span>))  <span style="color:#000">=</span> <span style="color:#c41a16">&#34;RSKT111111&#34;</span>

<span style="color:#000">caverphone</span>(<span style="color:#000">translit</span>(<span style="color:#c41a16">&#34;сонце&#34;</span>))  <span style="color:#000">=</span> <span style="color:#c41a16">&#34;SNTK111111&#34;</span>
<span style="color:#000">caverphone</span>(<span style="color:#000">translit</span>(<span style="color:#c41a16">&#34;солнце&#34;</span>)) <span style="color:#000">=</span> <span style="color:#c41a16">&#34;SNTK111111&#34;</span>

<span style="color:#000">caverphone</span>(<span style="color:#000">translit</span>(<span style="color:#c41a16">&#34;абривиатура&#34;</span>))  <span style="color:#000">=</span> <span style="color:#c41a16">&#34;APRFTRA111&#34;</span>
<span style="color:#000">caverphone</span>(<span style="color:#000">translit</span>(<span style="color:#c41a16">&#34;аббревиатура&#34;</span>)) <span style="color:#000">=</span> <span style="color:#c41a16">&#34;APRFTRA111&#34;</span>
</code></pre></div><p>Рассчитаем коды для слов из словаря и построим индекс:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#a90d91">alter</span> <span style="color:#a90d91">table</span> <span style="color:#000">words</span> <span style="color:#a90d91">add</span> <span style="color:#a90d91">column</span> <span style="color:#000">hash</span> <span style="color:#a90d91">text</span>;
<span style="color:#a90d91">update</span> <span style="color:#000">words</span> <span style="color:#a90d91">set</span> <span style="color:#000">hash</span> <span style="color:#000">=</span> <span style="color:#000">caverphone</span>(<span style="color:#000">translit</span>(<span style="color:#000">word</span>));
<span style="color:#a90d91">create</span> <span style="color:#a90d91">index</span> <span style="color:#000">words_hash_idx</span> <span style="color:#a90d91">on</span> <span style="color:#000">words</span>(<span style="color:#000">hash</span>);
</code></pre></div><p>Исправим опечатку в слове <code>абривиатура</code>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#a90d91">select</span> <span style="color:#000">word</span>
<span style="color:#a90d91">from</span> <span style="color:#000">words</span>
<span style="color:#a90d91">where</span> <span style="color:#000">hash</span> <span style="color:#000">=</span> <span style="color:#000">caverphone</span>(<span style="color:#000">translit</span>(<span style="color:#c41a16">&#39;абривиатура&#39;</span>))
<span style="color:#a90d91">limit</span> <span style="color:#1c01ce">3</span>;
</code></pre></div><pre tabindex="0"><code>┌───────────────┐
│     word      │
├───────────────┤
│ аббревиатура  │
│ аббревиатурой │
│ аббревиатурою │
└───────────────┘
Run Time: real 0.002 user 0.000130 sys 0.000391
</code></pre><p>Замечательно! Запрос выполнился мгновенно и вернул подходящие слова из словаря.</p>
<h2 id="search-combined">6. Ищем по фонетике и расстоянию</h2>
<p>Как удачно все получилось с «аббревиатурой». Проверим на «расчете»:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#a90d91">select</span> <span style="color:#000">word</span>
<span style="color:#a90d91">from</span> <span style="color:#000">words</span>
<span style="color:#a90d91">where</span> <span style="color:#000">hash</span> <span style="color:#000">=</span> <span style="color:#000">caverphone</span>(<span style="color:#000">translit</span>(<span style="color:#c41a16">&#39;рассчет&#39;</span>))
<span style="color:#a90d91">limit</span> <span style="color:#1c01ce">3</span>;
</code></pre></div><pre tabindex="0"><code>┌────────────┐
│    word    │
├────────────┤
│ разжигает  │
│ разжигаете │
│ разжигайте │
└────────────┘
</code></pre><p>Эээ. Совсем не то, чего мы ожидали. Проблема в том, что у «расчета» фонетически похожих слов довольно много:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#a90d91">select</span> <span style="color:#a90d91">count</span>(<span style="color:#000">*</span>)
<span style="color:#a90d91">from</span> <span style="color:#000">words</span>
<span style="color:#a90d91">where</span> <span style="color:#000">hash</span> <span style="color:#000">=</span> <span style="color:#000">caverphone</span>(<span style="color:#000">translit</span>(<span style="color:#c41a16">&#39;рассчет&#39;</span>));
<span style="color:#177500">-- 50
</span></code></pre></div><p>Нам бы как-то найти среди этих пятидесяти самое похожее. Хорошо, что мы уже знаем как это сделать — с помощью расстояния Дамерау-Левенштейна! Будем выбирать слова-кандидаты по фонетическому коду, а наиболее подходящего из кандидатов — по расстоянию:</p>
<figure>
  <img class="img-bordered-thin" alt="Комбинированный поиск" src="search-combined.png">
  <figcaption>Транслитерируем слово, считаем фонетический код, затем ищем по нему кандидатов и выбираем ближайшего по расстоянияю.</figcaption>
</figure>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#177500">-- кандидаты по фонетическому коду
</span><span style="color:#177500"></span><span style="color:#a90d91">with</span> <span style="color:#000">candidates</span> <span style="color:#a90d91">as</span> (
  <span style="color:#a90d91">select</span> <span style="color:#000">word</span>
  <span style="color:#a90d91">from</span> <span style="color:#000">words</span>
  <span style="color:#a90d91">where</span> <span style="color:#000">hash</span> <span style="color:#000">=</span> <span style="color:#000">caverphone</span>(<span style="color:#000">translit</span>(<span style="color:#c41a16">&#39;рассчет&#39;</span>))
)

<span style="color:#177500">-- выбираем кандидата с минимальным расстоянием
</span><span style="color:#177500"></span><span style="color:#a90d91">select</span>
  <span style="color:#000">word</span>,
  <span style="color:#000">dlevenshtein</span>(
    <span style="color:#000">translit</span>(<span style="color:#c41a16">&#39;рассчет&#39;</span>),
    <span style="color:#000">translit</span>(<span style="color:#000">word</span>)
  ) <span style="color:#a90d91">as</span> <span style="color:#000">distance</span>
<span style="color:#a90d91">from</span> <span style="color:#000">candidates</span>
<span style="color:#a90d91">order</span> <span style="color:#a90d91">by</span>
  <span style="color:#000">distance</span>,
  <span style="color:#a90d91">abs</span>(<span style="color:#a90d91">length</span>(<span style="color:#000">word</span>) <span style="color:#000">-</span> <span style="color:#a90d91">length</span>(<span style="color:#c41a16">&#39;рассчет&#39;</span>)),
  <span style="color:#a90d91">length</span>(<span style="color:#000">word</span>)
<span style="color:#a90d91">limit</span> <span style="color:#1c01ce">3</span>;
</code></pre></div><pre tabindex="0"><code>┌──────────┬──────────┐
│   word   │ distance │
├──────────┼──────────┤
│ расчет   │ 1        │
│ расчёт   │ 1        │
│ рассечет │ 1        │
└──────────┴──────────┘
Run Time: real 0.014 user 0.000729 sys 0.003712
</code></pre><p>То что надо! Поиск остался моментальным (благодаря выборке кандидатов по индексу), но стал точным (благодаря честному сравнению расстояния между кандидатами).</p>
<h2 id="other-typos">7. Учитываем нефонетические опечатки</h2>
<p>Все здорово в нашем походе. Кроме одного: не все опечатки фонетические. Если перепутать порядок букв в слове <code>дорога</code>, звучать слова будут совершенно по-разному:</p>
<pre tabindex="0"><code>дорога
дороаг
</code></pre><p>Фонетический алгоритм посчитает такие слова разными (и будет прав):</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#000">caverphone</span>(<span style="color:#c41a16">&#34;doroga&#34;</span>) <span style="color:#000">=</span> <span style="color:#c41a16">&#34;TRKA111111&#34;</span>
<span style="color:#000">caverphone</span>(<span style="color:#c41a16">&#34;doroag&#34;</span>) <span style="color:#000">=</span> <span style="color:#c41a16">&#34;TRK1111111&#34;</span>
</code></pre></div><p>В результате на нефонетических опечатках наш алгоритм будет работать плохо. Для <code>дороаг</code> вернет:</p>
<pre tabindex="0"><code>┌────────┬──────────┐
│  word  │ distance │
├────────┼──────────┤
│ дорог  │ 1        │
│ дороге │ 2        │
│ драг   │ 2        │
└────────┴──────────┘
</code></pre><p>Часть нефонетических опечаток можно исправить. Например, выбирать не по строгому равенству фонетических кодов, а по префиксу (первые 3 символа в данном случае):</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#177500">-- диапазон допустимых фонетических кодов
</span><span style="color:#177500"></span><span style="color:#a90d91">with</span> <span style="color:#000">bounds</span> <span style="color:#a90d91">as</span> (
  <span style="color:#a90d91">select</span>
    <span style="color:#000">substr</span>(<span style="color:#000">caverphone</span>(<span style="color:#000">translit</span>(<span style="color:#c41a16">&#39;дороаг&#39;</span>)), <span style="color:#1c01ce">1</span>, <span style="color:#1c01ce">3</span>) <span style="color:#000">||</span> <span style="color:#c41a16">&#39;1&#39;</span> <span style="color:#a90d91">as</span> <span style="color:#a90d91">left</span>,
    <span style="color:#000">substr</span>(<span style="color:#000">caverphone</span>(<span style="color:#000">translit</span>(<span style="color:#c41a16">&#39;дороаг&#39;</span>)), <span style="color:#1c01ce">1</span>, <span style="color:#1c01ce">3</span>) <span style="color:#000">||</span> <span style="color:#c41a16">&#39;Z&#39;</span> <span style="color:#a90d91">as</span> <span style="color:#a90d91">right</span>
),

<span style="color:#177500">-- кандидаты по фонетическому коду
</span><span style="color:#177500">-- из числа допустимых
</span><span style="color:#177500"></span><span style="color:#000">candidates</span> <span style="color:#a90d91">as</span> (
  <span style="color:#a90d91">select</span> <span style="color:#000">word</span>
  <span style="color:#a90d91">from</span> <span style="color:#000">words</span>, <span style="color:#000">bounds</span>
  <span style="color:#a90d91">where</span> <span style="color:#000">hash</span> <span style="color:#a90d91">between</span> <span style="color:#000">bounds</span>.<span style="color:#a90d91">left</span> <span style="color:#a90d91">and</span> <span style="color:#000">bounds</span>.<span style="color:#a90d91">right</span>
)

<span style="color:#177500">-- выбираем кандидата с минимальным расстоянием
</span><span style="color:#177500"></span><span style="color:#a90d91">select</span>
  <span style="color:#000">word</span>,
  <span style="color:#000">dlevenshtein</span>(<span style="color:#000">translit</span>(<span style="color:#c41a16">&#39;дороаг&#39;</span>), <span style="color:#000">translit</span>(<span style="color:#000">word</span>)) <span style="color:#a90d91">as</span> <span style="color:#000">distance</span>
<span style="color:#a90d91">from</span> <span style="color:#000">candidates</span>
<span style="color:#a90d91">order</span> <span style="color:#a90d91">by</span> <span style="color:#000">distance</span>, <span style="color:#a90d91">abs</span>(<span style="color:#a90d91">length</span>(<span style="color:#000">word</span>) <span style="color:#000">-</span> <span style="color:#a90d91">length</span>(<span style="color:#c41a16">&#39;дороаг&#39;</span>)), <span style="color:#a90d91">length</span>(<span style="color:#000">word</span>)
<span style="color:#a90d91">limit</span> <span style="color:#1c01ce">3</span>;
</code></pre></div><pre tabindex="0"><code>┌────────┬──────────┐
│  word  │ distance │
├────────┼──────────┤
│ дорога │ 1        │
│ дорог  │ 1        │
│ дороге │ 2        │
└────────┴──────────┘
Run Time: real 0.032 user 0.030312 sys 0.000339
</code></pre><p>Такой запрос находит на порядки больше кандидатов (6633 вместо 81 для «дороги»). Из-за этого он намного медленнее работает (хотя 32 мс — все еще очень быстро с точки зрения человека).</p>
<p>Префиксный подход не сработает, если опечатка в самом начале слова. Запрос по <code>одрога</code> не найдет слово <code>дорога</code>:</p>
<pre tabindex="0"><code>┌────────┬──────────┐
│  word  │ distance │
├────────┼──────────┤
│ отрога │ 1        │
│ отроге │ 2        │
│ отроги │ 2        │
└────────┴──────────┘
</code></pre><p>Хоть мой айфон такую опечатку тоже не исправляет, так что может и ничего.</p>
<h2 id="spellfix">8. Готовое решение для SQLite</h2>
<p>Теперь вы знаете, как быстро искать похожие слова в стиле «сделай сам». Описанный алгоритм можно реализовать в любой СУБД, где есть фонетические функции и функции расстояний. Но даже если в вашей базе их нет — то же самое можно сделать на Python, JS или C#, для которых уж точно найдутся подходящие библиотеки.</p>
<p>Если же работаете в SQLite — можно сэкономить время и воспользоваться готовым расширением <a href="https://github.com/nalgeon/sqlean/issues/27#issuecomment-1002297477">spellfix</a>. Под капотом у него фонетика + расстояния, как мы обсуждали, но внешний интерфейс сильно проще:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql">.<span style="color:#a90d91">load</span> .<span style="color:#000">/</span><span style="color:#000">spellfix</span>

<span style="color:#a90d91">create</span> <span style="color:#000">virtual</span> <span style="color:#a90d91">table</span> <span style="color:#a90d91">dictionary</span> <span style="color:#a90d91">using</span> <span style="color:#000">spellfix1</span>;

<span style="color:#a90d91">insert</span> <span style="color:#a90d91">into</span> <span style="color:#a90d91">dictionary</span>(<span style="color:#000">word</span>)
<span style="color:#a90d91">select</span> <span style="color:#000">word</span> <span style="color:#a90d91">from</span> <span style="color:#000">words</span>;

<span style="color:#a90d91">select</span> <span style="color:#000">word</span> <span style="color:#a90d91">from</span> <span style="color:#a90d91">dictionary</span>
<span style="color:#a90d91">where</span> <span style="color:#000">word</span> <span style="color:#a90d91">match</span> <span style="color:#c41a16">&#39;абривиатура&#39;</span>
<span style="color:#a90d91">limit</span> <span style="color:#1c01ce">1</span>;
</code></pre></div><pre tabindex="0"><code>┌──────────────┐
│     word     │
├──────────────┤
│ аббревиатура │
└──────────────┘
Run Time: real 0.182 user 0.112689 sys 0.014142
</code></pre><p>Работает медленнее и местами хуже, чем наше DIY-решение, зато гибче настраивается. Можно добавлять синонимы слов и тюнить расстояние — см. разделы «Dealing With Unusual And Difficult Spellings» и «Configurable Edit Distance» <a href="https://sqlite.org/spellfix1.html">в документации</a>.</p>
<h2 id="9-итоги">9. Итоги</h2>
<p>Теперь вы умеете:</p>
<ul>
<li>Считать расстояние между словами, чтобы понять, насколько они отличаются.</li>
<li>Использовать фонетические алгоритмы, чтобы искать созвучные слова.</li>
<li>Сочетать фонетику и расстояние, чтобы моментально находить похожие слова в миллионном словаре.</li>
</ul>
<p>Конечно, есть и альтернативные подходы к исправлению опечаток. Например:</p>
<ul>
<li>Для каждого слова из словаря заранее сгенерить возможные варианты опечаток и сохранить их в отдельной таблице. Словарь увеличится в десятки, если не сотни раз — зато не нужны фонетика и расстояния.</li>
<li>Обучить нейросеть предсказывать правильное слово по тому, что ввел человек. Заодно получится предиктивно предлагать варианты еще до того, как пользователь дописал слово — так работает ввод в айоси и андроиде.</li>
</ul>
<p>Но это уже совсем другая история ツ А фонетика и расстояния могут вам пригодиться.</p>
<div class="row">
<div class="col-xs-12 col-sm-10 col-md-8"><p><em>И подписывайтесь на канал <span class="nowrap"><i class="fas fa-database"></i> «<a href="https://t.me/sqliter">SQLite на практике</a>»</span></em></p></div>
</div>
]]></content:encoded></item><item><title>Датасет слов английского языка</title><link>https://antonz.ru/words-dataset/</link><pubDate>Wed, 01 Dec 2021 14:50:00 +0000</pubDate><guid>https://antonz.ru/words-dataset/</guid><description>Oxford 5000 и другие наборы с произношением.</description><content:encoded><![CDATA[<p>Обнаружил, что у Оксфордского университета есть списки распространенных слов и выражений английского языка. Доступны в традиционно «удобном» формате — html-амбразуре на сайте либо PDF.</p>
<p>Извлек их и сделал нормальные наборы данных в CSV. Например:</p>
<table>
<thead>
<tr>
<th>word</th>
<th>level</th>
<th>pos</th>
<th>definition_url</th>
<th>voice_url</th>
</tr>
</thead>
<tbody>
<tr>
<td>abandon</td>
<td>b2</td>
<td>verb</td>
<td><a href="https://www.oxfordlearnersdictionaries.com/definition/english/abandon_1">📄</a></td>
<td><a href="https://www.oxfordlearnersdictionaries.com/media/english/us_pron_ogg/a/aba/aband/abandon__us_2.ogg">🗣️</a></td>
</tr>
<tr>
<td>ability</td>
<td>a2</td>
<td>noun</td>
<td><a href="https://www.oxfordlearnersdictionaries.com/definition/english/ability_1">📄</a></td>
<td><a href="https://www.oxfordlearnersdictionaries.com/media/english/us_pron_ogg/a/abi/abili/ability__us_4.ogg">🗣️</a></td>
</tr>
<tr>
<td>able</td>
<td>a2</td>
<td>adjective</td>
<td><a href="https://www.oxfordlearnersdictionaries.com/definition/english/able_1">📄</a></td>
<td><a href="https://www.oxfordlearnersdictionaries.com/media/english/us_pron_ogg/a/abl/able_/able__us_2.ogg">🗣️</a></td>
</tr>
<tr>
<td>abolish</td>
<td>c1</td>
<td>verb</td>
<td><a href="https://www.oxfordlearnersdictionaries.com/definition/english/abolish">📄</a></td>
<td><a href="https://www.oxfordlearnersdictionaries.com/media/english/us_pron_ogg/a/abo/aboli/abolish__us_1.ogg">🗣️</a></td>
</tr>
<tr>
<td>и еще 5000 слов&hellip;</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Атрибутика:</p>
<ul>
<li><code>word</code> — слово</li>
<li><code>pos</code> — часть речи</li>
<li><code>level</code> — уровень (A1, A2, B1, B2, C1)</li>
<li><code>definition_url</code> — ссылка на подробное определение</li>
<li><code>voice_url</code> — ссылка на озвучку в ogg</li>
</ul>
<!-- <p class="big">
<a href="https://github.com/nalgeon/words">github.com/nalgeon/words</a>
</p> -->
<p>Посмотреть и скачать:<br>
<a href="https://github.com/nalgeon/words"><strong>github.com/nalgeon/words</strong></a></p>
<div class="row">
<div class="col-xs-12 col-sm-10 col-md-8"><p><em>Заметка из телеграм-канала <span class="nowrap"><i class="fas fa-database"></i> «<a href="https://t.me/sqliter">SQLite на практике</a>»</span></em></p></div>
</div>
]]></content:encoded></item><item><title>Что нового в SQLite 3.37</title><link>https://antonz.ru/sqlite-3-37/</link><pubDate>Sun, 28 Nov 2021 15:25:00 +0000</pubDate><guid>https://antonz.ru/sqlite-3-37/</guid><description>Строгие таблицы, any-тип и новая прагма.</description><content:encoded><![CDATA[<p>В отличие от <a href="/sqlite-3-35">3.35</a>, релиз 3.37 принес не так много изменений. Но среди них — одно из важнейших за всю историю: «строгий» режим таблиц, в котором движок следит, чтобы данные в столбце соответствовали типу.</p>
<p>Возможно, теперь SQLite перестанут называть «джаваскриптом в мире СУБД» ツ Но давайте по порядку.</p>
<p><a href="https://habr.com/ru/news/t/592085/">подробности на Хабре</a></p>
]]></content:encoded></item><item><title>Скорость алгоритмов и котики</title><link>https://antonz.ru/big-o/</link><pubDate>Thu, 25 Nov 2021 16:30:00 +0000</pubDate><guid>https://antonz.ru/big-o/</guid><description>Разбираем быстрые и медленные алгоритмы на шерстяных жопках.</description><content:encoded><![CDATA[<p>Давайте посмотрим, как программисты оценивают быстрые и медленные алгоритмы. Поскольку тема максимально занудная, разбираться будем на дурацких примерах с котиками.</p>
<h2 id="константное-время-o1">Константное время, O(1)</h2>
<p>Самый лучший вариант, скорость алгоритма не зависит от количества котиков.</p>
<div class="row">
<div class="col-xs-12 col-sm-6 flex">
<div class="boxed">
    <p><strong>🐾 Пример</strong></p>
    <p>Вы — счастливый обладатель <code>N</code> котиков. Каждый котик знает, как его зовут. Если позвать «Клёпа!», то прибежит только он, а остальным <code>N-1</code> жопкам пофиг.</p>
</div>
</div>
<div class="col-xs-12 col-sm-6">
<figure>
  <img alt="Константное время" src="01-constant.jpg" class="img-bordered-thin">
</figure>
</div>
</div>
<h2 id="логарифмическое-время-ologn">Логарифмическое время, O(log n)</h2>
<p>На <code>N</code> котиках алгоритм отрабатывает за <code>log(N)</code> шагов. Это быстро! 1 000 000 котиков → всего 20 операций.</p>
<div class="row">
<div class="col-xs-12 col-sm-6 flex">
<div class="boxed">
    <p><strong>🐾 Пример</strong></p>
    <p>Мисочки у котиков расставлены по алфавиту. Когда у вас появляется новый котик, место для его мисочки находится за <code>log(N)</code> шагов.</p>
</div>
</div>
<div class="col-xs-12 col-sm-6">
<figure>
  <img alt="Логарифмическое время" src="02-log.jpg" class="img-bordered-thin">
</figure>
</div>
</div>
<h2 id="линейное-время-on">Линейное время, O(n)</h2>
<p>На <code>N</code> котиках алгоритм отрабатывает за <code>N</code> шагов. Это значит, каждый раз приходится перебирать всех кошачьих. Ну такое.</p>
<div class="row">
<div class="col-xs-12 col-sm-6 flex">
<div class="boxed">
    <p><strong>🐾 Пример</strong></p>
    <p>Котики взбунтовались и перестали отзываться на клички. Теперь приходится обходить <code>N</code> шубок, чтобы найти нужного.</p>
</div>
</div>
<div class="col-xs-12 col-sm-6">
<figure>
  <img alt="Линейное время" src="03-linear.jpg" class="img-bordered-thin">
</figure>
</div>
</div>
<h2 id="линейно-логарифмическое-время-onlogn">Линейно-логарифмическое время, O(n log n)</h2>
<p>На <code>N</code> котиках алгоритм отрабатывает за <code>N</code> × <code>log(N)</code> шагов. Это дольше, чем за линейное время, но ненамного (логарифм <code>N</code> сильно меньше <code>N</code>, помните?).</p>
<div class="row">
<div class="col-xs-12 col-sm-6 flex">
<div class="boxed">
    <p><strong>🐾 Пример</strong></p>
    <p>К приходу гостей вы решили рассадить котиков по размеру. Алгоритм quick sort справится с этим за <code>N</code> × <code>log(N)</code> шагов.</p>
</div>
</div>
<div class="col-xs-12 col-sm-6">
<figure>
  <img alt="Линейно-логарифмическое время" src="04-log-linear.jpg" class="img-bordered-thin">
</figure>
</div>
</div>
<p>На очереди у нас неторопливые полиномиальные котики и совсем улиточки — суперполиномиальные.</p>
<h2 id="квадратичное-время-on">Квадратичное время O(n²)</h2>
<p>На <code>N</code> котиках алгоритм отрабатывает за <code>N²</code> шагов. Ме-е-едленно.</p>
<div class="row">
<div class="col-xs-12 col-sm-6 flex">
<div class="boxed">
    <p><strong>🐾 Пример</strong></p>
    <p>Конкурент утверждает, что его <code>N</code> котиков более гладкие и довольные, чем ваши. Специальная комиссия попарно сравнит хвостатых и вынесет справедливый вердикт. Понадобится ~ <code>N²</code> сравнений.</p>
</div>
</div>
<div class="col-xs-12 col-sm-6">
<figure>
  <img alt="Квадратичное время" src="05-quadratic.jpg" class="img-bordered-thin">
</figure>
</div>
</div>
<h2 id="полиномиальное-время-onᵏ">Полиномиальное время, O(nᵏ)</h2>
<p>На <code>N</code> котиках алгоритм отрабатывает за <code>N³</code> шагов, <code>N⁴</code> шагов, <code>N⁵</code> шагов, или ещё дольше. Фу таким быть.</p>
<div class="row">
<div class="col-xs-12 col-sm-6 flex">
<div class="boxed">
    <p><strong>🐾 Пример</strong></p>
    <p>Фотосессия! Каждого из <code>N</code> котиков надо попарно отфоткать с другими, причем фотограф делает <code>N</code> снимков на каждую пару. <code>N</code> × <code>N</code> × <code>N</code> ≃ <code>N³</code> шагов.</p>
</div>
</div>
<div class="col-xs-12 col-sm-6">
<figure>
  <img alt="Полиномиальное время" src="06-polinomial.jpg" class="img-bordered-thin">
</figure>
</div>
</div>
<p>Хоть полиномиальные алгоритмы и не славятся быстротой, по сравнению с суперполиномиальными они стремительны как Флеш. Из «суперского» у суперполиномиальных только название, увы. Сейчас покажу.</p>
<h2 id="экспоненциальное-время-o2ⁿ">Экспоненциальное время, O(2ⁿ)</h2>
<p>На <code>N</code> котиках алгоритм отрабатывает за <code>2ⁿ</code> шагов. Это долго, вы вряд ли дождетесь.</p>
<div class="row">
<div class="col-xs-12 col-sm-6 flex">
<div class="boxed">
    <p><strong>🐾 Пример</strong></p>
    <p>Котики отправляются на выставку. Каждого взвесили и оценили в звездах. Но перевозка рассчитана максимум на X килограмм. Как выбрать самый звездный состав? Ответ потребует <code>2ⁿ</code> шагов.</p>
</div>
</div>
<div class="col-xs-12 col-sm-6">
<figure>
  <img alt="Экспоненциальное время" src="07-exponential.jpg" class="img-bordered-thin">
</figure>
</div>
</div>
<h2 id="факториальное-время-on">Факториальное время, O(n!)</h2>
<p>На <code>N</code> котиках алгоритм отработает за <code>N</code> × <code>(N-1)</code> × <code>(N-2)</code> ×… × <code>1</code> шагов. Это жесть! Всего 20 котиков уже дадут нам пару квинтиллионов операций.</p>
<div class="row">
<div class="col-xs-12 col-sm-6 flex">
<div class="boxed">
    <p><strong>🐾 Пример</strong></p>
    <p>Котики расселись по квартире. Вам хочется пожамкать каждого, но ходить лень. Какой кратчайший маршрут, чтобы обойти всех шерстяных жопок? Это ~ <code>N!</code> сравнений.</p>
</div>
</div>
<div class="col-xs-12 col-sm-6">
<figure>
  <img alt="Факториальное время" src="08-factorial.jpg" class="img-bordered-thin">
</figure>
</div>
</div>
<h2 id="резюме">Резюме</h2>
<p>Вот какие алгоритмы мы рассмотрели:</p>
<ul>
<li>Константные <code>O(1)</code></li>
<li>Логарифмические <code>O(log n)</code></li>
<li>Линейные <code>O(n)</code></li>
<li>Линейно-логарифмические <code>O(n log n)</code></li>
<li>Квадратичные <code>O(n²)</code></li>
<li>Полиномиальные <code>O(nᵏ)</code></li>
<li>Экспоненциальные <code>O(2ⁿ)</code></li>
<li>Факториальные <code>O(n!)</code></li>
</ul>
<p>Константный алгоритм — всегда лучший вариант, а логарифмический — почти всегда. С линейными и полиномиальными сложнее — тут все зависит от задачи. Где-то стыдно выбирать <code>O(n)</code>, а где-то и <code>O(n²)</code> будет большим успехом.</p>
<p><code>O(2ⁿ)</code> и <code>O(n!)</code> безумно медленные, поэтому на практике вместо них обычно используют неоптимальные, но быстрые алгоритмы.</p>
<p><em>Всем котиков! И подписывайтесь на <a href="https://twitter.com/nalgeon">@nalgeon</a> в твитере, чтобы не пропустить новые заметки 🚀</em></p>
]]></content:encoded></item><item><title>Как на самом деле устроен список в Python</title><link>https://antonz.ru/list-internals/</link><pubDate>Thu, 11 Nov 2021 16:18:00 +0000</pubDate><guid>https://antonz.ru/list-internals/</guid><description>И где у него константное время, а где линейное.</description><content:encoded><![CDATA[<p><em>Эта заметка посвящена структуре данных номер один в мире — массивам. Если вы еще не гуру алгоритмов и структур данных — гарантирую, что лучше поймете списки в питоне, их преимущества и ограничения. А если и так все знаете — освежите ключевые моменты.</em></p>
<p>Все знают, как работать со списком в питоне:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="color:#000">&gt;&gt;&gt;</span> <span style="color:#000">guests</span> <span style="color:#000">=</span> [<span style="color:#c41a16">&#34;Френк&#34;</span>, <span style="color:#c41a16">&#34;Клер&#34;</span>, <span style="color:#c41a16">&#34;Зоя&#34;</span>]
<span style="color:#000">&gt;&gt;&gt;</span> <span style="color:#000">guests</span>[<span style="color:#1c01ce">1</span>]
<span style="color:#c41a16">&#39;Клер&#39;</span>
</code></pre></div><p>Наверняка вы знаете, что выборка элемента по индексу — <code>guests[idx]</code> — отработает очень быстро даже на списке из миллиона элементов. Более точно, выборка по индексу работает за константное время O(1) — то есть не зависит от количества элементов в списке.</p>
<p>А знаете, за счет чего так быстро работает? Если да — вы в меньшинстве:</p>
<div class="row">
<div class="col-xs-12 col-sm-6">
<figure>
  <img alt="Опрос" src="survey.png">
</figure>
</div>
</div>
<p>Давайте разбираться.</p>
<h2 id="список--массив">Список = массив?</h2>
<p>В основе списка лежит массив. Массив — это набор элементов ① одинакового размера и ② расположенных в памяти подряд друг за другом, без пропусков.</p>
<p>Раз элементы одинаковые и идут подряд, получить элемент массива по индексу несложно — достаточно знать адрес самого первого элемента («головы» массива).</p>
<p>Допустим, голова находится по адресу <code>0×00001234</code>, а каждый элемент занимает 8 байт. Тогда элемент с индексом <code>idx</code> находится по адресу <code>0×00001234 + idx*8</code>:</p>
<div class="row">
<div class="col-xs-12 col-sm-6">
<figure>
  <img alt="Список — массив" src="array-1.png" class="img-bordered-thin">
</figure>
</div>
</div>
<p>Поскольку операция «получить значение по адресу» выполняется за константное время, то и выборка из массива по индексу выполняется за O(1).</p>
<p>Грубо говоря, список в питоне именно так и устроен. Он хранит указатель на голову массива и количество элементов в массиве. Количество хранится отдельно, чтобы функция <code>len()</code> тоже отрабатывала за O(1), а не считала каждый раз фактическое количество элементов списка.</p>
<p>Все хорошо, но есть пара проблем:</p>
<ul>
<li>все элементы массива одного размера, а список умеет хранить разные (true/false, числа, строки разной длины);</li>
<li>массив имеет фиксированную длину, а в список можно добавить сколько угодно элементов.</li>
</ul>
<p>Чуть позже посмотрим, как их решить.</p>
<h2 id="ну-очень-примитивный-список">Ну очень примитивный список</h2>
<p>Лучший способ освоить структуру данных — реализовать ее с нуля. К сожалению, питон плохо подходит для таких низкоуровненых структур как массив, потому что не дает явно работать с указателями (адресами в памяти).</p>
<p>Но кое-что можно сделать:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="color:#a90d91">class</span> <span style="color:#3f6e75">OhMyList</span>:
    <span style="color:#a90d91">def</span> <span style="color:#000">__init__</span>(<span style="color:#5b269a">self</span>):
        <span style="color:#5b269a">self</span><span style="color:#000">.</span><span style="color:#000">length</span> <span style="color:#000">=</span> <span style="color:#1c01ce">0</span>
        <span style="color:#5b269a">self</span><span style="color:#000">.</span><span style="color:#000">capacity</span> <span style="color:#000">=</span> <span style="color:#1c01ce">8</span>
        <span style="color:#5b269a">self</span><span style="color:#000">.</span><span style="color:#000">array</span> <span style="color:#000">=</span> (<span style="color:#5b269a">self</span><span style="color:#000">.</span><span style="color:#000">capacity</span> <span style="color:#000">*</span> <span style="color:#000">ctypes</span><span style="color:#000">.</span><span style="color:#000">py_object</span>)()

    <span style="color:#a90d91">def</span> <span style="color:#000">append</span>(<span style="color:#5b269a">self</span>, <span style="color:#000">item</span>):
        <span style="color:#5b269a">self</span><span style="color:#000">.</span><span style="color:#000">array</span>[<span style="color:#5b269a">self</span><span style="color:#000">.</span><span style="color:#000">length</span>] <span style="color:#000">=</span> <span style="color:#000">item</span>
        <span style="color:#5b269a">self</span><span style="color:#000">.</span><span style="color:#000">length</span> <span style="color:#000">+=</span> <span style="color:#1c01ce">1</span>

    <span style="color:#a90d91">def</span> <span style="color:#000">__len__</span>(<span style="color:#5b269a">self</span>):
        <span style="color:#a90d91">return</span> <span style="color:#5b269a">self</span><span style="color:#000">.</span><span style="color:#000">length</span>

    <span style="color:#a90d91">def</span> <span style="color:#000">__getitem__</span>(<span style="color:#5b269a">self</span>, <span style="color:#000">idx</span>):
        <span style="color:#a90d91">return</span> <span style="color:#5b269a">self</span><span style="color:#000">.</span><span style="color:#000">array</span>[<span style="color:#000">idx</span>]
</code></pre></div><p>Наш самописный список имеет фиксированную вместимость (<code>capacity</code> = 8 элементов) и хранит элементы в массиве <code>array</code>.</p>
<p>Модуль <code>ctypes</code> дает доступ к сишным структурам, на которых построена стандартная библиотека. В даннам случае мы используем его, чтобы создать массив размером в <code>capacity</code> элементов.</p>
<h2 id="список--массив-указателей">Список = массив указателей</h2>
<p>Список моментально выбирает элемент по индексу, потому что внутри у него массив. А массив такой быстрый, потому что все элементы у него одинакового размера.</p>
<p>Но при этом в списке элементы могут быть очень разные:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="color:#000">guests</span> <span style="color:#000">=</span> [<span style="color:#c41a16">&#34;Френк&#34;</span>, <span style="color:#c41a16">&#34;Клер&#34;</span>, <span style="color:#c41a16">&#34;Зоя&#34;</span>, <span style="color:#a90d91">True</span>, <span style="color:#1c01ce">42</span>]
</code></pre></div><p>Чтобы решить эту задачку, придумали хранить в массиве не сами значения, а указатели на них. Элемент массива — адрес в памяти, а если обратиться по адресу — получишь настоящее значение:</p>
<div class="row">
<div class="col-xs-12 col-sm-10">
<figure>
  <img alt="Список — массив указателей" src="array-2.png" class="img-bordered-thin">
  <figcaption>Элементы массива расположены подряд, а сами значения, на которые они ссылаются, могут быть вперемешку где угодно в памяти.</figcaption>
</figure>
</div>
</div>
<p>Поскольку указатели фиксированного размера (8 байт на современных 64-битных процессорах), то все прекрасно работает. Да, получается, что вместо одной операции (получить значение из элемента массива) мы делаем две:</p>
<ol>
<li>Получить адрес из элемента массива.</li>
<li>Получить значение по адресу.</li>
</ol>
<p>Но это все еще константное время O(1).</p>
<h2 id="список--динамический-массив">Список = динамический массив</h2>
<p>Если в массиве под списком остались свободные места, то метод <code>.append(item)</code> выполнится за константное время — достаточно записать новое значение в свободную ячейку и увеличить счетчик элементов на 1:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="color:#a90d91">def</span> <span style="color:#000">append</span>(<span style="color:#5b269a">self</span>, <span style="color:#000">item</span>):
    <span style="color:#5b269a">self</span><span style="color:#000">.</span><span style="color:#000">array</span>[<span style="color:#5b269a">self</span><span style="color:#000">.</span><span style="color:#000">length</span>] <span style="color:#000">=</span> <span style="color:#000">item</span>
    <span style="color:#5b269a">self</span><span style="color:#000">.</span><span style="color:#000">length</span> <span style="color:#000">+=</span> <span style="color:#1c01ce">1</span>
</code></pre></div><p>Но что делать, если массив уже заполнен?</p>
<p>Приходится выделять память под новый массив, побольше, и копировать все элементы старого массива в новый:</p>
<div class="row">
<div class="col-xs-12 col-sm-6">
<figure>
  <img alt="Список — динамический массив" src="array-3.png" class="img-bordered-thin">
  <figcaption>Когда место в старом массиве заканчивается, приходится создавать новый.</figcaption>
</figure>
</div>
</div>
<p>Примерно так:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="color:#a90d91">def</span> <span style="color:#000">append</span>(<span style="color:#5b269a">self</span>, <span style="color:#000">item</span>):
    <span style="color:#a90d91">if</span> <span style="color:#5b269a">self</span><span style="color:#000">.</span><span style="color:#000">length</span> <span style="color:#000">==</span> <span style="color:#5b269a">self</span><span style="color:#000">.</span><span style="color:#000">capacity</span>:
        <span style="color:#5b269a">self</span><span style="color:#000">.</span><span style="color:#000">_resize</span>(<span style="color:#5b269a">self</span><span style="color:#000">.</span><span style="color:#000">capacity</span><span style="color:#000">*</span><span style="color:#1c01ce">2</span>)
    <span style="color:#5b269a">self</span><span style="color:#000">.</span><span style="color:#000">array</span>[<span style="color:#5b269a">self</span><span style="color:#000">.</span><span style="color:#000">length</span>] <span style="color:#000">=</span> <span style="color:#000">item</span>
    <span style="color:#5b269a">self</span><span style="color:#000">.</span><span style="color:#000">length</span> <span style="color:#000">+=</span> <span style="color:#1c01ce">1</span>

<span style="color:#a90d91">def</span> <span style="color:#000">_resize</span>(<span style="color:#5b269a">self</span>, <span style="color:#000">new_cap</span>):
    <span style="color:#000">new_arr</span> <span style="color:#000">=</span> (<span style="color:#000">new_cap</span> <span style="color:#000">*</span> <span style="color:#000">ctypes</span><span style="color:#000">.</span><span style="color:#000">py_object</span>)()
    <span style="color:#a90d91">for</span> <span style="color:#000">idx</span> <span style="color:#000">in</span> <span style="color:#a90d91">range</span>(<span style="color:#5b269a">self</span><span style="color:#000">.</span><span style="color:#000">length</span>):
        <span style="color:#000">new_arr</span>[<span style="color:#000">idx</span>] <span style="color:#000">=</span> <span style="color:#5b269a">self</span><span style="color:#000">.</span><span style="color:#000">array</span>[<span style="color:#000">idx</span>]
    <span style="color:#5b269a">self</span><span style="color:#000">.</span><span style="color:#000">array</span> <span style="color:#000">=</span> <span style="color:#000">new_arr</span>
    <span style="color:#5b269a">self</span><span style="color:#000">.</span><span style="color:#000">capacity</span> <span style="color:#000">=</span> <span style="color:#000">new_cap</span>
</code></pre></div><p><code>._resize()</code> — затратная операция, так что новый массив создают с запасом. В примере выше новый массив в два раза больше старого, а в питоне используют более скромный коэффициент — примерно 1.12.</p>
<p>Если удалить из списка больше половины элементов через <code>.pop()</code>, то питон его скукожит — выделит новый массив поменьше и перенесет элементы в него.</p>
<p>Таким образом, список все время жонглирует массивами, чтобы это не приходилось делать нам ツ</p>
<h2 id="добавление-элемента-в-конец-списка">Добавление элемента в конец списка</h2>
<p>Выборка из списка по индексу работает за O(1) — с этим разобрались. Метод <code>.append(item)</code> тоже отрабатывает за O(1), пока не приходится расширять массив под списком. Но любое расширение массива — это операция O(n). Так за сколько же в итоге отрабатывает <code>.append()</code>?</p>
<p>Оценивать отдельную операцию вставки было бы неправильно — как мы выяснили, она иногда выполняется за O(1), а иногда и за O(n). Поэтому используют амортизационный анализ — оценивают общее время, которое займет последовательность из K операций, затем делят его на K и получают амортизированное время одной операции.</p>
<p>Так вот. Не вдаваясь в подробности скажу, что амортизированное время для <code>.append(item)</code> получается константным — O(1). Так что вставка в конец списка работает очень быстро.</p>
<div class="boxed">
<h3>Почему амортизированное время — O(1)</h3>
<p>Допустим, список пуст и мы хотим добавить в него <code>n</code> элементов. Для простоты будем использовать фактор расширения 2. Посчитаем количество атомарных операций:</p>
<ul>
  <li>первый элемент: 1 (копирование) + 1 (вставка)</li>
  <li>ещё 2: 2 (копирование) + 2 (вставка)</li>
  <li>ещё 4: 4 (копирование) + 4 (вставка)</li>
  <li>ещё 8: 8 (копирование) + 8 (вставка)</li>
  <li>...</li>
</ul>
<p>Итого на <code>n</code> элементов будет <code>n</code> операций вставки.</p>
<p>А при копировании будет</p>
<pre><code>1 + 2 + 4 + ... log(n) = 
= 2**log(n) * 2 - 1 =
= 2n - 1</code></pre>
<p>операций.</p>
<p>Итого на <code>n</code> элементов получилось <code>3n - 1</code> атомарных операций.</p>
<p><code>O((3n - 1) / n)</code> = <code>O(1)</code></p>
</div>
<p>Получается, у списка есть такие гарантированно быстрые операции:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="color:#177500"># O(1)</span>
<span style="color:#000">lst</span>[<span style="color:#000">idx</span>]

<span style="color:#177500"># O(1)</span>
<span style="color:#a90d91">len</span>(<span style="color:#000">lst</span>)

<span style="color:#177500"># амортизированное O(1)</span>
<span style="color:#000">lst</span><span style="color:#000">.</span><span style="color:#000">append</span>(<span style="color:#000">item</span>)
<span style="color:#000">lst</span><span style="color:#000">.</span><span style="color:#000">pop</span>()
</code></pre></div><h2 id="итоги">Итоги</h2>
<p>Как мы выяснили, у списка работают за O(1):</p>
<ul>
<li>выборка по индексу <code>lst[idx]</code></li>
<li>запрос длины <code>len(lst)</code></li>
<li>добавление элемента в конец списка <code>.append(item)</code></li>
<li>удаление элемента из конца списка <code>.pop()</code></li>
</ul>
<p>Остальные операции — «медленные»:</p>
<ul>
<li>Вставка и удаление из произвольной позиции — <code>.insert(idx, item)</code> и <code>.pop(idx)</code> — работают за линейное время O(n), потому что сдвигают все элементы после целевого.</li>
<li>Поиск и удаление элемента по значению — <code>item in lst</code>, <code>.index(item)</code> и <code>.remove(item)</code> — работают за линейное время O(n), потому что перебирают все элементы.</li>
<li>Выборка среза из <code>k</code> элементов — <code>lst[from:to]</code> — работает за O(k).</li>
</ul>
<p>Значит ли это, что «медленные» операции нельзя использовать? Конечно, нет. Если у вас список из 1000 элементов, разница между O(1) и O(n) для единичной операции незаметна.</p>
<p>С другой стороны, если вы миллион раз выполняете «медленную» операцию на списке из 1000 элементов — это уже заметно. Или если список из миллиона элементов — тоже.</p>
<p>Поэтому полезно знать, что у списка работает за константное время, а что за линейное — чтобы осознанно принимать решение в конкретной ситуации.</p>
<div class="row">
<div class="col-xs-12 col-sm-10 col-md-8"><p><em>Заметка из телеграм-канала <span class="nowrap"><i class="fas fa-kiwi-bird"></i> «<a href="https://t.me/ohmypy">Oh My Py</a>»</span></em></p></div>
</div>]]></content:encoded></item><item><title>Табличные выражения SQL</title><link>https://antonz.ru/cte/</link><pubDate>Fri, 05 Nov 2021 11:14:51 +0000</pubDate><guid>https://antonz.ru/cte/</guid><description>Используйте их вместо подзапросов.</description><content:encoded><![CDATA[<p>Прием № 1, чтобы писать хорошие читаемые SQL-запросы — это <em>табличные выражения</em> (CTE). Люди их боятся, а зря. Давайте разберемся за три минуты, читать увесистую книгу по SQL или проходить курсы не придется.</p>
<h2 id="проблема">Проблема</h2>
<p>Допустим, у нас есть таблица продаж по месяцам за два года:</p>
<pre tabindex="0"><code>┌──────┬───────┬───────┬──────────┬─────────┐
│ year │ month │ price │ quantity │ revenue │
├──────┼───────┼───────┼──────────┼─────────┤
│ 2019 │ 1     │ 60    │ 200      │ 12000   │
│ 2019 │ 2     │ 60    │ 660      │ 39600   │
│ 2019 │ 3     │ 60    │ 400      │ 24000   │
│ 2019 │ 4     │ 60    │ 300      │ 18000   │
│ 2019 │ 5     │ 60    │ 440      │ 26400   │
│ 2019 │ 6     │ 60    │ 540      │ 32400   │
│ 2019 │ 7     │ 60    │ 440      │ 26400   │
│ 2019 │ 8     │ 60    │ 440      │ 26400   │
│ 2019 │ 9     │ 60    │ 250      │ 15000   │
│ 2019 │ 10    │ 60    │ 420      │ 25200   │
│ ...  │ ...   │ ...   │ ...      │ ...     │
└──────┴───────┴───────┴──────────┴─────────┘
</code></pre><p><a href="https://sqlime.org/#gist:858c409b81ae3a676580cba6745d68ea">песочница</a></p>
<p>Мы хотим выбрать только те месяцы, выручка за которые превысила среднемесячную за год.</p>
<p>Для начала посчитаем среднемесячную выручку по годам:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#a90d91">select</span>
  <span style="color:#a90d91">year</span>,
  <span style="color:#a90d91">avg</span>(<span style="color:#000">revenue</span>) <span style="color:#a90d91">as</span> <span style="color:#000">avg_rev</span>
<span style="color:#a90d91">from</span> <span style="color:#000">sales</span>
<span style="color:#a90d91">group</span> <span style="color:#a90d91">by</span> <span style="color:#a90d91">year</span>;
</code></pre></div><pre tabindex="0"><code>┌──────┬─────────┐
│ year │ avg_rev │
├──────┼─────────┤
│ 2019 │ 25125.0 │
│ 2020 │ 48625.0 │
└──────┴─────────┘
</code></pre><p>Теперь можно выбрать только те записи, <code>revenue</code> в которых не уступает <code>avg_rev</code>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#a90d91">select</span>
  <span style="color:#000">sales</span>.<span style="color:#a90d91">year</span>,
  <span style="color:#000">sales</span>.<span style="color:#a90d91">month</span>,
  <span style="color:#000">sales</span>.<span style="color:#000">revenue</span>,
  <span style="color:#000">round</span>(<span style="color:#000">totals</span>.<span style="color:#000">avg_rev</span>) <span style="color:#a90d91">as</span> <span style="color:#000">avg_rev</span>
<span style="color:#a90d91">from</span> <span style="color:#000">sales</span>
  <span style="color:#a90d91">join</span> (
    <span style="color:#a90d91">select</span>
      <span style="color:#a90d91">year</span>,
      <span style="color:#a90d91">avg</span>(<span style="color:#000">revenue</span>) <span style="color:#a90d91">as</span> <span style="color:#000">avg_rev</span>
    <span style="color:#a90d91">from</span> <span style="color:#000">sales</span>
    <span style="color:#a90d91">group</span> <span style="color:#a90d91">by</span> <span style="color:#a90d91">year</span>
  ) <span style="color:#a90d91">as</span> <span style="color:#000">totals</span>
  <span style="color:#a90d91">on</span> <span style="color:#000">sales</span>.<span style="color:#a90d91">year</span> <span style="color:#000">=</span> <span style="color:#000">totals</span>.<span style="color:#a90d91">year</span>
<span style="color:#a90d91">where</span> <span style="color:#000">sales</span>.<span style="color:#000">revenue</span> <span style="color:#000">&gt;=</span> <span style="color:#000">totals</span>.<span style="color:#000">avg_rev</span>;
</code></pre></div><pre tabindex="0"><code>┌──────┬───────┬─────────┬─────────┐
│ year │ month │ revenue │ avg_rev │
├──────┼───────┼─────────┼─────────┤
│ 2019 │ 2     │ 39600   │ 25125.0 │
│ 2019 │ 5     │ 26400   │ 25125.0 │
│ 2019 │ 6     │ 32400   │ 25125.0 │
│ 2019 │ 7     │ 26400   │ 25125.0 │
│ ...  │ ...   │ ...     │ ...     │
└──────┴───────┴─────────┴─────────┘
</code></pre><p>Решили с помощью подзапроса:</p>
<ul>
<li>внутренний запрос считает среднемесячную выручку;</li>
<li>внешний соединяется с ним и фильтрует результаты.</li>
</ul>
<p>Запрос в целом получился сложноват. Если вернетесь к нему спустя месяц — наверняка потратите какое-то время на «распутывание». Проблема в том, что такие вложенные запросы приходится читать наоборот:</p>
<ul>
<li>найти самый внутренний запрос, осознать;</li>
<li>мысленно присоединить к более внешнему;</li>
<li>присоединить к следующему внешнему, и так далее.</li>
</ul>
<p>Хорошо, когда вложенных уровня два, как в нашем примере. На практике же я часто встречаю трех- и четырехуровневые подзапросы. Форменное издевательство над читателем.</p>
<h2 id="решение">Решение</h2>
<p>Вместо подзапроса можно использовать <em>табличное выражение</em> (common table expression, CTE). Любой подзапрос <code>X</code>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#a90d91">select</span> <span style="color:#000">a</span>, <span style="color:#000">b</span>, <span style="color:#a90d91">c</span>
<span style="color:#a90d91">from</span> (<span style="color:#000">X</span>)
<span style="color:#a90d91">where</span> <span style="color:#000">e</span> <span style="color:#000">=</span> <span style="color:#000">f</span>
</code></pre></div><p>Механически превращается в CTE:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#a90d91">with</span> <span style="color:#000">cte</span> <span style="color:#a90d91">as</span> (<span style="color:#000">X</span>)
<span style="color:#a90d91">select</span> <span style="color:#000">a</span>, <span style="color:#000">b</span>, <span style="color:#a90d91">c</span>
<span style="color:#a90d91">from</span> <span style="color:#000">cte</span>
<span style="color:#a90d91">where</span> <span style="color:#000">e</span> <span style="color:#000">=</span> <span style="color:#000">f</span>
</code></pre></div><p>В нашем примере:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#a90d91">with</span> <span style="color:#000">totals</span> <span style="color:#a90d91">as</span> (
  <span style="color:#a90d91">select</span>
    <span style="color:#a90d91">year</span>,
    <span style="color:#a90d91">avg</span>(<span style="color:#000">revenue</span>) <span style="color:#a90d91">as</span> <span style="color:#000">avg_rev</span>
  <span style="color:#a90d91">from</span> <span style="color:#000">sales</span>
  <span style="color:#a90d91">group</span> <span style="color:#a90d91">by</span> <span style="color:#a90d91">year</span>
)

<span style="color:#a90d91">select</span>
  <span style="color:#000">sales</span>.<span style="color:#a90d91">year</span>,
  <span style="color:#000">sales</span>.<span style="color:#a90d91">month</span>,
  <span style="color:#000">sales</span>.<span style="color:#000">revenue</span>,
  <span style="color:#000">round</span>(<span style="color:#000">totals</span>.<span style="color:#000">avg_rev</span>) <span style="color:#a90d91">as</span> <span style="color:#000">avg_rev</span>
<span style="color:#a90d91">from</span> <span style="color:#000">sales</span> 
  <span style="color:#a90d91">join</span> <span style="color:#000">totals</span> <span style="color:#a90d91">on</span> <span style="color:#000">totals</span>.<span style="color:#a90d91">year</span> <span style="color:#000">=</span> <span style="color:#000">sales</span>.<span style="color:#a90d91">year</span>
<span style="color:#a90d91">where</span> <span style="color:#000">sales</span>.<span style="color:#000">revenue</span> <span style="color:#000">&gt;=</span> <span style="color:#000">totals</span>.<span style="color:#000">avg_rev</span>;
</code></pre></div><p>С табличным выражением запрос становится одноуровневым — так воспринимать его намного проще. Кроме того, табличное выражение можно переиспользовать в пределах запроса, как будто это обычная таблица:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#a90d91">with</span> <span style="color:#000">totals</span> <span style="color:#a90d91">as</span> (...)
<span style="color:#a90d91">select</span> ... <span style="color:#a90d91">from</span> <span style="color:#000">sales_ru</span> <span style="color:#a90d91">join</span> <span style="color:#000">totals</span> ...
<span style="color:#a90d91">union</span> <span style="color:#a90d91">all</span>
<span style="color:#a90d91">select</span> ... <span style="color:#a90d91">from</span> <span style="color:#000">sales_us</span> <span style="color:#a90d91">join</span> <span style="color:#000">totals</span> ...
</code></pre></div><p>Табличные выражения SQL чем-то похожи на функции в обычном языке программирования — они уменьшают общую сложность:</p>
<ul>
<li>Можно написать нечитаемую простыню кода, а можно разбить код на понятные отдельные функции и составить программу из них.</li>
<li>Можно возвести башню из пяти этажей подзапросов, а можно вынести подзапросы в CTE и составить общий запрос из них.</li>
</ul>
<h2 id="cte-против-подзапроса">CTE против подзапроса</h2>
<p>Существует миф, что «CTE медленные». Он пришел из старых версий PostgreSQL (11 и раньше), которые всегда <em>материализовали</em> CTE — вычисляли полный результат табличного выражения и запоминали до конца запроса.</p>
<p>Обычно это хорошо: один раз вычислил результат, и дальше используешь его несколько раз по ходу основного запроса. Но иногда материализация мешала движку оптимизировать запрос:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#a90d91">with</span> <span style="color:#000">cte</span> <span style="color:#a90d91">as</span> (<span style="color:#a90d91">select</span> <span style="color:#000">*</span> <span style="color:#a90d91">from</span> <span style="color:#000">foo</span>)
<span style="color:#a90d91">select</span> <span style="color:#000">*</span> <span style="color:#a90d91">from</span> <span style="color:#000">cte</span> <span style="color:#a90d91">where</span> <span style="color:#000">id</span> <span style="color:#000">=</span> <span style="color:#1c01ce">500000</span>;
</code></pre></div><p>Здесь выбирается ровно одна запись по идентификатору, но материализация создает в памяти копию <em>всей таблицы</em> — из-за этого запрос отработает очень медленно.</p>
<p>PostgreSQL 12+ и другие современные СУБД поумнели и больше так не делают. Материализация применяется, когда от нее больше пользы, чем вреда. Плюс, многие СУБД позволяют явно управлять этим поведением через инструкции <code>MATERIALIZED</code> / <code>NOT MATERIALIZED</code>.</p>
<p>Так что CTE не медленнее подзапросов. А если сомневаетесь, всегда можно сделать два варианта — подзапрос и табличное выражение — и сравнить план и время выполнения.</p>
<p>Как понять, когда использовать подзапрос, а когда CTE? Я вывел для себя простое правило, которое пока ни разу не подвело:</p>
<blockquote class="big">
<p>Всегда использовать CTE</p>
</blockquote>
<p>Чего и вам желаю.</p>
<div class="row">
<div class="col-xs-12 col-sm-10 col-md-8"><p><em>И подписывайтесь на канал <span class="nowrap"><i class="fas fa-database"></i> «<a href="https://t.me/sqliter">SQLite на практике</a>»</span></em></p></div>
</div>
]]></content:encoded></item><item><title>Справочник адресов России</title><link>https://antonz.ru/fias/</link><pubDate>Sun, 24 Oct 2021 17:02:08 +0000</pubDate><guid>https://antonz.ru/fias/</guid><description>Который ведет налоговая.</description><content:encoded><![CDATA[<p>Не все знают, что в России есть Великий Справочник Адресов, в который свято веруют все чиновники (да и не только они). Расскажу о нём немного. Без официальной нуднятины, только задорные факты из жизни.</p>
<p>Справочник адресов называется «ФИАС» (федеральная информационная адресная система) или «ГАР» (государственный адресный реестр) — это одно и то же. Раньше назывался «КЛАДР» (классификатор адресов). Технически поддерживает его налоговая, а данные о домах и улицах вносят местные чиновники по всей стране. У справочника даже есть сайт (не читайте его): <a href="https://fias.nalog.ru">fias.nalog.ru</a></p>
<p>Вот как видит нашу родину налоговая служба:</p>
<ul>
<li>86 регионов</li>
<li>3 тыс. городов</li>
<li>300 тыс. населённых пунктов</li>
<li>1 млн улиц</li>
<li>31 млн домов</li>
<li>52 млн квартир</li>
</ul>
<p>У каждого адреса есть тип и название. Скажем, тип = «город», название = «Самара». Или тип = «республика», название = «Бурятия». Но если вам повезло жить в республике Чувашия, то тип = «Чувашия», название = «Чувашская республика». Потому что пошёл ты нахер, вот почему.</p>
<p>ФИАС — истина в последней инстанции для всех гос. органов. Если вы живёте в Кабардино-Балкарии на Моздокской улице, а у налоговой она значится как «МосдоГская» (в честь знаменитых кабардино-балкарских догов, видимо), то ни одному чиновнику вы свою правоту не докажете.</p>
<figure>
  <img alt="Странные дома" src="fias-house-zero.png">
  <figcaption>Дурная фантазия чиновников безгранична</figcaption>
</figure>
<p>Или ещё был случай. В 2018 году питерским чиновникам стало скучно, и они домам приделали «литеру А». Был «Невский проспект, дом 41», а стал «дом 41 литер А». И так со всеми домами в городе. На табличках нормально написано, а в голове у чиновников — с литерами. Deal with it.</p>
<p>Справочник полон милых идиотизмов. Однажды перестали помещаться гаражи и садовые товарищества, и налоговая додумалась добавить новый «уровень» адреса для них. Загадочно назвали его «планировочная структура». Но забыли рассказать местным чиновникам, что это такое и зачем. Поэтому теперь в «планировочных структурах» лежит всё от жилых кварталов до районов городов и международных трасс. Бадум-тсс!</p>
<p>Ах да. Если вы думаете, что живёте в городе, то разочарую. На самом деле это не «город», а «городской округ». Это называется «муниципальное деление»: городские округа вместо городов, сельские поселения вместо сёл, и так далее. Ну, чтобы никто не догадался.</p>
<p>Налоговая любит внезапно менять справочник. То все дома в городе потеряет, то битых улиц насыпет, то просто два месяца не обновляет. Объяснений и анонсов, конечно же, никто не делает. Сами разберётесь, не маленькие.</p>
<p>Но. Хоть я и ворчу, ФИАС — большое благо! Это структурированный, регулярно обновляемый справочник адресов, доступный всем желающим. У большинства стран такого нет, так что пусть завидуют 👌</p>
<p><em>Подписывайтесь на <a href="https://twitter.com/nalgeon">@nalgeon</a> в твитере, чтобы не пропустить новые заметки</em></p>
]]></content:encoded></item><item><title>Вы являетесь дизайнеру в страшном сне</title><link>https://antonz.ru/tinkoff-signin/</link><pubDate>Thu, 07 Oct 2021 13:49:33 +0000</pubDate><guid>https://antonz.ru/tinkoff-signin/</guid><description>Помогаем Тинькову избавиться от косноязычия на форме входа.</description><content:encoded><![CDATA[<p>Интернет-банк Тинькова при входе встречает многозначительной надписью:</p>
<figure>
  <img alt="Вы являетесь держателем" src="tinkoff-signin-1.png">
</figure>
<blockquote class="big">
Вы являетесь держателем продуктов Тинькофф Банка. При входе по номеру телефона, в целях безопасности, введите пароль.
</blockquote>
<p>Я, конечно, не UX-писатель, но это жуть какая кривая формулировка. Давайте попробуем улучшить.</p>
<h2 id="1-формулируем-по-человечески">1. Формулируем по-человечески</h2>
<p>Меняем суконный язык банковских безопасников на нормальную речь.</p>
<blockquote class="big">
Вы являетесь держателем продуктов Тинькофф Банка. При входе по номеру телефона, в целях безопасности, введите пароль.<br>↓
</blockquote>
<blockquote class="big">
Вы — клиент Тинькофф Банка. Введите пароль, чтобы войти.
</blockquote>
<h2 id="2-убираем-лишнее">2. Убираем лишнее</h2>
<p>Зачем писать человеку, что он клиент? Я и так это знаю, потому и пытаюсь войти в интернет-банк. Убираем.</p>
<blockquote class="big">
Вы — клиент Тинькофф Банка. Введите пароль, чтобы войти.<br>↓
</blockquote>
<blockquote class="big">Введите пароль, чтобы войти.</blockquote>
<h2 id="3-убираем-очевидное">3. Убираем очевидное</h2>
<p>На этой же форме огроменное поле ПАРОЛЬ и кнопка ВОЙТИ. Спорим, человек догадается, чего от него хотят?</p>
<blockquote class="big">Введите пароль, чтобы войти.<br>↓</blockquote>
<blockquote class="big">Ø</blockquote>
<p>Что осталось:</p>
<figure>
  <img alt="Больше не являетесь" src="tinkoff-signin-2.png">
</figure>
<h2 id="qa">Q&amp;A</h2>
<blockquote>
<p>А это не юридический затык? У Тинькофа вроде всё хорошо с ux-райтингом во всех других местах.</p>
</blockquote>
<p>У Тинькова есть некоторое количество сотрудников, которые умеют писать нормальный текст, и огромная армия тех, кто делать этого не умеет и не желает. Вторые иногда прорываются. Хотя первые в целом отлично справляются, да.</p>
<blockquote>
<p>Мне кажется, предполагать, что человек сразу поймет, куда он входит, слишком смело.</p>
</blockquote>
<p>Действительно, он зашел на сайт Тинькова, нажал на «Войти», указал номер телефона. Конечно, он понятия не имеет, что делает.</p>
<blockquote>
<p>А может это было сделано по требованиям accessibility? Чтобы читалка озвучила, например.</p>
</blockquote>
<p>Это делается иначе.</p>
<blockquote>
<p>Не уверен, что насчет этого можно сразу рассуждать предположениями. Как реально юзеры реагируют на такую форму можно понять только через исследования.</p>
</blockquote>
<p>Не надо проводить исследования, чтобы исправить очевидные проблемы. Исследования не заменяют головной мозг, пользуйтесь им.</p>
<div class="row">
<div class="col-xs-12 col-sm-10 col-md-8"><p><em>Заметка из телеграм-канала <span class="nowrap"><i class="far fa-star color-sin"></i> «<a href="https://t.me/dangry">Интерфейсы без шелухи</a>»</span></em></p></div>
</div>
]]></content:encoded></item><item><title>SQLite-песочница в браузере</title><link>https://antonz.ru/sqlime/</link><pubDate>Tue, 28 Sep 2021 21:13:03 +0000</pubDate><guid>https://antonz.ru/sqlime/</guid><description>Для отладки и шаринга запросов.</description><content:encoded><![CDATA[<p>Чего мне всегда не хватало, так это аналога JSFiddle для SQLite. Онлайн-песочницы, в которой можно быстро проверить SQL-запрос и поделиться с другими.</p>
<p><a href="https://sqlime.org/"><img src="sqlime.png" alt="SQLime"></a></p>
<p>Вот чего хотелось:</p>
<ul>
<li>Возможность загрузить готовую базу, а не писать SQL для создания таблиц.</li>
<li>Подключать как локальные базы, так и удаленные (по url).</li>
<li>Сохранять базу и запросы в облаке.</li>
<li>Бесплатно и без регистрации.</li>
<li>Свежайшая версия SQLite.</li>
<li>Минимализм.</li>
</ul>
<p>В итоге сделал такую песочницу сам:</p>
<ul>
<li><a href="https://sqlime.org/">демка</a> с пустой базой;</li>
<li><a href="https://sqlime.org/#gist:e012594111ce51f91590c4737e41a046">пример</a> заполненной базы;</li>
<li><a href="https://github.com/nalgeon/sqlime">исходники</a>.</li>
</ul>
<p><a href="https://habr.com/ru/post/580240/">подробности на Хабре</a></p>
]]></content:encoded></item><item><title>Как хранят данные в браузере</title><link>https://antonz.ru/browser-storage/</link><pubDate>Sun, 26 Sep 2021 09:36:07 +0000</pubDate><guid>https://antonz.ru/browser-storage/</guid><description>От мохнатой древности до нашего времени.</description><content:encoded><![CDATA[<p>Поговорим о том, как люди хранили данные в браузере, от мохнатой древности до нашего времени.</p>
<h2 id="1-куки">1. Куки</h2>
<p>Первые инженеры, едва переодевшись из шкур в неопрятные свитера, попытались использовать родной и привычный HTTP-протокол. Проблема в том, что он не хранит состояние (stateless) — пять запросов от Алисы выглядят точно так же, как пять запросов от пяти разных людей.</p>
<p>Что же делать? В любой непонятной ситуации придумывай костыль! Так появились <em>куки</em> (cookie). Это пары строк (ключ — значение), которые браузер гоняет на сервер с каждым запросом. Таким образом stateless протокол внезапно становится немножко stateful.</p>
<figure>
  <img alt="Куки" class="img-bordered-thin" src="storage-cookies.png">
</figure>
<p>Куки хороши тем, что доступны и на клиенте, и на сервере. Когда вы ходите по страницам интернет-магазина и складываете товары в корзину, браузер с каждым запросом передает в куках идентификатор сессии. По нему сервер магазина понимает, что товары относятся именно к вашей корзине.</p>
<p>Куку может установить не только тот сайт, на котором вы находитесь, но и вообще любой (так называемые third-party cookies). Этим немедленно воспользовались хитрозадые рекламодатели. Если на сайте магазина подключен фейсбук, а вы купили ботинки — теперь до конца жизни будете видеть рекламу ботинок на всех сайтах, подключенных к фейсбуку.</p>
<p>Third-party cookies можно отключить в настройках браузера, а в Сафари они даже отключены по умолчанию. Рекомендую это сделать. Правда, некоторые особенно кривые сайты при этом перестанут работать — но оно и к лучшему, как по мне.</p>
<p>Работа с куками в JS реализована традиционно для веба — максимально неудобно. <code>document.cookie</code> — это все куки, склеенные в одну строку через точку с запятой. Наслаждайтесь парсингом.</p>
<p>Вообще, о куках можно еще много плохого рассказать. Делать этого я, конечно, не буду.</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies">Куки на MDN</a></p>
<h2 id="2-web-storage">2. Web Storage</h2>
<p>Постепенно разработчики поняли, что надо оставить HTTP в покое и сделать нормальное API хранения данных в браузере. Так появились <em>localStorage</em> и <em>sessionStorage</em> с очень простым интерфейсом:</p>
<ul>
<li>получить значение по ключу,</li>
<li>записать значение по ключу,</li>
<li>удалить значение по ключу.</li>
</ul>
<p>localStorage хранит данные вечно, а sessionStorage — только пока открыта вкладка браузера. local свой у каждого домена, чужие данные посмотреть не получится. А session отдельный у каждой вкладки. Максимальный размер базы — несколько мегабайт.</p>
<figure>
  <img alt="Web Storage" class="img-bordered-thin" src="storage-webstorage.png">
</figure>
<p>И ключи, и значения — только строки, так что числа, массивы и объекты приходится превращать в строку перед сохранением. И парсить из строки при выборке. Обычно не заморачиваются и используют <code>JSON.stringify</code> / <code>JSON.parse</code>.</p>
<p>sessionStorage редко используют, а вот localStorage весьма популярен. Простой, удобный, быстрый — что еще надо:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#a90d91">let</span> <span style="color:#000">obj</span> <span style="color:#000">=</span> { <span style="color:#000">a</span><span style="color:#000">:</span> <span style="color:#1c01ce">42</span> };
<span style="color:#a90d91">let</span> <span style="color:#000">objStr</span> <span style="color:#000">=</span> <span style="color:#000">JSON</span>.<span style="color:#000">stringify</span>(<span style="color:#000">obj</span>);
<span style="color:#000">localStorage</span>.<span style="color:#000">setItem</span>(<span style="color:#c41a16">&#34;q&#34;</span>, <span style="color:#000">objStr</span>);

<span style="color:#a90d91">let</span> <span style="color:#000">objStr</span> <span style="color:#000">=</span> <span style="color:#000">localStorage</span>.<span style="color:#000">getItem</span>(<span style="color:#c41a16">&#34;q&#34;</span>);
<span style="color:#000">JSON</span>.<span style="color:#000">parse</span>(<span style="color:#000">objStr</span>);
<span style="color:#177500">// {a: 42}
</span></code></pre></div><p>Ребята из команды Chrome рекомендуют вместо Web Storage использовать более новый механизм — IndexedDB. Это, мягко говоря, странный совет — но о своеобразном подходе разработчиков браузеров мы еще поговорим.</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API">Web Storage на MDN</a></p>
<h2 id="3-web-sql">3. Web SQL</h2>
<p>Постепенно разработчики дозрели до полноценной базы данных в браузере. Надо сказать, что абсолютно во всех браузерах — что мобильных, что десктопных — уже встроена отличная СУБД, которая реализует стандарт SQL-92 (и большой кусок более поздних стандартов) — <a href="https://sqlite.org/">SQLite</a>.</p>
<figure>
  <img alt="Web SQL" class="img-bordered-thin" src="storage-websql.png">
</figure>
<p>Казалось бы, придумай удобный интерфейс поверх SQLite, согласуй со всеми и вперед — что может быть логичнее? Собственно, в конце нулевых так и сделали — новый стандарт <em>Web SQL</em> поддержали Apple (Safari), Google (Chrome) и Opera (еще популярная тогда). А Mozilla (Firefox) — нет.</p>
<p>Замечательные люди из Мозиллы заявили, что:</p>
<ol>
<li>Использовать SQL в вебе некрасиво, у веба свой путь.</li>
<li>Где это видано, всем использовать SQLite, вместо того, чтобы каждый браузер напилил свой велосипед.</li>
</ol>
<p>Классные аргументы, да? Очень характерно для веба.</p>
<p>В результате Web SQL убили, использовать его сейчас нельзя. А элегантное решение, которое гении из Мозиллы породили ему на замену (IndexedDB), я вам скоро покажу.</p>
<div class="boxed">
<p><strong>🤔 SQL в браузере</strong></p>
<p>Если интересно, как может работать настоящий SQL в браузере — попробуйте онлайн-песочницу <strong><a href="https://sqlime.org/">sqlime</a></strong>. Там можно подключить любую SQLite-базу или создать новую с нуля и делать к ней запросы прямо из браузера.</p>
</div>
<p><a href="https://docs.tizen.org/application/web/guides/w3c/storage/websql/">Документация по Web SQL</a> (для полноты картины)</p>
<h2 id="4-indexed-database">4. Indexed Database</h2>
<p>Ну уж тут-то разработчики браузеров развернулись. <em>IndexedDB</em> — это настоящая NoSQL-база данных у вас в браузере. Можно сделать полноценное приложение, которое шустро ворочает сотнями мегабайт данных, не обращаясь к серверу. Прямо на вашем айфоне, мухаха.</p>
<p>Начнем с хорошего в IndexedDB:</p>
<ul>
<li>есть коллекции (аналог таблиц в реляционных БД), индексы и транзакции;</li>
<li>без проблем хранит массивы и объекты;</li>
<li>поддерживает версионирование схемы данных;</li>
<li>(условно) неограниченный размер базы;</li>
<li>работает асинхронно.</li>
</ul>
<figure>
  <img alt="Indexed Database" class="img-bordered-thin" src="storage-indexeddb.png">
</figure>
<p>А теперь о плохом:</p>
<blockquote class="big"><p>всё очень сложно</p></blockquote>
<p>Никаких вам get / set, будьте любезны освоить многочисленные концепции, приемы и особенности работы, чтобы записать свой несчастный объект в базу и получить его обратно. Уверен, вы просто мечтали освоить еще одну СУБД. Ваши мечты сбылись.</p>
<figure>
  <img alt="Код для IndexedDB" class="img-bordered-thin" src="storage-indexeddb-tutotial.png">
  <figcaption>Картинка из туториала по IndexedDB, для вдохновения. Пришлось уменьшить масштаб, а то на экран не влезала.</figcaption>
</figure>
<p>Ах, и еще. В вебе есть стандарт асинхронной работы — механизм промисов (promise) и async / await. Так вот, IndexedDB его не поддерживает. Потому что fuck you, that&rsquo;s why. Используйте костылики (<a href="https://github.com/jakearchibald/idb">idb</a>) — это ведь так элегантно.</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API">IndexedDB на MDN</a></p>
<h2 id="5-cache-api">5. Cache API</h2>
<p>Допустим, у вас веб-приложение для заметок. Было бы здорово, чтобы оно работало даже когда нет сети, верно?</p>
<p>Сами заметки можно хранить в localStorage или IndexedDB. Но что делать, если человек обновит страницу, а сети нет? Тут и пригодится <em>Cache API</em>.</p>
<p>Cache API создан, чтобы хранить не данные приложения, а сетевые запросы и ответы. Обычно это файлы приложения — все ваши <code>*.html</code>, <code>*.css</code> и <code>*.js</code></p>
<p>Если сохранить файлы в кеш, то в офлайн-режиме можно перехватить запросы и вернуть их из кеша, когда человек обновит страницу. За перехват отвечает другой механизм — service worker, о нем не будем.</p>
<p>Cache API простой и асинхронный, одно удовольствие:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#a90d91">const</span> <span style="color:#000">cache</span> <span style="color:#000">=</span> <span style="color:#a90d91">await</span> <span style="color:#000">caches</span>.<span style="color:#000">open</span>(<span style="color:#c41a16">&#34;app&#34;</span>);
<span style="color:#a90d91">await</span> <span style="color:#000">cache</span>.<span style="color:#000">add</span>(<span style="color:#c41a16">&#34;/app.js&#34;</span>);
<span style="color:#a90d91">const</span> <span style="color:#000">resp</span> <span style="color:#000">=</span> <span style="color:#a90d91">await</span> <span style="color:#000">cache</span>.<span style="color:#000">match</span>(<span style="color:#c41a16">&#34;/app.js&#34;</span>);
</code></pre></div><p><code>.add()</code> сам запросит указанный файл и сложит ответ в кеш, такой заботливый.</p>
<p>Возможно, вы ожидаете, что Cache API умеет очищать старые или редко используемые записи (на то он и кеш). Но нет! Это веб, так что решите вопрос как-нибудь самостоятельно.</p>
<p>На самом деле, никто не мешает использовать кеш и для данных приложения. Но так обычно не делают:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#a90d91">const</span> <span style="color:#000">data</span> <span style="color:#000">=</span> { <span style="color:#000">a</span><span style="color:#000">:</span> <span style="color:#1c01ce">42</span> };
<span style="color:#a90d91">let</span> <span style="color:#000">resp</span> <span style="color:#000">=</span> <span style="color:#a90d91">new</span> <span style="color:#000">Response</span>(<span style="color:#000">JSON</span>.<span style="color:#000">stringify</span>(<span style="color:#000">data</span>));
<span style="color:#a90d91">await</span> <span style="color:#000">cache</span>.<span style="color:#000">put</span>(<span style="color:#c41a16">&#34;data.json&#34;</span>, <span style="color:#000">resp</span>);

<span style="color:#000">resp</span> <span style="color:#000">=</span> <span style="color:#a90d91">await</span> <span style="color:#000">cache</span>.<span style="color:#000">match</span>(<span style="color:#c41a16">&#34;data.json&#34;</span>);
<span style="color:#a90d91">await</span> <span style="color:#000">resp</span>.<span style="color:#000">json</span>();
<span style="color:#177500">// { a: 42 }
</span></code></pre></div><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Cache">Cache API на MDN</a></p>
<h2 id="6-storage-api">6. Storage API</h2>
<p><em>Storage API</em> на самом деле ничего не хранит (обожаю веб). Вместо этого оно сообщает, сколько места занято вашим барахлом и сколько всего доступно.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#a90d91">const</span> {<span style="color:#000">usage</span>, <span style="color:#000">quota</span>} <span style="color:#000">=</span> <span style="color:#a90d91">await</span> <span style="color:#000">navigator</span>.<span style="color:#000">storage</span>.<span style="color:#000">estimate</span>();
</code></pre></div><p><code>usage</code> и <code>quota</code> считаются суммарно по всем видам хранилищ — Web Storage, IndexedDB и CacheAPI.</p>
<p>А ещё можно сообщить браузеру, что ваши данные ну очень ценные, и молча удалять их никак нельзя, только с разрешения человека:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#000">navigator</span>.<span style="color:#000">storage</span>.<span style="color:#000">persist</span>()
</code></pre></div><p>Storage API пока не работает в Safari. Увы.</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Storage_API">Storage API на MDN</a></p>
<h2 id="7-file-whatever-api">7. File (whatever) API</h2>
<p>Пара замечательных API с интуитивно понятными названиями: <em>File System Access API</em> и <em>File and Directory Entries API</em>.</p>
<p>Когда-нибудь они позволят вам писать файлы прямо на устройство пользователя. Но пока совсем сырые, так что не будем на них останавливаться.</p>
<h2 id="очень-краткие-выводы">Очень краткие выводы</h2>
<ul>
<li>Web Storage для мелочевки</li>
<li>IndexedDB для серьезных данных</li>
<li>Cache API для файлов и запросов</li>
</ul>
<p>Куки оставьте Цукербергу, Web SQL погиб молодым, File * API ещё не родились, а Storage API считает место.</p>
<p><em>И подписывайтесь на <a href="https://twitter.com/nalgeon">@nalgeon</a> в твитере, чтобы не пропустить новые заметки</em> 🚀</p>
]]></content:encoded></item></channel></rss>