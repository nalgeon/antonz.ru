<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Антон Жиянов</title>
    <description>Разработка софта, продуктоводство и здравый смысл</description>
    <link>https://antonz.ru/</link>
    <image>
      <url>https://antonz.ru/assets/favicon/favicon.png</url>
      <title>Антон Жиянов</title>
      <link>https://antonz.ru/</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <language>ru-ru</language>
    <lastBuildDate>Thu, 25 Nov 2021 16:30:00 +0000</lastBuildDate><atom:link href="https://antonz.ru/rss" rel="self" type="application/rss+xml" />
    <item>
      <title>Скорость алгоритмов (на котиках)</title>
      <link>https://antonz.ru/big-o/</link>
      <pubDate>Thu, 25 Nov 2021 16:30:00 +0000</pubDate>
      
      <guid>https://antonz.ru/big-o/</guid>
      <description>Как определить, насколько быстрый получился алгоритм? Разбираемся на шерстяных жопках.</description>
      <content:encoded><![CDATA[<p>Давайте посмотрим, как программисты оценивают, быстро работает алгоритм или медленно. Поскольку тема максимально занудная, разбираться будем на дурацких примерах с котиками.</p>
<h2 id="константное-время-o1">Константное время, O(1)</h2>
<p>Самый лучший вариант, скорость алгоритма не зависит от количества котиков.</p>
<div class="row">
<div class="col-xs-12 col-sm-6 flex">
<div class="boxed">
    <p><strong>🐾 Пример</strong></p>
    <p>Вы — счастливый обладатель <code>N</code> котиков. Каждый котик знает, как его зовут. Если позвать «Клёпа!», то прибежит только он, а остальным <code>N-1</code> жопкам пофиг.</p>
</div>
</div>
<div class="col-xs-12 col-sm-6">
<figure>
  <img alt="Константное время" src="01-constant.jpg" class="img-bordered-thin">
</figure>
</div>
</div>
<h2 id="логарифмическое-время-ologn">Логарифмическое время, O(log n)</h2>
<p>На <code>N</code> котиках алгоритм отрабатывает за <code>log(N)</code> шагов. Это быстро! 1 000 000 котиков → всего 20 операций.</p>
<div class="row">
<div class="col-xs-12 col-sm-6 flex">
<div class="boxed">
    <p><strong>🐾 Пример</strong></p>
    <p>Мисочки у котиков расставлены по алфавиту. Когда у вас появляется новый котик, место для его мисочки находится за <code>log(N)</code> шагов.</p>
</div>
</div>
<div class="col-xs-12 col-sm-6">
<figure>
  <img alt="Логарифмическое время" src="02-log.jpg" class="img-bordered-thin">
</figure>
</div>
</div>
<h2 id="линейное-время-on">Линейное время, O(n)</h2>
<p>На <code>N</code> котиках алгоритм отрабатывает за <code>N</code> шагов. Это значит, каждый раз приходится перебирать всех кошачьих. Ну такое.</p>
<div class="row">
<div class="col-xs-12 col-sm-6 flex">
<div class="boxed">
    <p><strong>🐾 Пример</strong></p>
    <p>Котики взбунтовались и перестали отзываться на клички. Теперь приходится обходить <code>N</code> шубок, чтобы найти нужного.</p>
</div>
</div>
<div class="col-xs-12 col-sm-6">
<figure>
  <img alt="Линейное время" src="03-linear.jpg" class="img-bordered-thin">
</figure>
</div>
</div>
<h2 id="линейно-логарифмическое-время-onlogn">Линейно-логарифмическое время, O(n log n)</h2>
<p>На <code>N</code> котиках алгоритм отрабатывает за <code>N</code> × <code>log(N)</code> шагов. Это дольше, чем за линейное время, но ненамного (логарифм <code>N</code> всегда намного меньше <code>N</code>, помните?).</p>
<div class="row">
<div class="col-xs-12 col-sm-6 flex">
<div class="boxed">
    <p><strong>🐾 Пример</strong></p>
    <p>К приходу гостей вы решили рассадить котиков по размеру. Алгоритм quick sort справится с этим за <code>N</code> × <code>log(N)</code> шагов.</p>
</div>
</div>
<div class="col-xs-12 col-sm-6">
<figure>
  <img alt="Линейно-логарифмическое время" src="04-log-linear.jpg" class="img-bordered-thin">
</figure>
</div>
</div>
<p>На очереди у нас неторопливые полиномиальные котики и улиточные суперполиномиальные.</p>
<h2 id="квадратичное-время-on">Квадратичное время O(n²)</h2>
<p>На <code>N</code> котиках алгоритм отрабатывает за <code>N²</code> шагов. Ме-е-едленно.</p>
<div class="row">
<div class="col-xs-12 col-sm-6 flex">
<div class="boxed">
    <p><strong>🐾 Пример</strong></p>
    <p>Конкурент утверждает, что его <code>N</code> котиков более гладкие и довольные, чем ваши. Специальная комиссия попарно сравнит хвостатых, чтобы вынести справедливый вердикт. Понадобится ~ <code>N²</code> сравнений.</p>
</div>
</div>
<div class="col-xs-12 col-sm-6">
<figure>
  <img alt="Квадратичное время" src="05-quadratic.jpg" class="img-bordered-thin">
</figure>
</div>
</div>
<h2 id="полиномиальное-время-onᵏ">Полиномиальное время, O(nᵏ)</h2>
<p>На <code>N</code> котиках алгоритм отрабатывает за <code>N³</code> шагов, <code>N⁴</code> шагов, <code>N⁵</code> шагов, или ещё дольше. Фу таким быть.</p>
<div class="row">
<div class="col-xs-12 col-sm-6 flex">
<div class="boxed">
    <p><strong>🐾 Пример</strong></p>
    <p>Фотосессия! Каждого из <code>N</code> котиков надо попарно отфоткать с другими, причем фотограф делает <code>N</code> снимков на каждую пару. <code>N</code> × <code>N</code> × <code>N</code> ≃ <code>N³</code> шагов.</p>
</div>
</div>
<div class="col-xs-12 col-sm-6">
<figure>
  <img alt="Полиномиальное время" src="06-polinomial.jpg" class="img-bordered-thin">
</figure>
</div>
</div>
<p>Хоть полиномиальные алгоритмы и не славятся быстротой, по сравнению с суперполиномиальными они стремительны как Флеш. Из суперского у «суперполиномиальных» только название, увы. Сейчас покажу.</p>
<h2 id="экспоненциальное-время-o2ⁿ">Экспоненциальное время, O(2ⁿ)</h2>
<p>На <code>N</code> котиках алгоритм отрабатывает за <code>2ⁿ</code> шагов. Это долго, вы вряд ли дождетесь.</p>
<div class="row">
<div class="col-xs-12 col-sm-6 flex">
<div class="boxed">
    <p><strong>🐾 Пример</strong></p>
    <p>Котики отправляются на выставку. Каждого взвесили и оценили в звездах. Но перевозка рассчитана максимум на X килограмм. Как выбрать самый звездный состав? Ответ потребует <code>2ⁿ</code> шагов.</p>
</div>
</div>
<div class="col-xs-12 col-sm-6">
<figure>
  <img alt="Экспоненциальное время" src="07-exponential.jpg" class="img-bordered-thin">
</figure>
</div>
</div>
<h2 id="факториальное-время-on">Факториальное время, O(n!)</h2>
<p>На <code>N</code> котиках алгоритм отработает за <code>N</code> × <code>(N-1)</code> × <code>(N-2)</code> ×… × <code>1</code> шагов. Это жесть! Всего 20 котиков уже дадут нам пару квинтиллионов операций.</p>
<div class="row">
<div class="col-xs-12 col-sm-6 flex">
<div class="boxed">
    <p><strong>🐾 Пример</strong></p>
    <p>Котики расселись по квартире. Вам хочется пожамкать каждого, но ходить лень. Какой кратчайший маршрут, чтобы обойти всех шерстяных жопок? Это ~ <code>N!</code> сравнений.</p>
</div>
</div>
<div class="col-xs-12 col-sm-6">
<figure>
  <img alt="Факториальное время" src="08-factorial.jpg" class="img-bordered-thin">
</figure>
</div>
</div>
<h2 id="резюме">Резюме</h2>
<p>Вот какие алгоритмы мы рассмотрели:</p>
<ul>
<li>Константные <code>O(1)</code></li>
<li>Логарифмические <code>O(log n)</code></li>
<li>Линейные <code>O(n)</code></li>
<li>Линейно-логарифмические <code>O(n log n)</code></li>
<li>Квадратичные <code>O(n²)</code></li>
<li>Полиномиальные <code>O(nᵏ)</code></li>
<li>Экспоненциальные <code>O(2ⁿ)</code></li>
<li>Факториальные <code>O(n!)</code></li>
</ul>
<p>Константный алгоритм — всегда лучший вариант, а логарифмический — почти всегда. С линейными и полиномиальными сложнее — тут все зависит от задачи. Где-то стыдно выбирать <code>O(n)</code>, а где-то и <code>O(n²)</code> будет большим успехом.</p>
<p><code>O(2ⁿ)</code> и <code>O(n!)</code> безумно медленные, поэтому на практике вместо них обычно используют неоптимальные, но быстрые алгоритмы.</p>
<p><em>Всем котиков! И подписывайтесь на <a href="https://twitter.com/nalgeon">@nalgeon</a> в твитере, чтобы не пропустить новые заметки 🚀</em></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Как на самом деле устроен список в Python</title>
      <link>https://antonz.ru/list-internals/</link>
      <pubDate>Thu, 11 Nov 2021 16:18:00 +0000</pubDate>
      
      <guid>https://antonz.ru/list-internals/</guid>
      <description>И где у него константное время, а где линейное.</description>
      <content:encoded><![CDATA[<p><em>Эта заметка посвящена структуре данных номер один в мире — массивам. Если вы еще не гуру алгоритмов и структур данных — гарантирую, что лучше поймете списки в питоне, их преимущества и ограничения. А если и так все знаете — освежите ключевые моменты.</em></p>
<p>Все знают, как работать со списком в питоне:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="color:#000">&gt;&gt;&gt;</span> <span style="color:#000">guests</span> <span style="color:#000">=</span> [<span style="color:#c41a16">&#34;Френк&#34;</span>, <span style="color:#c41a16">&#34;Клер&#34;</span>, <span style="color:#c41a16">&#34;Зоя&#34;</span>]
<span style="color:#000">&gt;&gt;&gt;</span> <span style="color:#000">guests</span>[<span style="color:#1c01ce">1</span>]
<span style="color:#c41a16">&#39;Клер&#39;</span>
</code></pre></div><p>Наверняка вы знаете, что выборка элемента по индексу — <code>guests[idx]</code> — отработает очень быстро даже на списке из миллиона элементов. Более точно, выборка по индексу работает за константное время O(1) — то есть не зависит от количества элементов в списке.</p>
<p>А знаете, за счет чего так быстро работает? Если да — вы в меньшинстве:</p>
<div class="row">
<div class="col-xs-12 col-sm-6">
<figure>
  <img alt="Опрос" src="survey.png">
</figure>
</div>
</div>
<p>Давайте разбираться.</p>
<h2 id="список--массив">Список = массив?</h2>
<p>В основе списка лежит массив. Массив — это набор элементов ① одинакового размера и ② расположенных в памяти подряд друг за другом, без пропусков.</p>
<p>Раз элементы одинаковые и идут подряд, получить элемент массива по индексу несложно — достаточно знать адрес самого первого элемента («головы» массива).</p>
<p>Допустим, голова находится по адресу <code>0×00001234</code>, а каждый элемент занимает 8 байт. Тогда элемент с индексом <code>idx</code> находится по адресу <code>0×00001234 + idx*8</code>:</p>
<div class="row">
<div class="col-xs-12 col-sm-6">
<figure>
  <img alt="Список — массив" src="array-1.png" class="img-bordered-thin">
</figure>
</div>
</div>
<p>Поскольку операция «получить значение по адресу» выполняется за константное время, то и выборка из массива по индексу выполняется за O(1).</p>
<p>Грубо говоря, список в питоне именно так и устроен. Он хранит указатель на голову массива и количество элементов в массиве. Количество хранится отдельно, чтобы функция <code>len()</code> тоже отрабатывала за O(1), а не считала каждый раз фактическое количество элементов списка.</p>
<p>Все хорошо, но есть пара проблем:</p>
<ul>
<li>все элементы массива одного размера, а список умеет хранить разные (true/false, числа, строки разной длины);</li>
<li>массив имеет фиксированную длину, а в список можно добавить сколько угодно элементов.</li>
</ul>
<p>Чуть позже посмотрим, как их решить.</p>
<h2 id="ну-очень-примитивный-список">Ну очень примитивный список</h2>
<p>Лучший способ освоить структуру данных — реализовать ее с нуля. К сожалению, питон плохо подходит для таких низкоуровненых структур как массив, потому что не дает явно работать с указателями (адресами в памяти).</p>
<p>Но кое-что можно сделать:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="color:#a90d91">class</span> <span style="color:#3f6e75">OhMyList</span>:
    <span style="color:#a90d91">def</span> <span style="color:#000">__init__</span>(<span style="color:#5b269a">self</span>):
        <span style="color:#5b269a">self</span><span style="color:#000">.</span><span style="color:#000">length</span> <span style="color:#000">=</span> <span style="color:#1c01ce">0</span>
        <span style="color:#5b269a">self</span><span style="color:#000">.</span><span style="color:#000">capacity</span> <span style="color:#000">=</span> <span style="color:#1c01ce">8</span>
        <span style="color:#5b269a">self</span><span style="color:#000">.</span><span style="color:#000">array</span> <span style="color:#000">=</span> (<span style="color:#5b269a">self</span><span style="color:#000">.</span><span style="color:#000">capacity</span> <span style="color:#000">*</span> <span style="color:#000">ctypes</span><span style="color:#000">.</span><span style="color:#000">py_object</span>)()

    <span style="color:#a90d91">def</span> <span style="color:#000">append</span>(<span style="color:#5b269a">self</span>, <span style="color:#000">item</span>):
        <span style="color:#5b269a">self</span><span style="color:#000">.</span><span style="color:#000">array</span>[<span style="color:#5b269a">self</span><span style="color:#000">.</span><span style="color:#000">length</span>] <span style="color:#000">=</span> <span style="color:#000">item</span>
        <span style="color:#5b269a">self</span><span style="color:#000">.</span><span style="color:#000">length</span> <span style="color:#000">+=</span> <span style="color:#1c01ce">1</span>

    <span style="color:#a90d91">def</span> <span style="color:#000">__len__</span>(<span style="color:#5b269a">self</span>):
        <span style="color:#a90d91">return</span> <span style="color:#5b269a">self</span><span style="color:#000">.</span><span style="color:#000">length</span>

    <span style="color:#a90d91">def</span> <span style="color:#000">__getitem__</span>(<span style="color:#5b269a">self</span>, <span style="color:#000">idx</span>):
        <span style="color:#a90d91">return</span> <span style="color:#5b269a">self</span><span style="color:#000">.</span><span style="color:#000">array</span>[<span style="color:#000">idx</span>]
</code></pre></div><p>Наш самописный список имеет фиксированную вместимость (<code>capacity</code> = 8 элементов) и хранит элементы в массиве <code>array</code>.</p>
<p>Модуль <code>ctypes</code> дает доступ к сишным структурам, на которых построена стандартная библиотека. В даннам случае мы используем его, чтобы создать массив размером в <code>capacity</code> элементов.</p>
<h2 id="список--массив-указателей">Список = массив указателей</h2>
<p>Список моментально выбирает элемент по индексу, потому что внутри у него массив. А массив такой быстрый, потому что все элементы у него одинакового размера.</p>
<p>Но при этом в списке элементы могут быть очень разные:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="color:#000">guests</span> <span style="color:#000">=</span> [<span style="color:#c41a16">&#34;Френк&#34;</span>, <span style="color:#c41a16">&#34;Клер&#34;</span>, <span style="color:#c41a16">&#34;Зоя&#34;</span>, <span style="color:#a90d91">True</span>, <span style="color:#1c01ce">42</span>]
</code></pre></div><p>Чтобы решить эту задачку, придумали хранить в массиве не сами значения, а указатели на них. Элемент массива — адрес в памяти, а если обратиться по адресу — получишь настоящее значение:</p>
<div class="row">
<div class="col-xs-12 col-sm-10">
<figure>
  <img alt="Список — массив указателей" src="array-2.png" class="img-bordered-thin">
  <figcaption>Элементы массива расположены подряд, а сами значения, на которые они ссылаются, могут быть вперемешку где угодно в памяти.</figcaption>
</figure>
</div>
</div>
<p>Поскольку указатели фиксированного размера (8 байт на современных 64-битных процессорах), то все прекрасно работает. Да, получается, что вместо одной операции (получить значение из элемента массива) мы делаем две:</p>
<ol>
<li>Получить адрес из элемента массива.</li>
<li>Получить значение по адресу.</li>
</ol>
<p>Но это все еще константное время O(1).</p>
<h2 id="список--динамический-массив">Список = динамический массив</h2>
<p>Если в массиве под списком остались свободные места, то метод <code>.append(item)</code> выполнится за константное время — достаточно записать новое значение в свободную ячейку и увеличить счетчик элементов на 1:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="color:#a90d91">def</span> <span style="color:#000">append</span>(<span style="color:#5b269a">self</span>, <span style="color:#000">item</span>):
    <span style="color:#5b269a">self</span><span style="color:#000">.</span><span style="color:#000">array</span>[<span style="color:#5b269a">self</span><span style="color:#000">.</span><span style="color:#000">length</span>] <span style="color:#000">=</span> <span style="color:#000">item</span>
    <span style="color:#5b269a">self</span><span style="color:#000">.</span><span style="color:#000">length</span> <span style="color:#000">+=</span> <span style="color:#1c01ce">1</span>
</code></pre></div><p>Но что делать, если массив уже заполнен?</p>
<p>Приходится выделять память под новый массив, побольше, и копировать все элементы старого массива в новый:</p>
<div class="row">
<div class="col-xs-12 col-sm-6">
<figure>
  <img alt="Список — динамический массив" src="array-3.png" class="img-bordered-thin">
  <figcaption>Когда место в старом массиве заканчивается, приходится создавать новый.</figcaption>
</figure>
</div>
</div>
<p>Примерно так:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="color:#a90d91">def</span> <span style="color:#000">append</span>(<span style="color:#5b269a">self</span>, <span style="color:#000">item</span>):
    <span style="color:#a90d91">if</span> <span style="color:#5b269a">self</span><span style="color:#000">.</span><span style="color:#000">length</span> <span style="color:#000">==</span> <span style="color:#5b269a">self</span><span style="color:#000">.</span><span style="color:#000">capacity</span>:
        <span style="color:#5b269a">self</span><span style="color:#000">.</span><span style="color:#000">_resize</span>(<span style="color:#5b269a">self</span><span style="color:#000">.</span><span style="color:#000">capacity</span><span style="color:#000">*</span><span style="color:#1c01ce">2</span>)
    <span style="color:#5b269a">self</span><span style="color:#000">.</span><span style="color:#000">array</span>[<span style="color:#5b269a">self</span><span style="color:#000">.</span><span style="color:#000">length</span>] <span style="color:#000">=</span> <span style="color:#000">item</span>
    <span style="color:#5b269a">self</span><span style="color:#000">.</span><span style="color:#000">length</span> <span style="color:#000">+=</span> <span style="color:#1c01ce">1</span>

<span style="color:#a90d91">def</span> <span style="color:#000">_resize</span>(<span style="color:#5b269a">self</span>, <span style="color:#000">new_cap</span>):
    <span style="color:#000">new_arr</span> <span style="color:#000">=</span> (<span style="color:#000">new_cap</span> <span style="color:#000">*</span> <span style="color:#000">ctypes</span><span style="color:#000">.</span><span style="color:#000">py_object</span>)()
    <span style="color:#a90d91">for</span> <span style="color:#000">idx</span> <span style="color:#000">in</span> <span style="color:#a90d91">range</span>(<span style="color:#5b269a">self</span><span style="color:#000">.</span><span style="color:#000">length</span>):
        <span style="color:#000">new_arr</span>[<span style="color:#000">idx</span>] <span style="color:#000">=</span> <span style="color:#5b269a">self</span><span style="color:#000">.</span><span style="color:#000">array</span>[<span style="color:#000">idx</span>]
    <span style="color:#5b269a">self</span><span style="color:#000">.</span><span style="color:#000">array</span> <span style="color:#000">=</span> <span style="color:#000">new_arr</span>
    <span style="color:#5b269a">self</span><span style="color:#000">.</span><span style="color:#000">capacity</span> <span style="color:#000">=</span> <span style="color:#000">new_cap</span>
</code></pre></div><p><code>._resize()</code> — затратная операция, так что новый массив создают с запасом. В примере выше новый массив в два раза больше старого, а в питоне используют более скромный коэффициент — примерно 1.12.</p>
<p>Если удалить из списка больше половины элементов через <code>.pop()</code>, то питон его скукожит — выделит новый массив поменьше и перенесет элементы в него.</p>
<p>Таким образом, список все время жонглирует массивами, чтобы это не приходилось делать нам ツ</p>
<h2 id="добавление-элемента-в-конец-списка">Добавление элемента в конец списка</h2>
<p>Выборка из списка по индексу работает за O(1) — с этим разобрались. Метод <code>.append(item)</code> тоже отрабатывает за O(1), пока не приходится расширять массив под списком. Но любое расширение массива — это операция O(n). Так за сколько же в итоге отрабатывает <code>.append()</code>?</p>
<p>Оценивать отдельную операцию вставки было бы неправильно — как мы выяснили, она иногда выполняется за O(1), а иногда и за O(n). Поэтому используют амортизационный анализ — оценивают общее время, которое займет последовательность из K операций, затем делят его на K и получают амортизированное время одной операции.</p>
<p>Так вот. Не вдаваясь в подробности скажу, что амортизированное время для <code>.append(item)</code> получается константным — O(1). Так что вставка в конец списка работает очень быстро.</p>
<div class="boxed">
<h3>Почему амортизированное время — O(1)</h3>
<p>Допустим, список пуст и мы хотим добавить в него <code>n</code> элементов. Для простоты будем использовать фактор расширения 2. Посчитаем количество атомарных операций:</p>
<ul>
  <li>первый элемент: 1 (копирование) + 1 (вставка)</li>
  <li>ещё 2: 2 (копирование) + 2 (вставка)</li>
  <li>ещё 4: 4 (копирование) + 4 (вставка)</li>
  <li>ещё 8: 8 (копирование) + 8 (вставка)</li>
  <li>...</li>
</ul>
<p>Итого на <code>n</code> элементов будет <code>n</code> операций вставки.</p>
<p>А при копировании будет</p>
<pre><code>1 + 2 + 4 + ... log(n) = 
= 2**log(n) * 2 - 1 =
= 2n - 1</code></pre>
<p>операций.</p>
<p>Итого на <code>n</code> элементов получилось <code>3n - 1</code> атомарных операций.</p>
<p><code>O((3n - 1) / n)</code> = <code>O(1)</code></p>
</div>
<p>Получается, у списка есть такие гарантированно быстрые операции:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-py" data-lang="py"><span style="color:#177500"># O(1)</span>
<span style="color:#000">lst</span>[<span style="color:#000">idx</span>]

<span style="color:#177500"># O(1)</span>
<span style="color:#a90d91">len</span>(<span style="color:#000">lst</span>)

<span style="color:#177500"># амортизированное O(1)</span>
<span style="color:#000">lst</span><span style="color:#000">.</span><span style="color:#000">append</span>(<span style="color:#000">item</span>)
<span style="color:#000">lst</span><span style="color:#000">.</span><span style="color:#000">pop</span>()
</code></pre></div><h2 id="итоги">Итоги</h2>
<p>Как мы выяснили, у списка работают за O(1):</p>
<ul>
<li>выборка по индексу <code>lst[idx]</code></li>
<li>запрос длины <code>len(lst)</code></li>
<li>добавление элемента в конец списка <code>.append(item)</code></li>
<li>удаление элемента из конца списка <code>.pop()</code></li>
</ul>
<p>Остальные операции — «медленные»:</p>
<ul>
<li>Вставка и удаление из произвольной позиции — <code>.insert(idx, item)</code> и <code>.pop(idx)</code> — работают за линейное время O(n), потому что сдвигают все элементы после целевого.</li>
<li>Поиск и удаление элемента по значению — <code>item in lst</code>, <code>.index(item)</code> и <code>.remove(item)</code> — работают за линейное время O(n), потому что перебирают все элементы.</li>
<li>Выборка среза из <code>k</code> элементов — <code>lst[from:to]</code> — работает за O(k).</li>
</ul>
<p>Значит ли это, что «медленные» операции нельзя использовать? Конечно, нет. Если у вас список из 1000 элементов, разница между O(1) и O(n) для единичной операции незаметна.</p>
<p>С другой стороны, если вы миллион раз выполняете «медленную» операцию на списке из 1000 элементов — это уже заметно. Или если список из миллиона элементов — тоже.</p>
<p>Поэтому полезно знать, что у списка работает за константное время, а что за линейное — чтобы осознанно принимать решение в конкретной ситуации.</p>
<div class="row">
<div class="col-xs-12 col-sm-10 col-md-8"><p><em>Заметка из телеграм-канала <span class="nowrap"><i class="fas fa-kiwi-bird"></i> «<a href="https://t.me/ohmypy">Oh My Py</a>»</span></em></p></div>
</div>]]></content:encoded>
    </item>
    
    <item>
      <title>Табличные выражения SQL</title>
      <link>https://antonz.ru/cte/</link>
      <pubDate>Fri, 05 Nov 2021 11:14:51 +0000</pubDate>
      
      <guid>https://antonz.ru/cte/</guid>
      <description>Используйте их вместо подзапросов.</description>
      <content:encoded><![CDATA[<p>Прием № 1, чтобы писать хорошие читаемые SQL-запросы — это <em>табличные выражения</em> (CTE). Люди их боятся, а зря. Давайте разберемся за три минуты, читать увесистую книгу по SQL или проходить курсы не придется.</p>
<h2 id="проблема">Проблема</h2>
<p>Допустим, у нас есть таблица продаж по месяцам за два года:</p>
<pre tabindex="0"><code>┌──────┬───────┬───────┬──────────┬─────────┐
│ year │ month │ price │ quantity │ revenue │
├──────┼───────┼───────┼──────────┼─────────┤
│ 2019 │ 1     │ 60    │ 200      │ 12000   │
│ 2019 │ 2     │ 60    │ 660      │ 39600   │
│ 2019 │ 3     │ 60    │ 400      │ 24000   │
│ 2019 │ 4     │ 60    │ 300      │ 18000   │
│ 2019 │ 5     │ 60    │ 440      │ 26400   │
│ 2019 │ 6     │ 60    │ 540      │ 32400   │
│ 2019 │ 7     │ 60    │ 440      │ 26400   │
│ 2019 │ 8     │ 60    │ 440      │ 26400   │
│ 2019 │ 9     │ 60    │ 250      │ 15000   │
│ 2019 │ 10    │ 60    │ 420      │ 25200   │
│ ...  │ ...   │ ...   │ ...      │ ...     │
└──────┴───────┴───────┴──────────┴─────────┘
</code></pre><p><a href="https://sqlime.org/#gist:858c409b81ae3a676580cba6745d68ea">песочница</a></p>
<p>Мы хотим выбрать только те месяцы, выручка за которые превысила среднемесячную за год.</p>
<p>Для начала посчитаем среднемесячную выручку по годам:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#a90d91">select</span>
  <span style="color:#a90d91">year</span>,
  <span style="color:#a90d91">avg</span>(<span style="color:#000">revenue</span>) <span style="color:#a90d91">as</span> <span style="color:#000">avg_rev</span>
<span style="color:#a90d91">from</span> <span style="color:#000">sales</span>
<span style="color:#a90d91">group</span> <span style="color:#a90d91">by</span> <span style="color:#a90d91">year</span>;
</code></pre></div><pre tabindex="0"><code>┌──────┬─────────┐
│ year │ avg_rev │
├──────┼─────────┤
│ 2019 │ 25125.0 │
│ 2020 │ 48625.0 │
└──────┴─────────┘
</code></pre><p>Теперь можно выбрать только те записи, <code>revenue</code> в которых не уступает <code>avg_rev</code>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#a90d91">select</span>
  <span style="color:#000">sales</span>.<span style="color:#a90d91">year</span>,
  <span style="color:#000">sales</span>.<span style="color:#a90d91">month</span>,
  <span style="color:#000">sales</span>.<span style="color:#000">revenue</span>,
  <span style="color:#000">round</span>(<span style="color:#000">totals</span>.<span style="color:#000">avg_rev</span>) <span style="color:#a90d91">as</span> <span style="color:#000">avg_rev</span>
<span style="color:#a90d91">from</span> <span style="color:#000">sales</span>
  <span style="color:#a90d91">join</span> (
    <span style="color:#a90d91">select</span>
      <span style="color:#a90d91">year</span>,
      <span style="color:#a90d91">avg</span>(<span style="color:#000">revenue</span>) <span style="color:#a90d91">as</span> <span style="color:#000">avg_rev</span>
    <span style="color:#a90d91">from</span> <span style="color:#000">sales</span>
    <span style="color:#a90d91">group</span> <span style="color:#a90d91">by</span> <span style="color:#a90d91">year</span>
  ) <span style="color:#a90d91">as</span> <span style="color:#000">totals</span>
  <span style="color:#a90d91">on</span> <span style="color:#000">sales</span>.<span style="color:#a90d91">year</span> <span style="color:#000">=</span> <span style="color:#000">totals</span>.<span style="color:#a90d91">year</span>
<span style="color:#a90d91">where</span> <span style="color:#000">sales</span>.<span style="color:#000">revenue</span> <span style="color:#000">&gt;=</span> <span style="color:#000">totals</span>.<span style="color:#000">avg_rev</span>;
</code></pre></div><pre tabindex="0"><code>┌──────┬───────┬─────────┬─────────┐
│ year │ month │ revenue │ avg_rev │
├──────┼───────┼─────────┼─────────┤
│ 2019 │ 2     │ 39600   │ 25125.0 │
│ 2019 │ 5     │ 26400   │ 25125.0 │
│ 2019 │ 6     │ 32400   │ 25125.0 │
│ 2019 │ 7     │ 26400   │ 25125.0 │
│ ...  │ ...   │ ...     │ ...     │
└──────┴───────┴─────────┴─────────┘
</code></pre><p>Решили с помощью подзапроса:</p>
<ul>
<li>внутренний запрос считает среднемесячную выручку;</li>
<li>внешний соединяется с ним и фильтрует результаты.</li>
</ul>
<p>Запрос в целом получился сложноват. Если вернетесь к нему спустя месяц — наверняка потратите какое-то время на «распутывание». Проблема в том, что такие вложенные запросы приходится читать наоборот:</p>
<ul>
<li>найти самый внутренний запрос, осознать;</li>
<li>мысленно присоединить к более внешнему;</li>
<li>присоединить к следующему внешнему, и так далее.</li>
</ul>
<p>Хорошо, когда вложенных уровня два, как в нашем примере. На практике же я часто встречаю трех- и четырехуровневые подзапросы. Форменное издевательство над читателем.</p>
<h2 id="решение">Решение</h2>
<p>Вместо подзапроса можно использовать <em>табличное выражение</em> (common table expression, CTE). Любой подзапрос <code>X</code>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#a90d91">select</span> <span style="color:#000">a</span>, <span style="color:#000">b</span>, <span style="color:#a90d91">c</span>
<span style="color:#a90d91">from</span> (<span style="color:#000">X</span>)
<span style="color:#a90d91">where</span> <span style="color:#000">e</span> <span style="color:#000">=</span> <span style="color:#000">f</span>
</code></pre></div><p>Механически превращается в CTE:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#a90d91">with</span> <span style="color:#000">cte</span> <span style="color:#a90d91">as</span> (<span style="color:#000">X</span>)
<span style="color:#a90d91">select</span> <span style="color:#000">a</span>, <span style="color:#000">b</span>, <span style="color:#a90d91">c</span>
<span style="color:#a90d91">from</span> <span style="color:#000">cte</span>
<span style="color:#a90d91">where</span> <span style="color:#000">e</span> <span style="color:#000">=</span> <span style="color:#000">f</span>
</code></pre></div><p>В нашем примере:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#a90d91">with</span> <span style="color:#000">totals</span> <span style="color:#a90d91">as</span> (
  <span style="color:#a90d91">select</span>
    <span style="color:#a90d91">year</span>,
    <span style="color:#a90d91">avg</span>(<span style="color:#000">revenue</span>) <span style="color:#a90d91">as</span> <span style="color:#000">avg_rev</span>
  <span style="color:#a90d91">from</span> <span style="color:#000">sales</span>
  <span style="color:#a90d91">group</span> <span style="color:#a90d91">by</span> <span style="color:#a90d91">year</span>
)

<span style="color:#a90d91">select</span>
  <span style="color:#000">sales</span>.<span style="color:#a90d91">year</span>,
  <span style="color:#000">sales</span>.<span style="color:#a90d91">month</span>,
  <span style="color:#000">sales</span>.<span style="color:#000">revenue</span>,
  <span style="color:#000">round</span>(<span style="color:#000">totals</span>.<span style="color:#000">avg_rev</span>) <span style="color:#a90d91">as</span> <span style="color:#000">avg_rev</span>
<span style="color:#a90d91">from</span> <span style="color:#000">sales</span> 
  <span style="color:#a90d91">join</span> <span style="color:#000">totals</span> <span style="color:#a90d91">on</span> <span style="color:#000">totals</span>.<span style="color:#a90d91">year</span> <span style="color:#000">=</span> <span style="color:#000">sales</span>.<span style="color:#a90d91">year</span>
<span style="color:#a90d91">where</span> <span style="color:#000">sales</span>.<span style="color:#000">revenue</span> <span style="color:#000">&gt;=</span> <span style="color:#000">totals</span>.<span style="color:#000">avg_rev</span>;
</code></pre></div><p>С табличным выражением запрос становится одноуровневым — так воспринимать его намного проще. Кроме того, табличное выражение можно переиспользовать в пределах запроса, как будто это обычная таблица:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#a90d91">with</span> <span style="color:#000">totals</span> <span style="color:#a90d91">as</span> (...)
<span style="color:#a90d91">select</span> ... <span style="color:#a90d91">from</span> <span style="color:#000">sales_ru</span> <span style="color:#a90d91">join</span> <span style="color:#000">totals</span> ...
<span style="color:#a90d91">union</span> <span style="color:#a90d91">all</span>
<span style="color:#a90d91">select</span> ... <span style="color:#a90d91">from</span> <span style="color:#000">sales_us</span> <span style="color:#a90d91">join</span> <span style="color:#000">totals</span> ...
</code></pre></div><p>Табличные выражения SQL чем-то похожи на функции в обычном языке программирования — они уменьшают общую сложность:</p>
<ul>
<li>Можно написать нечитаемую простыню кода, а можно разбить код на понятные отдельные функции и составить программу из них.</li>
<li>Можно возвести башню из пяти этажей подзапросов, а можно вынести подзапросы в CTE и составить общий запрос из них.</li>
</ul>
<h2 id="cte-против-подзапроса">CTE против подзапроса</h2>
<p>Существует миф, что «CTE медленные». Он пришел из старых версий PostgreSQL (11 и раньше), которые всегда <em>материализовали</em> CTE — вычисляли полный результат табличного выражения и запоминали до конца запроса.</p>
<p>Обычно это хорошо: один раз вычислил результат, и дальше используешь его несколько раз по ходу основного запроса. Но иногда материализация мешала движку оптимизировать запрос:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#a90d91">with</span> <span style="color:#000">cte</span> <span style="color:#a90d91">as</span> (<span style="color:#a90d91">select</span> <span style="color:#000">*</span> <span style="color:#a90d91">from</span> <span style="color:#000">foo</span>)
<span style="color:#a90d91">select</span> <span style="color:#000">*</span> <span style="color:#a90d91">from</span> <span style="color:#000">cte</span> <span style="color:#a90d91">where</span> <span style="color:#000">id</span> <span style="color:#000">=</span> <span style="color:#1c01ce">500000</span>;
</code></pre></div><p>Здесь выбирается ровно одна запись по идентификатору, но материализация создает в памяти копию <em>всей таблицы</em> — из-за этого запрос отработает очень медленно.</p>
<p>PostgreSQL 12+ и другие современные СУБД поумнели и больше так не делают. Материализация применяется, когда от нее больше пользы, чем вреда. Плюс, многие СУБД позволяют явно управлять этим поведением через инструкции <code>MATERIALIZED</code> / <code>NOT MATERIALIZED</code>.</p>
<p>Так что CTE не медленнее подзапросов. А если сомневаетесь, всегда можно сделать два варианта — подзапрос и табличное выражение — и сравнить план и время выполнения.</p>
<p>Как понять, когда использовать подзапрос, а когда CTE? Я вывел для себя простое правило, которое пока ни разу не подвело:</p>
<blockquote class="big">
<p>Всегда использовать CTE</p>
</blockquote>
<p>Чего и вам желаю.</p>
<div class="row">
<div class="col-xs-12 col-sm-10 col-md-8"><p><em>И подписывайтесь на канал <span class="nowrap"><i class="fas fa-database"></i> «<a href="https://t.me/sqliter">SQLite на практике</a>»</span></em></p></div>
</div>
]]></content:encoded>
    </item>
    
    <item>
      <title>Справочник адресов России</title>
      <link>https://antonz.ru/fias/</link>
      <pubDate>Sun, 24 Oct 2021 17:02:08 +0000</pubDate>
      
      <guid>https://antonz.ru/fias/</guid>
      <description>Который ведет налоговая.</description>
      <content:encoded><![CDATA[<p>Не все знают, что в России есть Великий Справочник Адресов, в который свято веруют все чиновники (да и не только они). Расскажу о нём немного. Без официальной нуднятины, только задорные факты из жизни.</p>
<p>Справочник адресов называется «ФИАС» (федеральная информационная адресная система) или «ГАР» (государственный адресный реестр) — это одно и то же. Раньше назывался «КЛАДР» (классификатор адресов). Технически поддерживает его налоговая, а данные о домах и улицах вносят местные чиновники по всей стране. У справочника даже есть сайт (не читайте его): <a href="https://fias.nalog.ru">fias.nalog.ru</a></p>
<p>Вот как видит нашу родину налоговая служба:</p>
<ul>
<li>86 регионов</li>
<li>3 тыс. городов</li>
<li>300 тыс. населённых пунктов</li>
<li>1 млн улиц</li>
<li>31 млн домов</li>
<li>52 млн квартир</li>
</ul>
<p>У каждого адреса есть тип и название. Скажем, тип = «город», название = «Самара». Или тип = «республика», название = «Бурятия». Но если вам повезло жить в республике Чувашия, то тип = «Чувашия», название = «Чувашская республика». Потому что пошёл ты нахер, вот почему.</p>
<p>ФИАС — истина в последней инстанции для всех гос. органов. Если вы живёте в Кабардино-Балкарии на Моздокской улице, а у налоговой она значится как «МосдоГская» (в честь знаменитых кабардино-балкарских догов, видимо), то ни одному чиновнику вы свою правоту не докажете.</p>
<figure>
  <img alt="Странные дома" src="fias-house-zero.png">
  <figcaption>Дурная фантазия чиновников безгранична</figcaption>
</figure>
<p>Или ещё был случай. В 2018 году питерским чиновникам стало скучно, и они домам приделали «литеру А». Был «Невский проспект, дом 41», а стал «дом 41 литер А». И так со всеми домами в городе. На табличках нормально написано, а в голове у чиновников — с литерами. Deal with it.</p>
<p>Справочник полон милых идиотизмов. Однажды перестали помещаться гаражи и садовые товарищества, и налоговая додумалась добавить новый «уровень» адреса для них. Загадочно назвали его «планировочная структура». Но забыли рассказать местным чиновникам, что это такое и зачем. Поэтому теперь в «планировочных структурах» лежит всё от жилых кварталов до районов городов и международных трасс. Бадум-тсс!</p>
<p>Ах да. Если вы думаете, что живёте в городе, то разочарую. На самом деле это не «город», а «городской округ». Это называется «муниципальное деление»: городские округа вместо городов, сельские поселения вместо сёл, и так далее. Ну, чтобы никто не догадался.</p>
<p>Налоговая любит внезапно менять справочник. То все дома в городе потеряет, то битых улиц насыпет, то просто два месяца не обновляет. Объяснений и анонсов, конечно же, никто не делает. Сами разберётесь, не маленькие.</p>
<p>Но. Хоть я и ворчу, ФИАС — большое благо! Это структурированный, регулярно обновляемый справочник адресов, доступный всем желающим. У большинства стран такого нет, так что пусть завидуют 👌</p>
<p><em>Подписывайтесь на <a href="https://twitter.com/nalgeon">@nalgeon</a> в твитере, чтобы не пропустить новые заметки</em></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Вы являетесь дизайнеру в страшном сне</title>
      <link>https://antonz.ru/tinkoff-signin/</link>
      <pubDate>Thu, 07 Oct 2021 13:49:33 +0000</pubDate>
      
      <guid>https://antonz.ru/tinkoff-signin/</guid>
      <description>Помогаем Тинькову избавиться от косноязычия на форме входа.</description>
      <content:encoded><![CDATA[<p>Интернет-банк Тинькова при входе встречает многозначительной надписью:</p>
<figure>
  <img alt="Вы являетесь держателем" src="tinkoff-signin-1.png">
</figure>
<blockquote class="big">
Вы являетесь держателем продуктов Тинькофф Банка. При входе по номеру телефона, в целях безопасности, введите пароль.
</blockquote>
<p>Я, конечно, не UX-писатель, но это жуть какая кривая формулировка. Давайте попробуем улучшить.</p>
<h2 id="1-формулируем-по-человечески">1. Формулируем по-человечески</h2>
<p>Меняем суконный язык банковских безопасников на нормальную речь.</p>
<blockquote class="big">
Вы являетесь держателем продуктов Тинькофф Банка. При входе по номеру телефона, в целях безопасности, введите пароль.<br>↓
</blockquote>
<blockquote class="big">
Вы — клиент Тинькофф Банка. Введите пароль, чтобы войти.
</blockquote>
<h2 id="2-убираем-лишнее">2. Убираем лишнее</h2>
<p>Зачем писать человеку, что он клиент? Я и так это знаю, потому и пытаюсь войти в интернет-банк. Убираем.</p>
<blockquote class="big">
Вы — клиент Тинькофф Банка. Введите пароль, чтобы войти.<br>↓
</blockquote>
<blockquote class="big">Введите пароль, чтобы войти.</blockquote>
<h2 id="3-убираем-очевидное">3. Убираем очевидное</h2>
<p>На этой же форме огроменное поле ПАРОЛЬ и кнопка ВОЙТИ. Спорим, человек догадается, чего от него хотят?</p>
<blockquote class="big">Введите пароль, чтобы войти.<br>↓</blockquote>
<blockquote class="big">Ø</blockquote>
<p>Что осталось:</p>
<figure>
  <img alt="Больше не являетесь" src="tinkoff-signin-2.png">
</figure>
<h2 id="qa">Q&amp;A</h2>
<blockquote>
<p>А это не юридический затык? У Тинькофа вроде всё хорошо с ux-райтингом во всех других местах.</p>
</blockquote>
<p>У Тинькова есть некоторое количество сотрудников, которые умеют писать нормальный текст, и огромная армия тех, кто делать этого не умеет и не желает. Вторые иногда прорываются. Хотя первые в целом отлично справляются, да.</p>
<blockquote>
<p>Мне кажется, предполагать, что человек сразу поймет, куда он входит, слишком смело.</p>
</blockquote>
<p>Действительно, он зашел на сайт Тинькова, нажал на «Войти», указал номер телефона. Конечно, он понятия не имеет, что делает.</p>
<blockquote>
<p>А может это было сделано по требованиям accessibility? Чтобы читалка озвучила, например.</p>
</blockquote>
<p>Это делается иначе.</p>
<blockquote>
<p>Не уверен, что насчет этого можно сразу рассуждать предположениями. Как реально юзеры реагируют на такую форму можно понять только через исследования.</p>
</blockquote>
<p>Не надо проводить исследования, чтобы исправить очевидные проблемы. Исследования не заменяют головной мозг, пользуйтесь им.</p>
<div class="row">
<div class="col-xs-12 col-sm-10 col-md-8"><p><em>Заметка из телеграм-канала <span class="nowrap"><i class="far fa-star color-sin"></i> «<a href="https://t.me/dangry">Интерфейсы без шелухи</a>»</span></em></p></div>
</div>
]]></content:encoded>
    </item>
    
    <item>
      <title>SQLite-песочница в браузере</title>
      <link>https://antonz.ru/sqlime/</link>
      <pubDate>Tue, 28 Sep 2021 21:13:03 +0000</pubDate>
      
      <guid>https://antonz.ru/sqlime/</guid>
      <description>Для отладки и шаринга запросов.</description>
      <content:encoded><![CDATA[<p>Чего мне всегда не хватало, так это аналога JSFiddle для SQLite. Онлайн-песочницы, в которой можно быстро проверить SQL-запрос и поделиться с другими.</p>
<p><a href="https://sqlime.org/"><img src="sqlime.png" alt="SQLime"></a></p>
<p>Вот чего хотелось:</p>
<ul>
<li>Возможность загрузить готовую базу, а не писать SQL для создания таблиц.</li>
<li>Подключать как локальные базы, так и удаленные (по url).</li>
<li>Сохранять базу и запросы в облаке.</li>
<li>Бесплатно и без регистрации.</li>
<li>Свежайшая версия SQLite.</li>
<li>Минимализм.</li>
</ul>
<p>В итоге сделал такую песочницу сам:</p>
<ul>
<li><a href="https://sqlime.org/">демка</a> с пустой базой;</li>
<li><a href="https://sqlime.org/#gist:e012594111ce51f91590c4737e41a046">пример</a> заполненной базы;</li>
<li><a href="https://github.com/nalgeon/sqlime">исходники</a>.</li>
</ul>
<p><a href="https://habr.com/ru/post/580240/">подробности на Хабре</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Как хранят данные в браузере</title>
      <link>https://antonz.ru/browser-storage/</link>
      <pubDate>Sun, 26 Sep 2021 09:36:07 +0000</pubDate>
      
      <guid>https://antonz.ru/browser-storage/</guid>
      <description>От мохнатой древности до нашего времени.</description>
      <content:encoded><![CDATA[<p>Поговорим о том, как люди хранили данные в браузере, от мохнатой древности до нашего времени.</p>
<h2 id="1-куки">1. Куки</h2>
<p>Первые инженеры, едва переодевшись из шкур в неопрятные свитера, попытались использовать родной и привычный HTTP-протокол. Проблема в том, что он не хранит состояние (stateless) — пять запросов от Алисы выглядят точно так же, как пять запросов от пяти разных людей.</p>
<p>Что же делать? В любой непонятной ситуации придумывай костыль! Так появились <em>куки</em> (cookie). Это пары строк (ключ — значение), которые браузер гоняет на сервер с каждым запросом. Таким образом stateless протокол внезапно становится немножко stateful.</p>
<figure>
  <img alt="Куки" class="img-bordered-thin" src="storage-cookies.png">
</figure>
<p>Куки хороши тем, что доступны и на клиенте, и на сервере. Когда вы ходите по страницам интернет-магазина и складываете товары в корзину, браузер с каждым запросом передает в куках идентификатор сессии. По нему сервер магазина понимает, что товары относятся именно к вашей корзине.</p>
<p>Куку может установить не только тот сайт, на котором вы находитесь, но и вообще любой (так называемые third-party cookies). Этим немедленно воспользовались хитрозадые рекламодатели. Если на сайте магазина подключен фейсбук, а вы купили ботинки — теперь до конца жизни будете видеть рекламу ботинок на всех сайтах, подключенных к фейсбуку.</p>
<p>Third-party cookies можно отключить в настройках браузера, а в Сафари они даже отключены по умолчанию. Рекомендую это сделать. Правда, некоторые особенно кривые сайты при этом перестанут работать — но оно и к лучшему, как по мне.</p>
<p>Работа с куками в JS реализована традиционно для веба — максимально неудобно. <code>document.cookie</code> — это все куки, склеенные в одну строку через точку с запятой. Наслаждайтесь парсингом.</p>
<p>Вообще, о куках можно еще много плохого рассказать. Делать этого я, конечно, не буду.</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies">Куки на MDN</a></p>
<h2 id="2-web-storage">2. Web Storage</h2>
<p>Постепенно разработчики поняли, что надо оставить HTTP в покое и сделать нормальное API хранения данных в браузере. Так появились <em>localStorage</em> и <em>sessionStorage</em> с очень простым интерфейсом:</p>
<ul>
<li>получить значение по ключу,</li>
<li>записать значение по ключу,</li>
<li>удалить значение по ключу.</li>
</ul>
<p>localStorage хранит данные вечно, а sessionStorage — только пока открыта вкладка браузера. local свой у каждого домена, чужие данные посмотреть не получится. А session отдельный у каждой вкладки. Максимальный размер базы — несколько мегабайт.</p>
<figure>
  <img alt="Web Storage" class="img-bordered-thin" src="storage-webstorage.png">
</figure>
<p>И ключи, и значения — только строки, так что числа, массивы и объекты приходится превращать в строку перед сохранением. И парсить из строки при выборке. Обычно не заморачиваются и используют <code>JSON.stringify</code> / <code>JSON.parse</code>.</p>
<p>sessionStorage редко используют, а вот localStorage весьма популярен. Простой, удобный, быстрый — что еще надо:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#a90d91">let</span> <span style="color:#000">obj</span> <span style="color:#000">=</span> { <span style="color:#000">a</span><span style="color:#000">:</span> <span style="color:#1c01ce">42</span> };
<span style="color:#a90d91">let</span> <span style="color:#000">objStr</span> <span style="color:#000">=</span> <span style="color:#000">JSON</span>.<span style="color:#000">stringify</span>(<span style="color:#000">obj</span>);
<span style="color:#000">localStorage</span>.<span style="color:#000">setItem</span>(<span style="color:#c41a16">&#34;q&#34;</span>, <span style="color:#000">objStr</span>);

<span style="color:#a90d91">let</span> <span style="color:#000">objStr</span> <span style="color:#000">=</span> <span style="color:#000">localStorage</span>.<span style="color:#000">getItem</span>(<span style="color:#c41a16">&#34;q&#34;</span>);
<span style="color:#000">JSON</span>.<span style="color:#000">parse</span>(<span style="color:#000">objStr</span>);
<span style="color:#177500">// {a: 42}
</span></code></pre></div><p>Ребята из команды Chrome рекомендуют вместо Web Storage использовать более новый механизм — IndexedDB. Это, мягко говоря, странный совет — но о своеобразном подходе разработчиков браузеров мы еще поговорим.</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API">Web Storage на MDN</a></p>
<h2 id="3-web-sql">3. Web SQL</h2>
<p>Постепенно разработчики дозрели до полноценной базы данных в браузере. Надо сказать, что абсолютно во всех браузерах — что мобильных, что десктопных — уже встроена отличная СУБД, которая реализует стандарт SQL-92 (и большой кусок более поздних стандартов) — <a href="https://sqlite.org/">SQLite</a>.</p>
<figure>
  <img alt="Web SQL" class="img-bordered-thin" src="storage-websql.png">
</figure>
<p>Казалось бы, придумай удобный интерфейс поверх SQLite, согласуй со всеми и вперед — что может быть логичнее? Собственно, в конце нулевых так и сделали — новый стандарт <em>Web SQL</em> поддержали Apple (Safari), Google (Chrome) и Opera (еще популярная тогда). А Mozilla (Firefox) — нет.</p>
<p>Замечательные люди из Мозиллы заявили, что:</p>
<ol>
<li>Использовать SQL в вебе некрасиво, у веба свой путь.</li>
<li>Где это видано, всем использовать SQLite, вместо того, чтобы каждый браузер напилил свой велосипед.</li>
</ol>
<p>Классные аргументы, да? Очень характерно для веба.</p>
<p>В результате Web SQL убили, использовать его сейчас нельзя. А элегантное решение, которое гении из Мозиллы породили ему на замену (IndexedDB), я вам скоро покажу.</p>
<div class="boxed">
<p><strong>🤔 SQL в браузере</strong></p>
<p>Если интересно, как может работать настоящий SQL в браузере — попробуйте онлайн-песочницу <strong><a href="https://sqlime.org/">sqlime</a></strong>. Там можно подключить любую SQLite-базу или создать новую с нуля и делать к ней запросы прямо из браузера.</p>
</div>
<p><a href="https://docs.tizen.org/application/web/guides/w3c/storage/websql/">Документация по Web SQL</a> (для полноты картины)</p>
<h2 id="4-indexed-database">4. Indexed Database</h2>
<p>Ну уж тут-то разработчики браузеров развернулись. <em>IndexedDB</em> — это настоящая NoSQL-база данных у вас в браузере. Можно сделать полноценное приложение, которое шустро ворочает сотнями мегабайт данных, не обращаясь к серверу. Прямо на вашем айфоне, мухаха.</p>
<p>Начнем с хорошего в IndexedDB:</p>
<ul>
<li>есть коллекции (аналог таблиц в реляционных БД), индексы и транзакции;</li>
<li>без проблем хранит массивы и объекты;</li>
<li>поддерживает версионирование схемы данных;</li>
<li>(условно) неограниченный размер базы;</li>
<li>работает асинхронно.</li>
</ul>
<figure>
  <img alt="Indexed Database" class="img-bordered-thin" src="storage-indexeddb.png">
</figure>
<p>А теперь о плохом:</p>
<blockquote class="big"><p>всё очень сложно</p></blockquote>
<p>Никаких вам get / set, будьте любезны освоить многочисленные концепции, приемы и особенности работы, чтобы записать свой несчастный объект в базу и получить его обратно. Уверен, вы просто мечтали освоить еще одну СУБД. Ваши мечты сбылись.</p>
<figure>
  <img alt="Код для IndexedDB" class="img-bordered-thin" src="storage-indexeddb-tutotial.png">
  <figcaption>Картинка из туториала по IndexedDB, для вдохновения. Пришлось уменьшить масштаб, а то на экран не влезала.</figcaption>
</figure>
<p>Ах, и еще. В вебе есть стандарт асинхронной работы — механизм промисов (promise) и async / await. Так вот, IndexedDB его не поддерживает. Потому что fuck you, that&rsquo;s why. Используйте костылики (<a href="https://github.com/jakearchibald/idb">idb</a>) — это ведь так элегантно.</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API">IndexedDB на MDN</a></p>
<h2 id="5-cache-api">5. Cache API</h2>
<p>Допустим, у вас веб-приложение для заметок. Было бы здорово, чтобы оно работало даже когда нет сети, верно?</p>
<p>Сами заметки можно хранить в localStorage или IndexedDB. Но что делать, если человек обновит страницу, а сети нет? Тут и пригодится <em>Cache API</em>.</p>
<p>Cache API создан, чтобы хранить не данные приложения, а сетевые запросы и ответы. Обычно это файлы приложения — все ваши <code>*.html</code>, <code>*.css</code> и <code>*.js</code></p>
<p>Если сохранить файлы в кеш, то в офлайн-режиме можно перехватить запросы и вернуть их из кеша, когда человек обновит страницу. За перехват отвечает другой механизм — service worker, о нем не будем.</p>
<p>Cache API простой и асинхронный, одно удовольствие:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#a90d91">const</span> <span style="color:#000">cache</span> <span style="color:#000">=</span> <span style="color:#a90d91">await</span> <span style="color:#000">caches</span>.<span style="color:#000">open</span>(<span style="color:#c41a16">&#34;app&#34;</span>);
<span style="color:#a90d91">await</span> <span style="color:#000">cache</span>.<span style="color:#000">add</span>(<span style="color:#c41a16">&#34;/app.js&#34;</span>);
<span style="color:#a90d91">const</span> <span style="color:#000">resp</span> <span style="color:#000">=</span> <span style="color:#a90d91">await</span> <span style="color:#000">cache</span>.<span style="color:#000">match</span>(<span style="color:#c41a16">&#34;/app.js&#34;</span>);
</code></pre></div><p><code>.add()</code> сам запросит указанный файл и сложит ответ в кеш, такой заботливый.</p>
<p>Возможно, вы ожидаете, что Cache API умеет очищать старые или редко используемые записи (на то он и кеш). Но нет! Это веб, так что решите вопрос как-нибудь самостоятельно.</p>
<p>На самом деле, никто не мешает использовать кеш и для данных приложения. Но так обычно не делают:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#a90d91">const</span> <span style="color:#000">data</span> <span style="color:#000">=</span> { <span style="color:#000">a</span><span style="color:#000">:</span> <span style="color:#1c01ce">42</span> };
<span style="color:#a90d91">let</span> <span style="color:#000">resp</span> <span style="color:#000">=</span> <span style="color:#a90d91">new</span> <span style="color:#000">Response</span>(<span style="color:#000">JSON</span>.<span style="color:#000">stringify</span>(<span style="color:#000">data</span>));
<span style="color:#a90d91">await</span> <span style="color:#000">cache</span>.<span style="color:#000">put</span>(<span style="color:#c41a16">&#34;data.json&#34;</span>, <span style="color:#000">resp</span>);

<span style="color:#000">resp</span> <span style="color:#000">=</span> <span style="color:#a90d91">await</span> <span style="color:#000">cache</span>.<span style="color:#000">match</span>(<span style="color:#c41a16">&#34;data.json&#34;</span>);
<span style="color:#a90d91">await</span> <span style="color:#000">resp</span>.<span style="color:#000">json</span>();
<span style="color:#177500">// { a: 42 }
</span></code></pre></div><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Cache">Cache API на MDN</a></p>
<h2 id="6-storage-api">6. Storage API</h2>
<p><em>Storage API</em> на самом деле ничего не хранит (обожаю веб). Вместо этого оно сообщает, сколько места занято вашим барахлом и сколько всего доступно.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#a90d91">const</span> {<span style="color:#000">usage</span>, <span style="color:#000">quota</span>} <span style="color:#000">=</span> <span style="color:#a90d91">await</span> <span style="color:#000">navigator</span>.<span style="color:#000">storage</span>.<span style="color:#000">estimate</span>();
</code></pre></div><p><code>usage</code> и <code>quota</code> считаются суммарно по всем видам хранилищ — Web Storage, IndexedDB и CacheAPI.</p>
<p>А ещё можно сообщить браузеру, что ваши данные ну очень ценные, и молча удалять их никак нельзя, только с разрешения человека:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#000">navigator</span>.<span style="color:#000">storage</span>.<span style="color:#000">persist</span>()
</code></pre></div><p>Storage API пока не работает в Safari. Увы.</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Storage_API">Storage API на MDN</a></p>
<h2 id="7-file-whatever-api">7. File (whatever) API</h2>
<p>Пара замечательных API с интуитивно понятными названиями: <em>File System Access API</em> и <em>File and Directory Entries API</em>.</p>
<p>Когда-нибудь они позволят вам писать файлы прямо на устройство пользователя. Но пока совсем сырые, так что не будем на них останавливаться.</p>
<h2 id="очень-краткие-выводы">Очень краткие выводы</h2>
<ul>
<li>Web Storage для мелочевки</li>
<li>IndexedDB для серьезных данных</li>
<li>Cache API для файлов и запросов</li>
</ul>
<p>Куки оставьте Цукербергу, Web SQL погиб молодым, File * API ещё не родились, а Storage API считает место.</p>
<p><em>И подписывайтесь на <a href="https://twitter.com/nalgeon">@nalgeon</a> в твитере, чтобы не пропустить новые заметки</em> 🚀</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Признать проблему</title>
      <link>https://antonz.ru/acknowledge/</link>
      <pubDate>Thu, 09 Sep 2021 10:32:08 +0000</pubDate>
      
      <guid>https://antonz.ru/acknowledge/</guid>
      <description>Продукты работают хуже, потому что команда не признает проблемы.</description>
      <content:encoded><![CDATA[<p>Иногда продукты работают хуже, чем могли бы, потому что команда отказывается признавать проблемы. Давайте посмотрим, как это бывает.</p>
<h2 id="письма-озаказе">Письма о заказе</h2>
<p>Представьте ситуацию. Вы работаете в крупном маркетплейсе. Люди делают на маркетплейсе заказы, он доставляет. А по факту доставки <em>одного</em> заказа присылает <em>шесть</em> писем:</p>
<div class="row">
<div class="col-xs-12 col-sm-4">
<figure>
  <img alt="Письма о заказее" src="acknowledge-ozon.png" class="img-bordered-thin">
</figure>
</div>
<div class="col-xs-12 col-sm-8">
<ul>
  <li>Заказ доставлен</li>
  <li>Электронный чек по 1-й части заказа</li>
  <li>Электронный чек по 2-й части заказа</li>
  <li>Электронный чек по 3-й части заказа</li>
  <li>Электронный чек по 4-й части заказа</li>
  <li>Вы довольны доставкой?</li>
</ul>
</div>
</div>
<p>При этом маркетплейс сам разбивает заказ на части, покупатель никак этим не управляет. В примере выше все части доставлены в один день, в одно время, одним курьером.</p>
<p>Некоторые покупатели почему-то недовольны таким количеством писем и жалуются в саппорт.</p>
<p>Ваши коллеги разводят руками — в заказе было 4 части, значит должно быть четыре чека. Потом, надо же уведомить о доставке, а то вдруг человек не в курсе. И уточнить, всем ли покупатель доволен (мы же клиентоориентированная компания). Вот и получается шесть писем. Ничего не поделаешь.</p>
<h2 id="решение">Решение</h2>
<p>Я предложил эту задачку подписчикам «<a href="https://t.me/dangry">Интерфейсов без шелухи</a>». Вот что они ответили:</p>
<div class="row">
<div class="col-xs-12 col-sm-6">
<figure>
  <img alt="ОПИСАНИЕ" src="acknowledge-solutions.png" class="img-bordered-thin">
  <figcaption>Нерешаемая инженерная проблема</figcaption>
</figure>
</div>
</div>
<p>Конечно, нормальное решение — присылать по факту доставки <em>одно</em> письмо, включив в него и чеки, и опрос, и все что еще важно. Никаким законам это не противоречит и технически реализуемо.</p>
<p>Маркетплейс не присылает четырех разных курьеров, чтобы доставить несчастный заказ — он понимает, что заказ один, и отправляет одного курьера. Аналогично можно объединить четыре письма с чеками в одно, а попотев еще немного — и оставшиеся два письма тоже свести в одно общее.</p>
<p>Но я хочу обратить внимание вот на что.</p>
<h2 id="признать-проблему">Признать проблему</h2>
<p>Самое плохое, что может сделать инженер (продакт, дизайнер, разработчик), столкнувшись с проблемой — отказаться ее признавать. Начать доказывать себе и другим, что все работает правильно и ничего менять нельзя.</p>
<p>Отказываясь признавать проблему, вы бесите потребителей, ослабляете продукт и становитесь хуже как специалист.</p>
<p>Всегда стоит руководствоваться здравым смыслом. Нет, это не нормально — присылать шесть писем об одном чертовом заказе! Это проблема. И важно это признать, хотя бы перед самим собой.</p>
<p>Признав проблему, можно оценить ее влияние, варианты решения и их стоимость. И потом уже думать — будете исправлять или нет.</p>
<p><em>Признав проблему, вы не обязаны ее решать</em>. Кажется, не все это понимают. Возможно, затраты на решение не окупят выгоды. Возможно, есть более критичные проблемы, на которых стоит сосредоточиться. Возможно, вы выберете дешевый обходной путь. Возможно, вообще не найдете решение. Всё это бывает, и в каждом продукте найдутся десятки проблем, которые сознательно не будут исправлены.</p>
<p>Но важно честно сказать себе, что да, это действительно проблема. А не закрывать глаза и убеждать всех вокруг, что ее не существует.</p>
<div class="row">
<div class="col-xs-12 col-sm-10 col-md-8"><p><em>Заметка из телеграм-канала <span class="nowrap"><i class="far fa-star color-sin"></i> «<a href="https://t.me/dangry">Интерфейсы без шелухи</a>»</span></em></p></div>
</div>
]]></content:encoded>
    </item>
    
    <item>
      <title>Почтовые адреса в интерфейсе</title>
      <link>https://antonz.ru/postal-address/</link>
      <pubDate>Mon, 06 Sep 2021 14:32:41 +0000</pubDate>
      
      <guid>https://antonz.ru/postal-address/</guid>
      <description>6 правил для работы с адресами.</description>
      <content:encoded><![CDATA[<p>Моя вынужденно-любимая тема! Поговорим о том, как работать с почтовыми адресами в интерфейсах. Вот что я об этом думаю (1–3 обязательно, 4–6 по необходимости и возможности):</p>
<h2 id="1-спрашивать-адрес-одним-полем">1. Спрашивать адрес одним полем</h2>
<p>Не мучайте людей, заставляя их вводить «регион», «город», «населенный пункт» и «улицу». Достаточно одного поля с автодополнением от Дадаты, Яндекса или хотя бы Гугла.</p>
<div class="row">
<div class="col-xs-12 col-sm-8">
<figure><img alt="Подсказки адресов" src="suggestions-address.png"></figure></div>
</div>
<h2 id="2-автоматически-определять-индекс">2. Автоматически определять индекс</h2>
<p>У нас не США, люди часто не помнят свой почтовый индекс. Сделайте доброе дело и подставьте его самостоятельно.</p>
<h2 id="3-разрешать-вводить-адрес-вручную">3. Разрешать вводить адрес вручную</h2>
<p>Какой бы адресный справочник вы ни использовали, точно известно одно — жизнь все равно богаче. Запрещаете вводить неизвестные адреса → теряете часть заказов. Не делайте так.</p>
<div class="row">
<div class="col-xs-12 col-sm-8">
<figure><img alt="Ошибка ввода адреса" src="suggestions-address-error.png" class="img-bordered-thin"></figure></div>
</div>
<h2 id="4-автоматически-определять-город">4. Автоматически определять город</h2>
<p>Если человек работает из мобильного приложения, вы знаете его координаты. Если из браузера — знаете айпи-адрес. В обоих случаях несложно определить город. Только оставьте возможность его изменить, конечно.</p>
<h2 id="5-показывать-почтовое-отделение">5. Показывать почтовое отделение</h2>
<p>Если человек будет получать товар на почте, сделайте доброе дело и напишите, где находится отделение и какие у него часы работы.</p>
<div class="row">
<div class="col-xs-12 col-sm-6">
<figure><img alt="Почтовое отделение" src="postal-address-5.png" class="img-bordered-thin"></figure></div>
</div>
<h2 id="6-определять-ближайшее-метро">6. Определять ближайшее метро</h2>
<p>Если товар доставит курьер, помогите ему и автоматически определите ближайшее к адресу метро.</p>
<div class="row">
<div class="col-xs-12 col-sm-6">
<figure><img alt="Ближайшее метро" src="postal-address-6.png" class="img-bordered-thin"></figure></div>
</div>
<p class="big">
<a href="https://dadata.ru/blog/basics/best-practises-address/">Подробности — в блоге «Дадаты»</a>
</p>
<div class="row">
<div class="col-xs-12 col-sm-10 col-md-8"><p><em>Заметка из телеграм-канала <span class="nowrap"><i class="far fa-star color-sin"></i> «<a href="https://t.me/dangry">Интерфейсы без шелухи</a>»</span></em></p></div>
</div>
]]></content:encoded>
    </item>
    
    <item>
      <title>Что должно быть в письме о заказе</title>
      <link>https://antonz.ru/order-confirmation/</link>
      <pubDate>Thu, 15 Jul 2021 15:57:34 +0000</pubDate>
      
      <guid>https://antonz.ru/order-confirmation/</guid>
      <description>Номер, стоимость, время доставки.</description>
      <content:encoded><![CDATA[<p>Если продаете товары с доставкой курьером — наверняка отправляете клиентам емейл или смс после того, как заказ оформлен. Все так делают.</p>
<p>Но не у всех это письмо полезно клиенту.</p>
<h2 id="плохо">Плохо</h2>
<p>Например, «Деликатеска» присылает такую простыню:</p>
<div class="row">
<div class="col-xs-12 col-sm-10">
<figure>
  <img class="img-bordered-thin" alt="Деликатеска" src="order-confirmation-deli.png">
  <figcaption>Здравствуйте, вам нужно больше читать, поэтому вот</figcaption>
</figure>
</div>
</div>
<p>Тут и правила всего на свете, и мое имя и телефон (спасибо, а то вечно забываю), и бесконечный список заказанных товаров (на скриншоте я его обрезал), и даже призыв защитить природу в финале. Все, кроме самого главного — когда я получу заказ. Формально дата и время в письме есть, но так затейливо спрятаны, что заметить их малореально.</p>
<p>Или вот «Озон»:</p>
<div class="row">
<div class="col-xs-12 col-sm-10">
<figure>
  <img class="img-bordered-thin" alt="Озон" src="order-confirmation-ozon.png">
  <figcaption>Все скажу, дату-время доставки не скажу</figcaption>
</figure>
</div>
</div>
<p>Тут получше — хотя бы нет правил поведения при пожаре. Но главный вопрос остается — когда я получу заказ?</p>
<p>А вот «Яндекс-маркет». Почти хорошо, не считая вступления с кнопкой:</p>
<div class="row">
<div class="col-xs-12 col-sm-10">
<figure>
  <img class="img-bordered-thin" alt="Яндекс-маркет" src="order-confirmation-ym.png">
  <figcaption>Нам платят, когда вы жмакаете на кнопку «перейти к заказам», поэтому она превыше всего</figcaption>
</figure>
</div>
</div>
<h2 id="лучше">Лучше</h2>
<p>Если письмо бестолковое — человеку все равно придется идти в личный кабинет и искать информацию там. Не делайте так. Если хотите, чтобы письмо пригодилось, напишите вот что:</p>
<blockquote>
<p>Приняли заказ №12345, стоимость 5623 ₽, доставим в пятницу 16 июля с 10 до 14.</p>
</blockquote>
<p>Если ваши айти-системы в состоянии идентифицировать заказ без номера (по телефону, например) — можно номер не писать, станет еще лучше. Правда, может возникнуть путаница, если у клиента несколько заказов одним днем.</p>
<blockquote>
<p>Приняли заказ на 5623 ₽, доставим в пятницу 16 июля с 10 до 14.</p>
</blockquote>
<p>Добавьте телефон, чтобы человек не искал, как с вами связаться:</p>
<blockquote>
<p>Приняли заказ на 5623 ₽, доставим в пятницу 16 июля с 10 до 14. <u>8 800 223-23-23</u></p>
</blockquote>
<p>Если есть ограничения по оплате, тоже напишите:</p>
<blockquote>
<p>Оплата только наличными, у курьера нет сдачи.</p>
</blockquote>
<blockquote>
<p>Заказ оплачен, вот <u>чек</u>.</p>
</blockquote>
<p>Такой формат одинаково подходит для емейла и смс. В смс достаточно этим и ограничиться. В емейле можно дать больше подробностей:</p>
<ul>
<li>список товаров;</li>
<li>как изменить время или отменить заказ;</li>
<li>особенности (курьер звонит за час, доставка до двери и тому подобное).</li>
</ul>
<p>Адрес доставки имеет смысл указывать, если у клиента их несколько. ФИО, телефон, адрес эл. почты — если заказ для другого человека.</p>
<h2 id="итого">Итого</h2>
<p>Укажите в сообщении о заказе:</p>
<ul>
<li>номер (если без него никак);</li>
<li>стоимость,</li>
<li>дату и время доставки,</li>
<li>контактный телефон,</li>
<li>важные ограничения.</li>
</ul>
<blockquote>
<p>Приняли заказ № 12345, стоимость 5623 ₽, доставим в пятницу 16 июля с 10 до 14. Оплата только наличными. <u>8 800 223-23-23</u></p>
</blockquote>
<p>Такое сообщение действительно пригодится.</p>
<div class="row">
<div class="col-xs-12 col-sm-10 col-md-8"><p><em>Заметка из телеграм-канала <span class="nowrap"><i class="far fa-star color-sin"></i> «<a href="https://t.me/dangry">Интерфейсы без шелухи</a>»</span></em></p></div>
</div>
]]></content:encoded>
    </item>
    
  </channel>
</rss>