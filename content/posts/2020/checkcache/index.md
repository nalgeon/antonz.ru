+++
date = 2020-06-30T16:27:34Z
description = "Чтобы не остаться в продакшене с пустым кешем посреди рабочего дня."
image = "/assets/projects/ohmypy-2.png"
slug = "checkcache"
tags = ["ohmypy"]
title = "Зачем читать исходники стандартной библиотеки"
subscribe = "ohmypy"
+++

Я как-то писал, что в документацию питона добавили ссылки на [исходники модулей](/python-sources/). Читать их не только увлекательно, но и полезно.

Помните `linecache.getline()` из прошлого поста, который выбирает строчку файла [по номеру](/linecache/)?

```python
>>> linecache.getline("answers.txt", 3)
'Проверили, проблема на вашей стороне'
```

Модуль не случайно называется `linecache`. При первом обращении к файлу `linecache` записывает его содержимое в кеш (в глобальную переменную `cache`). Именно из кеша `getline()` и выбирает строку по номеру. Благодаря кешу второй и следующие вызовы уже не читают файл и отрабатывают моментально.

```python
# lines - список строк файла
cache[filename] = size, mtime, lines, fullname
```

И есть в модуле функция `linecache.checkcache()`. Вот её документация:

> Check the cache for validity. Use this function if files in the cache may have changed on disk, and you require the updated version.

Вроде понятно, проверяет и актуализирует кеш. А вот как выглядит исходник функции:

```python
def checkcache(filename=None):
    # проверка, обновился ли файл
    # по сравнению с кешем
    # и если обновился, то:
    cache.pop(filename)
```

Оказывается, `checkcache()` не актуализирует, а очищает кеш! Из-за этого следующий вызов `getline()` отработает заметно медленнее: придётся заново начитывать весь файл.

В случае с `linecache` это вряд ли станет большой проблемой, но представьте, какой был бы неприятный сюрприз, если бы речь шла о продакшен-кеше вашего приложения ツ

В любой непонятной ситуации читай исходники, как говорил Урбан Мюллер, автор языка Brainfuck.
