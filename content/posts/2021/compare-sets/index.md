+++
date = 2021-05-25T21:16:27Z
description = "С помощью множества (set)."
image = "/assets/projects/ohmypy-2.png"
slug = "compare-sets"
tags = ["ohmypy"]
title = "Поэлементно сравнить коллекции в Python"
subscribe = "ohmypy"
+++

Однажды мы уже смотрели, как множества помогают быстро проверить, [входит ли элемент в коллекцию](/element-in-collection/).

Конечно, это не единственная возможность. Множества в питоне идеально подходят, чтобы поэлементно сравнивать коллекции.

Допустим, мы ведем учет посетителей:

```python
jan = ["Питер", "Клер", "Френк"]
feb = ["Френк", "Зоя", "Дуглас"]
mar = ["Клер", "Питер", "Зоя"]
```

И хотим узнать, кто приходил в январе и феврале. Нет ни малейшего желания писать вложенный цикл с перебором `jan` и `feb`. Намного приятнее (и быстрее) использовать множества.

```python
jan = {"Питер", "Клер", "Френк"}
feb = {"Френк", "Зоя", "Дуглас"}
mar = {"Клер", "Питер", "Зоя"}
```

Были в январе и феврале:

```python
>>> jan & feb
{'Френк'}
```

В январе или марте:

```python
>>> jan | mar
{'Питер', 'Клер', 'Зоя', 'Френк'}
```

В феврале, но не в марте:

```python
>>> feb - mar
{'Френк', 'Дуглас'}
```

В январе или феврале, но не в оба месяца:

```python
>>> jan ^ feb
{'Питер', 'Клер', 'Зоя', 'Дуглас'}
```

Вернулись ли зимние посетители в марте?

```python
>>> (jan & feb) <= mar
False
```

Все эти операции выполняются за линейное время `O(n)` вместо квадратичного `O(n²)`, как было бы на списках.

Кроме обычных множеств бывают замороженные (их нельзя менять):

```python
>>> visitors = frozenset ().union (jan, feb, mar)
>>> visitors
frozenset ({'Питер', 'Клер', 'Зоя', 'Френк', 'Дуглас'})
```

Множество можно слепить из любого iterable-типа. Например, из строки:

```python
>>> frozenset ('abcde')
frozenset ({'b', 'd', 'e', 'c', 'a'})
```

Или даже из диапазона:

```python
>>> set (range (1, 10))
{1, 2, 3, 4, 5, 6, 7, 8, 9}
```

Ключи словаря тоже работают как множество:

```python
>>> stats = { "Френк": 99, "Клер": 50 }
>>> stats.keys() & jan
{'Клер', 'Френк'}
```

В общем, полезная штука.
