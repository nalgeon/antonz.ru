<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>sqlite on Антон Жиянов</title><link>https://antonz.ru/tags/sqlite/</link><description>Recent content in sqlite on Антон Жиянов</description><generator>Hugo -- gohugo.io</generator><language>ru-ru</language><lastBuildDate>Wed, 18 May 2022 21:30:00 +0000</lastBuildDate><atom:link href="https://antonz.ru/tags/sqlite/index.xml" rel="self" type="application/rss+xml"/><item><title>Временные таблицы в SQLite</title><link>https://antonz.ru/temp-tables/</link><pubDate>Wed, 18 May 2022 21:30:00 +0000</pubDate><guid>https://antonz.ru/temp-tables/</guid><description>Бывает, хочется собрать данные из нескольких таблиц в одну, и дальше с ними поработать. Например, выбрать вакансии вместе с работодателями и регионами:
select v.*, e.name, a.name from vacancy as v join employer as e on e.id = v.employer_id join area as a on a.id = v.area_id Вопрос, как дальше запускать запросы по сводным данным. Есть три способа это сделать:
Табличное выражение (CTE) Представление (view) Временная таблица (temporary table) Табличное выражение — это подзапрос с именем:</description></item><item><title>JSON и виртуальные столбцы в SQLite</title><link>https://antonz.ru/json-virtual-columns/</link><pubDate>Sun, 15 May 2022 11:25:00 +0000</pubDate><guid>https://antonz.ru/json-virtual-columns/</guid><description>У вычисляемых столбцов есть еще одно чрезвычайно полезное применение.
Допустим, вы решили вести журнал событий, которые происходят в системе. События бывают разных типов, у каждого свой набор полей. Например, вход в систему:
{ &amp;#34;timestamp&amp;#34;: &amp;#34;2022-05-15T09:31:00Z&amp;#34;, &amp;#34;object&amp;#34;: &amp;#34;user&amp;#34;, &amp;#34;object_id&amp;#34;: 11, &amp;#34;action&amp;#34;: &amp;#34;login&amp;#34;, &amp;#34;details&amp;#34;: { &amp;#34;ip&amp;#34;: &amp;#34;192.168.0.1&amp;#34; } } Или пополнение счета:
{ &amp;#34;timestamp&amp;#34;: &amp;#34;2022-05-15T09:32:00Z&amp;#34;, &amp;#34;object&amp;#34;: &amp;#34;account&amp;#34;, &amp;#34;object_id&amp;#34;: 12, &amp;#34;action&amp;#34;: &amp;#34;deposit&amp;#34;, &amp;#34;details&amp;#34;: { &amp;#34;amount&amp;#34;: &amp;#34;1000&amp;#34;, &amp;#34;currency&amp;#34;: &amp;#34;USD&amp;#34; } } Вы решаете не заниматься нормализацией по таблицам, а хранить прямо в JSON.</description></item><item><title>Вычисляемые столбцы в SQLite</title><link>https://antonz.ru/generated-columns/</link><pubDate>Sat, 07 May 2022 17:10:00 +0000</pubDate><guid>https://antonz.ru/generated-columns/</guid><description>Иногда поле в запросе рассчитывают на основе других столбцов таблицы. Например, есть столбец income с годовым доходом и tax_rate с налоговой ставкой:
┌────────┬──────────┐ │ income │ tax_rate │ ├────────┼──────────┤ │ 70 │ 0.22 │ │ 84 │ 0.22 │ │ 90 │ 0.24 │ └────────┴──────────┘ Можно посчитать годовой налог:
select id, income * tax_rate as tax from people; А чтобы не таскать везде это выражение, удобно создать виртуальный вычисляемый столбец (generated column):</description></item><item><title>Многострочные запросы в консоли SQLite</title><link>https://antonz.ru/sqlite-multiline/</link><pubDate>Sun, 24 Apr 2022 21:30:00 +0000</pubDate><guid>https://antonz.ru/sqlite-multiline/</guid><description>Стоило написать, что отлаживать многострочные запросы в консоли SQLite неудобно, как вычитал на sqlite-форуме классный трюк:
Достаточно вместо Enter использовать для перехода на новую строку сочетание Ctrl+V, Ctrl+J — и многострочный запрос редактируется одним куском!
Еще несколько способов, которые используют люди:
Внешний редактор (.shell &amp;lt;editor&amp;gt; &amp;lt;file&amp;gt;) Запуск из файла (.read &amp;lt;file&amp;gt;) DBeaver, DataGrip или аналоги</description></item><item><title>История команд SQLite</title><link>https://antonz.ru/sqlite-history/</link><pubDate>Sun, 17 Apr 2022 14:50:00 +0000</pubDate><guid>https://antonz.ru/sqlite-history/</guid><description>Если вы используете консоль SQLite (sqlite3 или sqlite3.exe), то она помнит последние 2000 выполненных команд. Чтобы повторить последнюю команду, достаточно нажать клавишу ↑, а поиск работает по сочетанию Ctrl+R.
Быстрее найти старый запрос, чем вбивать заново По умолчанию файл истории хранится в каталоге пользователя и называется .sqlite_history. Он текстовый, так что можно просматривать хоть в редакторе. Если хотите сохранить в другом месте — укажите полный путь в переменной окружения SQLITE_HISTORY.</description></item><item><title>Гибкие типы данных в SQLite</title><link>https://antonz.ru/sqlite-types/</link><pubDate>Wed, 12 Jan 2022 15:15:00 +0000</pubDate><guid>https://antonz.ru/sqlite-types/</guid><description>Люди часто не понимают, что за ерунда происходит в SQLite с типами данных. Давайте разберемся.
SQLite использует пять типов:
INTEGER — целые числа, REAL — действительные числа, TEXT — строки, BLOB — бинарные данные, NULL — пустое значение. Пока ничего необычного (только типов маловато по сравнению с другими СУБД).
А как вам такое:
SQLite может хранить данные любого типа — вне зависимости от того, какой тип указан на столбце.</description></item><item><title>Все расширения для SQLite</title><link>https://antonz.ru/sqlean/</link><pubDate>Tue, 04 Jan 2022 11:30:00 +0000</pubDate><guid>https://antonz.ru/sqlean/</guid><description>Мне очень нравится SQLite. Это миниатюрная встраиваемая база, которая отлично подходит как для исследовательского анализа данных, так и в качестве хранилища для небольших приложений (писал об этом, не буду повторяться).
Но есть у нее один недостаток: маловато встроенных функций по сравнению с PostgreSQL или Oracle. К счастью, авторы заложили в SQLite механизм расширений, на котором можно сделать почти все что угодно. В результате интернет заполнен обрывочными расширениями, которые добавляют функцию-другую.</description></item><item><title>Быстрый поиск похожих слов на SQL</title><link>https://antonz.ru/similar-words/</link><pubDate>Thu, 02 Dec 2021 13:30:00 +0000</pubDate><guid>https://antonz.ru/similar-words/</guid><description>В этой статье разберемся, как быстро найти похожее слово в огромном словаре. Сначала рассмотрим наивное решение, потом сконструируем быстрое, а в конце посмотрим на готовое.
Предположим, мы хотим исправлять опечатки в поисковых запросах или сообщениях чата. Человек вводит «абривиатура», мы исправляем на «аббревиатура», «рассчет» → «расчет», «дороаг» → «дорога». Посмотрим, как решить такую задачу на SQL.
Я буду использовать SQLite. Но аналогичный подход сработает с любой СУБД или языком программирования (если интересно — дайте знать, сделаю примеры на Python).</description></item><item><title>Что нового в SQLite 3.37</title><link>https://antonz.ru/sqlite-3-37/</link><pubDate>Sun, 28 Nov 2021 15:25:00 +0000</pubDate><guid>https://antonz.ru/sqlite-3-37/</guid><description>В отличие от 3.35, релиз 3.37 принес не так много изменений. Но среди них — одно из важнейших за всю историю: «строгий» режим таблиц, в котором движок следит, чтобы данные в столбце соответствовали типу.
Возможно, теперь SQLite перестанут называть «джаваскриптом в мире СУБД» ツ Но давайте по порядку.
подробности на хабре</description></item><item><title>Табличные выражения SQL</title><link>https://antonz.ru/cte/</link><pubDate>Fri, 05 Nov 2021 11:14:51 +0000</pubDate><guid>https://antonz.ru/cte/</guid><description>Прием № 1, чтобы писать хорошие читаемые SQL-запросы — это табличные выражения (CTE). Люди их боятся, а зря. Давайте разберемся за три минуты, читать увесистую книгу по SQL или проходить курсы не придется.
Проблема Допустим, у нас есть таблица продаж по месяцам за два года:
┌──────┬───────┬───────┬──────────┬─────────┐ │ year │ month │ price │ quantity │ revenue │ ├──────┼───────┼───────┼──────────┼─────────┤ │ 2019 │ 1 │ 60 │ 200 │ 12000 │ │ 2019 │ 2 │ 60 │ 660 │ 39600 │ │ 2019 │ 3 │ 60 │ 400 │ 24000 │ │ 2019 │ 4 │ 60 │ 300 │ 18000 │ │ 2019 │ 5 │ 60 │ 440 │ 26400 │ │ 2019 │ 6 │ 60 │ 540 │ 32400 │ │ 2019 │ 7 │ 60 │ 440 │ 26400 │ │ 2019 │ 8 │ 60 │ 440 │ 26400 │ │ 2019 │ 9 │ 60 │ 250 │ 15000 │ │ 2019 │ 10 │ 60 │ 420 │ 25200 │ │ .</description></item></channel></rss>