<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ohmypy on Антон Жиянов</title>
    <link>https://antonz.ru/tags/ohmypy/</link>
    <description>Recent content in ohmypy on Антон Жиянов</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ru-ru</language>
    <lastBuildDate>Sat, 19 Jun 2021 17:24:59 +0000</lastBuildDate><atom:link href="https://antonz.ru/tags/ohmypy/rss" rel="self" type="application/rss+xml" />
    <item>
      <title>Разбор текста по шаблону на Python</title>
      <link>https://antonz.ru/parse/</link>
      <pubDate>Sat, 19 Jun 2021 17:24:59 +0000</pubDate>
      
      <guid>https://antonz.ru/parse/</guid>
      <description>Все знают, как в питоне форматировать текст по шаблону:
import datetime as dt date = dt.date(2020, 11, 20) who = &amp;#34;Френк&amp;#34; count = 42 tmpl = &amp;#34;{:%Y-%m-%d}: {}и его {:d}друга вылетели в Копенгаген&amp;#34; &amp;gt;&amp;gt;&amp;gt; tmpl.format(date, who, count) &amp;#39;2020-11-20: Френк и его 42 друга вылетели в Копенгаген&amp;#39; А благодаря библиотеке parse от Ричарда Джонса, с такой же легкостью можно разбирать текст обратно по переменным:
import parse tmpl = &amp;#34;{:ti}: {}и его {:d}друга вылетели в Копенгаген&amp;#34; txt = &amp;#34;2020-11-20: Френк и его 42 друга вылетели в Копенгаген&amp;#34; &amp;gt;&amp;gt;&amp;gt; date, who, count = parse.</description>
    </item>
    
    <item>
      <title>Современный HTTP-клиент для Python</title>
      <link>https://antonz.ru/httpx/</link>
      <pubDate>Sat, 12 Jun 2021 17:21:00 +0000</pubDate>
      
      <guid>https://antonz.ru/httpx/</guid>
      <description>Мало у какого языка такая нажористая стандартная библиотека, как у питона. Но все равно для работы с HTTP люди пользуются сторонним пакетом requests.
А я вот отказался от него в пользу замечательного httpx от Тома Кристи. Синхронный и асинхронный интерфейсы, поддержка wsgi/asgi, плюс все фичи requests — и совместимость с ним!
Можно заменить requests → httpx, и все продолжит работать:
&amp;gt;&amp;gt;&amp;gt; import httpx &amp;gt;&amp;gt;&amp;gt; r = httpx.get(&amp;quot;http://httpbingo.org/json&amp;quot;) &amp;gt;&amp;gt;&amp;gt; r.status_code 200 &amp;gt;&amp;gt;&amp;gt; r.</description>
    </item>
    
    <item>
      <title>Универсальные оповещения на Python</title>
      <link>https://antonz.ru/notifiers/</link>
      <pubDate>Sat, 05 Jun 2021 15:00:00 +0000</pubDate>
      
      <guid>https://antonz.ru/notifiers/</guid>
      <description>Есть куча способов отправлять уведомления — от проверенного SMTP и удобного Telegram до смс и специальных приложений для мобилок вроде Pushover.
Обычно для этого используют 3rd-party библиотеку соответствующего провайдера. Но есть более удобный способ — пакет notifiers от Ора Карми. Он предоставляет простой универсальный интерфейс для отправки сообщений через любой сервис.
Например, через телеграм:
import notifiers token = &amp;#34;bot_token&amp;#34; chat_id = 1234 tg = notifiers.get_notifier(&amp;#34;telegram&amp;#34;) tg.notify(message=&amp;#34;Привет!&amp;#34;, token=token, chat_id=chat_id) Поддерживается аж 16 провайдеров, а интерфейс один — метод .</description>
    </item>
    
    <item>
      <title>Счетчик для огромных коллекций на Python</title>
      <link>https://antonz.ru/bounter/</link>
      <pubDate>Sun, 30 May 2021 08:34:00 +0000</pubDate>
      
      <guid>https://antonz.ru/bounter/</guid>
      <description>В стандартной библиотеке есть класс Counter. Он отлично подходит, чтобы считать количество объектов разных типов. Но что делать, если объектов миллиарды, и счетчик просто не помещается в оперативную память?
Поможет bounter — это счетчик, который предоставляет схожий интерфейс, но внутри построен на вероятностных структурах данных. За счет этого он занимает в 30–250 раз меньше памяти, но может (слегка) привирать.
from bounter import bounter counts = bounter(size_mb=128) counts.update([&amp;#34;a&amp;#34;, &amp;#34;b&amp;#34;, &amp;#34;c&amp;#34;, &amp;#34;a&amp;#34;, &amp;#34;b&amp;#34;]) &amp;gt;&amp;gt;&amp;gt; counts.</description>
    </item>
    
    <item>
      <title>Поэлементно сравнить коллекции в Python</title>
      <link>https://antonz.ru/compare-sets/</link>
      <pubDate>Tue, 25 May 2021 21:16:27 +0000</pubDate>
      
      <guid>https://antonz.ru/compare-sets/</guid>
      <description>Однажды мы уже смотрели, как множества помогают быстро проверить, входит ли элемент в коллекцию.
Конечно, это не единственная возможность. Множества в питоне идеально подходят, чтобы поэлементно сравнивать коллекции.
Допустим, мы ведем учет посетителей:
jan = [&amp;#34;Питер&amp;#34;, &amp;#34;Клер&amp;#34;, &amp;#34;Френк&amp;#34;] feb = [&amp;#34;Френк&amp;#34;, &amp;#34;Зоя&amp;#34;, &amp;#34;Дуглас&amp;#34;] mar = [&amp;#34;Клер&amp;#34;, &amp;#34;Питер&amp;#34;, &amp;#34;Зоя&amp;#34;] И хотим узнать, кто приходил в январе и феврале. Нет ни малейшего желания писать вложенный цикл с перебором jan и feb. Намного приятнее (и быстрее) использовать множества.</description>
    </item>
    
    <item>
      <title>Планировщик задач на Python</title>
      <link>https://antonz.ru/schedule/</link>
      <pubDate>Sat, 22 May 2021 08:31:00 +0000</pubDate>
      
      <guid>https://antonz.ru/schedule/</guid>
      <description>В стандартной библотеке есть встроенный планировщик задач (а чего вообще в ней нет?). Подробно расскажу в другой раз, но в целом он, скажем так, не слишком юзер-френдли.
Поэтому Дэн Бэйдер сделал schedule — «планировщик для людей». Смотрите, какой милый:
import schedule import time def job(): print(&amp;#34;I&amp;#39;m working...&amp;#34;) schedule.every().hour.do(job) schedule.every(5).to(10).minutes.do(job) schedule.every().day.at(&amp;#34;10:30&amp;#34;).do(job) while True: schedule.run_pending() time.sleep(1) Ноль зависимостей, чистый и великолепно документированный код, примеры на все случаи жизни.
Заметка из телеграм-канала  «Oh My Py»</description>
    </item>
    
    <item>
      <title>«Отнаследовать» функцию от существующей в Python</title>
      <link>https://antonz.ru/functools-partial/</link>
      <pubDate>Tue, 18 May 2021 09:33:53 +0000</pubDate>
      
      <guid>https://antonz.ru/functools-partial/</guid>
      <description>Допустим, у нас есть список важных гостей. Он в легком беспорядке:
data = [ &amp;#34;4 - Дуглас&amp;#34;, &amp;#34;2 - Клер&amp;#34;, &amp;#34;11 - Зоя&amp;#34;, &amp;#34;1 - Френк&amp;#34;, &amp;#34;31 - Питер&amp;#34;, ] Отсортируем:
&amp;gt;&amp;gt;&amp;gt; sorted(data) [&amp;#39;1 - Френк&amp;#39;, &amp;#39;11 - Зоя&amp;#39;, &amp;#39;2 - Клер&amp;#39;, &amp;#39;31 - Питер&amp;#39;, &amp;#39;4 - Дуглас&amp;#39;] Порядка не прибавилось — sorted() не знает, что здесь нужна числовая сортировка, а не алфавитная. Поможем ему:
def _key(src): parts = src.partition(&amp;#34; - &amp;#34;) return int(parts[0]) &amp;gt;&amp;gt;&amp;gt; sorted(data, key=_key) [&amp;#39;1 - Френк&amp;#39;, &amp;#39;2 - Клер&amp;#39;, &amp;#39;4 - Дуглас&amp;#39;, &amp;#39;11 - Зоя&amp;#39;, &amp;#39;31 - Питер&amp;#39;] Так хорошо!</description>
    </item>
    
    <item>
      <title>Естественная сортировка на Python</title>
      <link>https://antonz.ru/natsort/</link>
      <pubDate>Sat, 15 May 2021 08:28:00 +0000</pubDate>
      
      <guid>https://antonz.ru/natsort/</guid>
      <description>Это #пакетик — еженедельная рубрика о полезных и интересных пакетах на Python.
Мой сегодняшний выбор — пакет Сета Мортона natsort, который сортирует строки привычным для человека образом.
Допустим, у нас есть список важных гостей. Он в легком беспорядке:
data = [ &amp;#34;4 - Дуглас&amp;#34;, &amp;#34;2 - Клер&amp;#34;, &amp;#34;11 - Зоя&amp;#34;, &amp;#34;1 - Френк&amp;#34;, &amp;#34;31 - Питер&amp;#34;, ] Отсортируем:
&amp;gt;&amp;gt;&amp;gt; sorted(data) [&amp;#39;1 - Френк&amp;#39;, &amp;#39;11 - Зоя&amp;#39;, &amp;#39;2 - Клер&amp;#39;, &amp;#39;31 - Питер&amp;#39;, &amp;#39;4 - Дуглас&amp;#39;] Порядка не прибавилось ツ А вот как будет с natsort:</description>
    </item>
    
    <item>
      <title>Второй язык для питониста</title>
      <link>https://antonz.ru/python-plus-one/</link>
      <pubDate>Sun, 09 May 2021 12:15:13 +0000</pubDate>
      
      <guid>https://antonz.ru/python-plus-one/</guid>
      <description>Если вы давно и хорошо знаете питон, некоторые моменты в нем могут напрягать. Например, необходимость начинать каждый новый проект с создания виртуального окружения и установки пачки тулов вроде black, pylint и pytest. Или отсутствующий рефакторинг и частые ошибки из-за динамической типизации. Или убоговатая асинхронность и костыль в виде GIL.
Если у вас так — возможно, пора освоить второй язык. Логично выбрать вариант без питонячих недостатков: статически типизированный, с готовым тулингом, продуманной асинхронностью и параллелизмом.</description>
    </item>
    
    <item>
      <title>Простое против легкого</title>
      <link>https://antonz.ru/simple-made-easy/</link>
      <pubDate>Fri, 26 Feb 2021 12:55:15 +0000</pubDate>
      
      <guid>https://antonz.ru/simple-made-easy/</guid>
      <description>9 лет назад в докладе «Simple Made Easy» Рич Хикки рассказал о разнице между простым (simple) и легким (easy) в разработке софта. Стремление к простым программам (в противоположность легким) — самый важный, наверное, принцип разработки. И при этом совершенно непопулярный.
 Simple — это о внутреннем устройстве программы, ее архитектуре. У простых программ мало внутренних зависимостей, движущихся частей, настроек. Антипод простой программы — сложная. Простая программа или сложная — это объективная характеристика.</description>
    </item>
    
    <item>
      <title>Задачка об итераторе на Python</title>
      <link>https://antonz.ru/iter-with-sentinel/</link>
      <pubDate>Mon, 10 Aug 2020 11:11:02 +0000</pubDate>
      
      <guid>https://antonz.ru/iter-with-sentinel/</guid>
      <description>На днях я предложил читателям телеграм-канала Oh My Py задачку об итераторе с ограничениями. Давайте её разберём.
Условия задачи Допустим, вы основали модный HR-стартап, который подбирает идеальные коллективы сотрудников. Дело это нелёгкое, так что начали с простой эвристики:
 Любой коллектив идеален, пока в нём не появляется Френк
 Подготовили интеллектуальный алгоритм, который предлагает сотрудника:
import random names = [&amp;#34;Френк&amp;#34;, &amp;#34;Клер&amp;#34;, &amp;#34;Зоя&amp;#34;, &amp;#34;Питер&amp;#34;, &amp;#34;Лукас&amp;#34;] def employee(): name = random.choice(names) return name Остался последний шаг — разработать нечто под названием employeficator(), что и будет подбирать дружный коллектив.</description>
    </item>
    
    <item>
      <title>Python. Грамотно работать с любым диапазоном</title>
      <link>https://antonz.ru/range/</link>
      <pubDate>Fri, 07 Aug 2020 12:50:42 +0000</pubDate>
      
      <guid>https://antonz.ru/range/</guid>
      <description>Все знают, что range() в питоне используется, когда нужно что-то сделать сколько-то раз:
&amp;gt;&amp;gt;&amp;gt; for i in range(3, 0, -1): ... print(i) 3 2 1 Но не все знают, что range — это коллекция (что? да!), вполне себе полноценная:
&amp;gt;&amp;gt;&amp;gt; seq = range(10, 100) &amp;gt;&amp;gt;&amp;gt; len(seq) 90 &amp;gt;&amp;gt;&amp;gt; 52 in seq True &amp;gt;&amp;gt;&amp;gt; seq[10] 20 И даже так:
&amp;gt;&amp;gt;&amp;gt; max(seq) 99 &amp;gt;&amp;gt;&amp;gt; seq.index(31) 21 &amp;gt;&amp;gt;&amp;gt; seq.count(42) 1 И так тоже:</description>
    </item>
    
    <item>
      <title>Python. Проверить, входит ли элемент в коллекцию</title>
      <link>https://antonz.ru/element-in-collection/</link>
      <pubDate>Thu, 30 Jul 2020 16:05:51 +0000</pubDate>
      
      <guid>https://antonz.ru/element-in-collection/</guid>
      <description>Предположим, вы ведёте реестр монет. В нём записаны монетки всех времён, стран и достоинств. На вашем сайте любой может проверить, есть ли та или иная монета в реестре, и если нет — добавить её.
Как проверить, есть ли монета в реестре?
Список: очень, очень медленно Можно так:
coins = [&amp;#34;1 aud&amp;#34;, &amp;#34;5 ars&amp;#34;, &amp;#34;1 byn&amp;#34;, &amp;#34;10 ghs&amp;#34;] def has(coin): return coin in coins &amp;gt;&amp;gt;&amp;gt; has(&amp;#34;1 byn&amp;#34;) True &amp;gt;&amp;gt;&amp;gt; has(&amp;#34;20 cny&amp;#34;) False Конечно, так делать нехорошо.</description>
    </item>
    
    <item>
      <title>Зачем читать исходники стандартной библиотеки</title>
      <link>https://antonz.ru/checkcache/</link>
      <pubDate>Tue, 30 Jun 2020 16:27:34 +0000</pubDate>
      
      <guid>https://antonz.ru/checkcache/</guid>
      <description>Я как-то писал, что в документацию питона добавили ссылки на исходники модулей. Читать их не только увлекательно, но и полезно.
Помните linecache.getline() из прошлого поста, который выбирает строчку файла по номеру?
&amp;gt;&amp;gt;&amp;gt; linecache.getline(&amp;#34;answers.txt&amp;#34;, 3) &amp;#39;Проверили, проблема на вашей стороне&amp;#39; Модуль не случайно называется linecache. При первом обращении к файлу linecache записывает его содержимое в кеш (в глобальную переменную cache). Именно из кеша getline() и выбирает строку по номеру. Благодаря кешу второй и следующие вызовы уже не читают файл и отрабатывают моментально.</description>
    </item>
    
    <item>
      <title>Python. Прочитать произвольную строку из файла</title>
      <link>https://antonz.ru/linecache/</link>
      <pubDate>Wed, 17 Jun 2020 12:57:43 +0000</pubDate>
      
      <guid>https://antonz.ru/linecache/</guid>
      <description>Предположим, вы решили разработать продвинутого саппорт-бота. В нём будет машин лёнинга до самых краёв, так что человек почти не понадобится. К сожалению, неотложные дела отвлекли ваше внимание, и вы делегировали задачу Френку.
Прямо скажем, это было не лучшее решение. Тупая и ленивая скотина придумала, что достаточно заготовить файл с универсальными ответами на все случаи жизни, и на каждый вопрос отвечать случайной фразой:
# answers.txt Перезагрузите ваше устройство, пожалуйста Проверили, проблема на вашей стороне Спасибо, займёмся этим позже Наши технические возможности исчерпаны Простой, надёжный алгоритм.</description>
    </item>
    
    <item>
      <title>Python. Отрезать строке голову и хвост</title>
      <link>https://antonz.ru/removeprefix/</link>
      <pubDate>Tue, 09 Jun 2020 11:47:38 +0000</pubDate>
      
      <guid>https://antonz.ru/removeprefix/</guid>
      <description>В Python 3.9 строке добавили методы, которые удаляют префикс и суффикс:
&amp;gt;&amp;gt;&amp;gt; &amp;#34;Френк и семечки&amp;#34;.removeprefix(&amp;#34;Френк и &amp;#34;) &amp;#39;семечки&amp;#39; &amp;gt;&amp;gt;&amp;gt; &amp;#34;Френк и семечки&amp;#34;.removesuffix(&amp;#34; и семечки&amp;#34;) &amp;#39;Френк&amp;#39; Во время обсуждения PEP разгорелся нешуточный спор. Сначала автор предложил названия cutprefix() и cutsuffix(), но сообществу не понравился глагол cut. Альтернативой предложили strip, trim и remove, долго и мучительно обсуждали, наконец остановились на remove.
Конечно, именование переменных и методов — первая неразрешимая проблема программирования (вторая, как вы знаете — устаревание кеша).</description>
    </item>
    
    <item>
      <title>Как сделать классный Python-пакет</title>
      <link>https://antonz.ru/packaging/</link>
      <pubDate>Fri, 15 May 2020 07:58:16 +0000</pubDate>
      
      <guid>https://antonz.ru/packaging/</guid>
      <description>Версия от апреля 2021 года
Бывает, напишешь какую-нибудь полезную утилиту на питоне, и хочется поделиться ей с коллегами. Лучший способ для этого — сделать пакет (package): он устанавливается одной командой и спасает от копипасты.
Если вы, как и я раньше, думаете, что создание пакетов в питоне — большая головная боль, то знайте, что это не так. Чтобы не быть голословным, я сделал это пошаговое руководство. Три основных шага и несколько вспомогательных, со ссылками на гитхаб.</description>
    </item>
    
    <item>
      <title>Автоматизация задач в Python-проекте</title>
      <link>https://antonz.ru/makefile/</link>
      <pubDate>Tue, 05 May 2020 15:16:48 +0000</pubDate>
      
      <guid>https://antonz.ru/makefile/</guid>
      <description>Когда разрабатываешь библиотеку или приложение, всегда найдутся задачи, которые выполняешь изо дня в день:
 проверить код линтерами, прогнать тесты с замером покрытия, запустить в докере, &amp;hellip;  JS-разработчикам повезло (ха): у них в package.json есть специальная секция scripts для таких штук:
{ ... &amp;quot;scripts&amp;quot;: { &amp;quot;format&amp;quot;: &amp;quot;prettier --write \&amp;quot;src/**/*.ts\&amp;quot;&amp;quot;, &amp;quot;lint&amp;quot;: &amp;quot;tslint -p tsconfig.json&amp;quot;, &amp;quot;test&amp;quot;: &amp;quot;jest --coverage --config jestconfig.json&amp;quot;, }, ... } Для Питона ничего подобного не предусмотрено. Можно, конечно, сделать по sh-скрипту на каждую задачу, но это замусоривает каталог проекта, да и хотелось бы все такие задачи держать вместе.</description>
    </item>
    
    <item>
      <title>Python. Создать словарь по списку ключей</title>
      <link>https://antonz.ru/dict-from-keys/</link>
      <pubDate>Tue, 09 Jul 2019 14:07:20 +0000</pubDate>
      
      <guid>https://antonz.ru/dict-from-keys/</guid>
      <description>Предположим, вы сделали робота для общественных пространств. Он будет помогать людям.
Вы решаете, что полезно собирать статистику добрых дел — что и сколько раз робот сделал. Для этого удобно использовать счётчик, ключами которого будут названия действий, а значениями — количество выполнений.
Робот постоянно учится новым полезным активностям, так что набор дел не фиксированный. Он хранится в списке:
actions = [ &amp;#34;махать флагом&amp;#34;, &amp;#34;чесать котов&amp;#34;, &amp;#34;смешить детей&amp;#34;, &amp;#34;рвать шаблоны&amp;#34;, ] Как бы из этого списка сделать счётчик?</description>
    </item>
    
    <item>
      <title>Python. Пронумеровать элементы коллекции</title>
      <link>https://antonz.ru/enumerate/</link>
      <pubDate>Tue, 02 Jul 2019 14:10:00 +0000</pubDate>
      
      <guid>https://antonz.ru/enumerate/</guid>
      <description>Одна уважаемая компания заказала вам разработку теста для соискателей на позицию «дизайнер продукта». Есть список вопросов с вариантами ответа:
survey = { &amp;#34;Чем известен Джони Айв?&amp;#34;: [ &amp;#34;Придумал анимированные эмодзи&amp;#34;, &amp;#34;Снялся в фильме про белую комнату&amp;#34;, &amp;#34;Изобрёл мышку с зарядкой в пузе&amp;#34;, ], &amp;#34;Почему важно надувать щёки?&amp;#34;: [ ... ], &amp;#34;Сколько у вас статей про дизайн-системы?&amp;#34;: [ ... ], } Вы написали код, который показывает на экране каждый вопрос с вариантами ответа:</description>
    </item>
    
    <item>
      <title>Быстрый язык ≠ быстрый код</title>
      <link>https://antonz.ru/fast-language/</link>
      <pubDate>Mon, 01 Jul 2019 08:15:04 +0000</pubDate>
      
      <guid>https://antonz.ru/fast-language/</guid>
      <description>Получил такой комментарий на заметку про быстрый и медленный алгоритмы:
 Мне кажется, тут не совсем корректное сравнение. sorted оптимизированная и написана на С, в то время как insort — просто питоновская функция. Она гоняет питоновские структурки и при любом раскладе будет работать медленно.
 Это вообще популярная точка зрения, что если что-то написано на «быстром» языке, то оно уж всяко будет быстрее, чем написанное на «медленном».
Конечно же, это не так.</description>
    </item>
    
    <item>
      <title>Python. Cортировать в конце или держать отсортированным?</title>
      <link>https://antonz.ru/sorted-puzzle/</link>
      <pubDate>Sat, 29 Jun 2019 07:55:19 +0000</pubDate>
      
      <guid>https://antonz.ru/sorted-puzzle/</guid>
      <description>На днях я предложил подписчикам канала Oh My Py такую задачку:
 Допустим, вы пишете программу, которой на вход последовательно, одно за другим, приходят числа. Ваша задача — накапливать их как-то, а потом, когда числа перестанут приходить — вернуть отсортированный список. Как думаете, что будет работать быстрее:
 Складывать приходящие числа в неупорядоченную кучу, отсортировать в конце. Постоянно поддерживать отсортированный список (с помощью bisect), в конце просто вернуть его.    Вот результаты голосования:</description>
    </item>
    
    <item>
      <title>Python. Быстро найти элемент коллекции</title>
      <link>https://antonz.ru/bisect/</link>
      <pubDate>Wed, 26 Jun 2019 16:44:00 +0000</pubDate>
      
      <guid>https://antonz.ru/bisect/</guid>
      <description>Френк решил открыть магазин диковинок. Прайс-лист огромный, приведу только несколько позиций:
from collections import namedtuple Product = namedtuple(&amp;#34;Product&amp;#34;, (&amp;#34;price&amp;#34;, &amp;#34;name&amp;#34;)) products = [ Product(1500, &amp;#34;живой багет&amp;#34;), Product(3300, &amp;#34;мельница для сыра&amp;#34;), Product(6500, &amp;#34;костюм картошки&amp;#34;), Product(9900, &amp;#34;беспилотная сова&amp;#34;), ] Магазин открылся, торговля идёт бойко, но есть проблемка. Покупатели донимают вопросом «у меня есть X рублей, какую самую дорогую дичь я могу купить за эту сумму?».
Френк очень плохо считает (неудивительно для голубя), поэтому требуется наша помощь.</description>
    </item>
    
    <item>
      <title>Python. Узнать день недели 40 лет назад</title>
      <link>https://antonz.ru/calendar/</link>
      <pubDate>Tue, 25 Jun 2019 13:15:00 +0000</pubDate>
      
      <guid>https://antonz.ru/calendar/</guid>
      <description>Есть в питоне модуль calendar. Лично я ожидал от него крутых фич по работе с датами, которые не влезли в datetime.
На деле он занимается форматированием календарей в HTML (именно то, что требуется в стандартной библиотеке любого языка) и предоставляет гениальные методы вроде itermonthdays, itermonthdays2, itermonthdays3 и itermonthdays4 (оцените богатство выбора, прямо как на воскресной ярмарке).
Но есть в нём и полезные функции. Например, узнать день недели для любой даты в прошлом или будущем:</description>
    </item>
    
    <item>
      <title>Python. Создать полный дубль коллекции</title>
      <link>https://antonz.ru/deepcopy/</link>
      <pubDate>Mon, 24 Jun 2019 17:02:00 +0000</pubDate>
      
      <guid>https://antonz.ru/deepcopy/</guid>
      <description>У нас ответственная миссия: запустить в космос автомобиль. Сначала подготовим инфраструктуру — собственно машину и мега-пушку:
from dataclasses import dataclass @dataclass class Car: brand: str model: str driver: str class SpaceCannon: def launch(self, cars): car = cars[0] print(f&amp;#34;{car.brand}{car.model}driven by {car.driver}sent to space!&amp;#34;) Проверим:
car = Car(brand=&amp;#34;Tesla&amp;#34;, model=&amp;#34;Roadster&amp;#34;, driver=&amp;#34;Starman&amp;#34;) cars = [car] cannon = SpaceCannon() cannon.launch(cars) Tesla Roadster driven by Starman sent to space! Работает!
Как всякий уважающий себя космический завод, наш умеет копировать машины.</description>
    </item>
    
    <item>
      <title>Python. Сегодня == сейчас</title>
      <link>https://antonz.ru/today-is-now/</link>
      <pubDate>Tue, 19 Feb 2019 12:32:15 +0000</pubDate>
      
      <guid>https://antonz.ru/today-is-now/</guid>
      <description>В каждом языке есть участки, которые не особо удались создателям. Для большинства языков, созданных до двухтысячных годов, камнем преткновения стала работа со временем.
Питон — не исключение. Возьмём функцию, которая сравнивает дату-время с точностью до минуты:
from datetime import datetime, timezone def equal(dt1, dt2): return dt1.replace(second=0, microsecond=0) == \ dt2.replace(second=0, microsecond=0) И сравним «сегодня» и «сейчас»:
&amp;gt;&amp;gt;&amp;gt; equal(datetime.today(), datetime.now()) True Оказывается, это одно и то же ツ Метод today() возвращает не начало дня, как можно было бы ожидать, а текущий момент времени.</description>
    </item>
    
    <item>
      <title>Python. Обработать заявки с учётом приоритетов</title>
      <link>https://antonz.ru/heapq/</link>
      <pubDate>Mon, 18 Feb 2019 13:35:18 +0000</pubDate>
      
      <guid>https://antonz.ru/heapq/</guid>
      <description>Если система обрабатывает заявки, редко бывает, что все они одинакового веса. Чаще встречаются разные приоритеты: клиенты бывают обычные и VIP, баги бывают минорные и критические, заказы бывают «до 1000 ₽» и «10000+ ₽».
Если приоритетов нет, обслуживать заявки просто: кто раньше пришёл, того раньше и обслужили (first in, first out — FIFO). С приоритетами сложнее: более важные заявки должны идти вперёд, но среди заявок с одинаковым приоритетом по-прежнему должен действовать принцип FIFO.</description>
    </item>
    
    <item>
      <title>Python. Выбрать топ-k элементов списка</title>
      <link>https://antonz.ru/heapq-nlargest/</link>
      <pubDate>Mon, 11 Feb 2019 10:32:16 +0000</pubDate>
      
      <guid>https://antonz.ru/heapq-nlargest/</guid>
      <description>Сегодня новое соревнование — граждане города выбирают самое наглое животное. Результаты опроса поступили в виде неупорядоченного списка пар «количество голосов — участник»:
contenders = [ (31, &amp;#34;индюк&amp;#34;), (22, &amp;#34;крыса&amp;#34;), (79, &amp;#34;кот&amp;#34;), (98, &amp;#34;голубь&amp;#34;), (13, &amp;#34;собака&amp;#34;), (95, &amp;#34;енот&amp;#34;), (15, &amp;#34;хомяк&amp;#34;), ] Осталось, как обычно, выбрать трёх победителей. Как насчёт такого:
&amp;gt;&amp;gt;&amp;gt; sorted(contenders)[-3:] [(79, &amp;#39;кот&amp;#39;), (95, &amp;#39;енот&amp;#39;), (98, &amp;#39;голубь&amp;#39;)] Неплохо. Но, как вы помните, сортировка списка занимает O(n log n) операций. Жирновато, чтобы просто выбрать топ-3 элемента.</description>
    </item>
    
    <item>
      <title>Python. Объединить отсортированные списки в один</title>
      <link>https://antonz.ru/heapq-merge/</link>
      <pubDate>Mon, 04 Feb 2019 10:26:00 +0000</pubDate>
      
      <guid>https://antonz.ru/heapq-merge/</guid>
      <description>Предположим, вы решили провести чемпионат мира по оглаживанию собак. Кто погладит больше всех шерстяных волчар за день, тот и победил. Участники не смогли собраться вместе, поэтому каждый город провёл независимое состязание и прислал результат:
washington = [ (99, &amp;#34;Френк&amp;#34;), (80, &amp;#34;Клер&amp;#34;), (73, &amp;#34;Зоя&amp;#34;) ] moscow = [ (90, &amp;#34;Валера&amp;#34;), (88, &amp;#34;Мария&amp;#34;), (50, &amp;#34;Анатолий&amp;#34;) ] beijing = [ (123, &amp;#34;Чан&amp;#34;), (109, &amp;#34;Пинг&amp;#34;), (70, &amp;#34;Ки&amp;#34;), ] Теперь ваша задача — выбрать трёх призёров.</description>
    </item>
    
    <item>
      <title>Python. Кортеж здорового человека</title>
      <link>https://antonz.ru/namedtuple/</link>
      <pubDate>Fri, 01 Feb 2019 11:52:24 +0000</pubDate>
      
      <guid>https://antonz.ru/namedtuple/</guid>
      <description>Эта статья — об одном из лучших изобретений Python: именованном кортеже (namedtuple). Мы рассмотрим его приятные особенности, от известных до неочевидных. Уровень погружения в тему будет нарастать постепенно, так что, надеюсь, каждый найдёт для себя что-то интересное. Поехали!
Введение Наверняка вы сталкивались с ситуацией, когда нужно передать несколько свойств объекта одним куском. Например, информацию о домашнем питомце: тип, кличка и возраст.
Часто создавать отдельный класс под это дело лень, и используют кортежи:</description>
    </item>
    
    <item>
      <title>Python. Из десятичной дроби — в обычную</title>
      <link>https://antonz.ru/float-as-integer-ratio/</link>
      <pubDate>Sat, 26 Jan 2019 15:42:48 +0000</pubDate>
      
      <guid>https://antonz.ru/float-as-integer-ratio/</guid>
      <description>У класса float есть прекрасный метод as_integer_ratio(), который представляет десятичную дробь в виде обычной — пары «числитель, знаменатель»:
&amp;gt;&amp;gt;&amp;gt; (0.25).as_integer_ratio() (1, 4) &amp;gt;&amp;gt;&amp;gt; (0.5).as_integer_ratio() (1, 2) &amp;gt;&amp;gt;&amp;gt; (0.75).as_integer_ratio() (3, 4) Так вот. Никогда им не пользуйтесь ツ Потому что:
&amp;gt;&amp;gt;&amp;gt; (0.2).as_integer_ratio() (3602879701896397, 18014398509481984) Виной всему стандарт представления дробных чисел IEEE 754, который реализует float.
Используйте Decimal:
&amp;gt;&amp;gt;&amp;gt; from decimal import Decimal &amp;gt;&amp;gt;&amp;gt; Decimal(&amp;quot;0.2&amp;quot;).as_integer_ratio() (1, 5) Уверен, вы и так это знаете.</description>
    </item>
    
    <item>
      <title>Python. Хранить последние N объектов</title>
      <link>https://antonz.ru/deque-maxlen/</link>
      <pubDate>Fri, 25 Jan 2019 09:06:58 +0000</pubDate>
      
      <guid>https://antonz.ru/deque-maxlen/</guid>
      <description>Допустим, вы пишете систему учёта посетителей для музея изящных искусств в Хиросиме (не спрашивайте). Одно из требований безопасников — команда tail, которая показывает трёх последних визитёров. Как её реализовать?
Конечно, можно складывать всех прибывших в список и по запросу выдавать из него последние 3 элемента:
TAIL_COUNT = 3 visitors = [] def handle(visitor): visitors.append(visitor) def tail(): return visitors[-TAIL_COUNT:] handle(&amp;quot;Питер&amp;quot;) handle(&amp;quot;Клер&amp;quot;) handle(&amp;quot;Френк&amp;quot;) handle(&amp;quot;Кен Чан&amp;quot;) handle(&amp;quot;Гоу Чан&amp;quot;) &amp;gt;&amp;gt;&amp;gt; visitors [&#39;Питер&#39;, &#39;Клер&#39;, &#39;Френк&#39;, &#39;Кен Чан&#39;, &#39;Гоу Чан&#39;] &amp;gt;&amp;gt;&amp;gt; tail() [&#39;Френк&#39;, &#39;Кен Чан&#39;, &#39;Гоу Чан&#39;] Но как-то не очень правильно хранить всех посетителей только ради того, чтобы показывать последних трёх, верно?</description>
    </item>
    
    <item>
      <title>Python. Подвох в функции sum()</title>
      <link>https://antonz.ru/sum-gotcha/</link>
      <pubDate>Mon, 21 Jan 2019 11:49:29 +0000</pubDate>
      
      <guid>https://antonz.ru/sum-gotcha/</guid>
      <description>Сидите вы на работе и смотрите на дневную статистику по заявкам разных типов:
monday = {&amp;quot;question&amp;quot;: 1, &amp;quot;problem&amp;quot;: 3, &amp;quot;idea&amp;quot;: 2} tuesday = {&amp;quot;problem&amp;quot;: 5, &amp;quot;idea&amp;quot;: 1} wednesday = {&amp;quot;question&amp;quot;: 2, &amp;quot;problem&amp;quot;: 2} Задача — посчитать агрегированную статистику за все дни. Всё вроде понятно. Тут подходит тимлид и говорит, что если решите задачу однострочником, он подарит вам жёлтую резиновую уточку.
Устоять перед этим решительно невозможно.
     Словари → счётчики Сначала от словарей надо перейти к счётчикам.</description>
    </item>
    
    <item>
      <title>Python. Операции со статистикой</title>
      <link>https://antonz.ru/collections-counter-sum/</link>
      <pubDate>Sat, 19 Jan 2019 08:39:13 +0000</pubDate>
      
      <guid>https://antonz.ru/collections-counter-sum/</guid>
      <description>Вернёмся к примеру со статистикой по заявкам разных типов. Вот данные о вопросах, проблемах и идеях за три дня:
monday = {&amp;quot;question&amp;quot;: 1, &amp;quot;problem&amp;quot;: 3, &amp;quot;idea&amp;quot;: 2} tuesday = {&amp;quot;problem&amp;quot;: 5, &amp;quot;idea&amp;quot;: 1} wednesday = {&amp;quot;question&amp;quot;: 2, &amp;quot;problem&amp;quot;: 2} Как бы посчитать агрегированную статистику? Можно так, конечно:
def add_day(day_stats, stats): for key, value in day_stats.items(): stats[key] += value return stats stats = {&amp;quot;question&amp;quot;: 0, &amp;quot;problem&amp;quot;: 0, &amp;quot;idea&amp;quot;: 0} stats = add_day(monday, stats) stats = add_day(tuesday, stats) stats = add_day(wednesday, stats) stats {&#39;question&#39;: 3, &#39;problem&#39;: 10, &#39;idea&#39;: 3} Но вы наверняка догадываетесь, что это не наш метод.</description>
    </item>
    
    <item>
      <title>Python. Посчитать количество объектов каждого типа</title>
      <link>https://antonz.ru/collections-counter/</link>
      <pubDate>Wed, 09 Jan 2019 13:17:14 +0000</pubDate>
      
      <guid>https://antonz.ru/collections-counter/</guid>
      <description>Допустим, вы пишете программу, которая обрабатывает заявки разных типов — идеи, вопросы и проблемы:
from collections import namedtuple Request = namedtuple(&amp;quot;Request&amp;quot;, (&amp;quot;type&amp;quot;, &amp;quot;text&amp;quot;)) requests = [ Request(type=&amp;quot;question&amp;quot;, text=&amp;quot;Как пасти котов?&amp;quot;), Request(type=&amp;quot;problem&amp;quot;, text=&amp;quot;Бакланы портят стадион&amp;quot;), Request(type=&amp;quot;idea&amp;quot;, text=&amp;quot;Переводчик с лисьего на русский&amp;quot;), Request(type=&amp;quot;problem&amp;quot;, text=&amp;quot;Кот крадёт электричество&amp;quot;), Request(type=&amp;quot;problem&amp;quot;, text=&amp;quot;Мыши похитили 540 кг марихуаны&amp;quot;), Request(type=&amp;quot;idea&amp;quot;, text=&amp;quot;Холодильник с таймером&amp;quot;), ] Предположим, требуется посчитать количество заявок каждого типа. Если в прошлой жизни человек писал на джаваскрипте, код может получиться таким:</description>
    </item>
    
    <item>
      <title>Python. Умолчательные значения настроек</title>
      <link>https://antonz.ru/collections-chainmap/</link>
      <pubDate>Tue, 08 Jan 2019 12:30:01 +0000</pubDate>
      
      <guid>https://antonz.ru/collections-chainmap/</guid>
      <description>Если в программе есть настройки, хорошо предусмотреть для них умолчательные значения. Так всё будет работать «из коробки», а в конфиг полезут только те, кому это действительно надо.
Допустим, настройки по умолчанию мы сложили в словарь:
DEFAULTS = { &amp;quot;name&amp;quot;: &amp;quot;Frank&amp;quot;, &amp;quot;species&amp;quot;: &amp;quot;pigeon&amp;quot;, &amp;quot;age&amp;quot;: 42, } А пользовательские настройки лежат в settings.ini. Их можно считать функцией load_settings(), которая тоже возвращает словарь.
Вопрос: как получить актуальное значение того или иного свойства?
Так себе способ:</description>
    </item>
    
    <item>
      <title>Python. Enum здорового человека</title>
      <link>https://antonz.ru/enum/</link>
      <pubDate>Fri, 04 Jan 2019 15:31:45 +0000</pubDate>
      
      <guid>https://antonz.ru/enum/</guid>
      <description>Если программист привык писать код, как это делали наши пращуры со времён аграрной революции, то перечисления у него выглядят как-то так:
class PigeonState: eating = 0 sleeping = 1 flying = 2 PigeonState.sleeping 1 Конечно, у наших современников есть способ получше — enum.Enum:
import enum class PigeonState(enum.Enum): eating = 0 sleeping = 1 flying = 2 PigeonState.sleeping.value 1 Это не просто более многословный способ сделать то же самое. У енумов есть вагон плюшек, недоступных староверам.</description>
    </item>
    
    <item>
      <title>Python. Исходники стандартной библиотеки</title>
      <link>https://antonz.ru/python-sources/</link>
      <pubDate>Thu, 03 Jan 2019 12:34:26 +0000</pubDate>
      
      <guid>https://antonz.ru/python-sources/</guid>
      <description>У большинства питонячих модулей хорошее описание: написано доходчиво, часто есть примеры. Но ничто не заменит исходного кода, если что-то непонятно или хочется понять, как та или иная штука реализована.
Core-разработчик Питона Реймонд Хеттингер тоже это заметил, и поэтому в документации к каждому модулю стандартной библиотеки первым делом идёт ссылка на исходники этого самого модуля на гитхабе.
 Модуль fnmatch — «лайтовая» альтернатива регулярным выраженияем. Хотите узнать, как он проверяет строки по паттернам?</description>
    </item>
    
    <item>
      <title>Чистый код. Единообразие в именах</title>
      <link>https://antonz.ru/naming-consistency/</link>
      <pubDate>Thu, 13 Dec 2018 13:23:31 +0000</pubDate>
      
      <guid>https://antonz.ru/naming-consistency/</guid>
      <description>Всякая книга про хороший код начинается с главы об именах переменных и функций. Но каждый, кто работал с большим проектом, знает — хороших имён недостаточно. Важно ещё, чтобы они были единообразными во всём проекте.
Посмотрим на питоновский модуль difflib, который помогал нам сравнивать строки:
 find_longest_match() находит самый длинный совпадающий кусок между двуми последовательностями и возвращает match — объект с совпадением и дополнительной информацией. get_matching_blocks() находит все совпадения между двумя последовательностями и возвращает список из match.</description>
    </item>
    
    <item>
      <title>Python. Шаблонизатор для бедных</title>
      <link>https://antonz.ru/string-template/</link>
      <pubDate>Wed, 12 Dec 2018 15:32:00 +0000</pubDate>
      
      <guid>https://antonz.ru/string-template/</guid>
      <description>Мантра «There should be one — and preferably only one — obvious way to do it» из Zen of Python далека от реальности.
Все мы знаем, что в Питоне за долгие годы собрали аж три способа подстановки переменных в строку:
who = &amp;quot;Голубь Френк&amp;quot; &amp;quot;%s постучался в стеклянные двери&amp;quot; % who &amp;quot;{} постучался в стеклянные двери&amp;quot;.format(who) f&amp;quot;{who} постучался в стеклянные двери&amp;quot; Но не все знают, что есть ещё и четвёртый способ — string.</description>
    </item>
    
    <item>
      <title>Python. Разбить строку на слова с учётом кавычек</title>
      <link>https://antonz.ru/shlex-split/</link>
      <pubDate>Fri, 07 Dec 2018 15:55:00 +0000</pubDate>
      
      <guid>https://antonz.ru/shlex-split/</guid>
      <description>Предположим, вы собираете архив статей, и хотите для каждой автоматически определять теги — по ним можно будет моментально найти статью в архиве. В качестве тегов решили брать топ-3 слова из текста.
Например, такая статья:
text = &amp;quot;&amp;quot;&amp;quot;Голубь Френк прибыл в отель &amp;quot;Четыре сезона&amp;quot; с дружеским визитом. По сообщениям очевидцев, он сожрал в ресторане киноа прямо из тарелки гостя, а затем клюнул в глаз прибежавшего на шум официанта. Френк прилетает в &amp;quot;Четыре сезона&amp;quot; каждый год.</description>
    </item>
    
    <item>
      <title>Чистый код. Похожие названия методов</title>
      <link>https://antonz.ru/real-quick-ratio/</link>
      <pubDate>Thu, 06 Dec 2018 15:54:00 +0000</pubDate>
      
      <guid>https://antonz.ru/real-quick-ratio/</guid>
      <description>На днях мы использовали метод SequenceMatcher.ratio() из модуля difflib, чтобы оценить сходство двух строк.
А что бы вы сказали, если узнали, что у того же класса есть ещё методы quick_ratio() и real_quick_ratio()? С описанием «возвращает верхнюю границу ratio довольно быстро» и «возвращает верхнюю границу ratio очень быстро»?
Я бы сказал, что это говнокод. Если бы коллега принёс такой код на ревью, я бы предложил подумать ещё ツ Либо ты нормально называешь эти методы, чтобы понятно было, когда какой использовать.</description>
    </item>
    
    <item>
      <title>Python. Кратко напечатать развесистую структуру</title>
      <link>https://antonz.ru/pprint-depth/</link>
      <pubDate>Tue, 04 Dec 2018 15:46:00 +0000</pubDate>
      
      <guid>https://antonz.ru/pprint-depth/</guid>
      <description>Наверняка вы знаете про функции pprint.pprint() и pprint.pformat(), которые красиво форматируют разные коллекции и словари.
У них есть замечательный опциональный параметр depth, который ограничивает уровень вложенности при форматировании. Он здорово помогает, если хочется получить общее представление о данных, не сильно вникая в детали.
Например, запросили вы апишечку и получили в ответ развесистый словарь:
rating = requests.get(&amp;quot;https://www.cia.gov/the-world-factbook/top-dumbest-animals&amp;quot;).json() Заглянем в него, не погружаясь в детали:
import pprint pprint.pprint(rating, depth=3) {&#39;leaderbord&#39;: [ {&#39;details&#39;: {.</description>
    </item>
    
    <item>
      <title>Python. Сравнить строки на похожесть</title>
      <link>https://antonz.ru/difflib-ratio/</link>
      <pubDate>Mon, 03 Dec 2018 12:06:00 +0000</pubDate>
      
      <guid>https://antonz.ru/difflib-ratio/</guid>
      <description>Помните ваш стартап с самыми актуальными новостями дня? Кажется, у него появился конкурент — он нагло крадёт ваши аутентичные новости, рерайтит их, и рассылает ничего не подозревающим клиентам, подрывая вашу репутацию.
Судите сами, вот ваши новости:
genuine = [ &amp;quot;«Братец-хлеб» из Китая носит плащ и корону из булочек, чтобы кормить чаек&amp;quot;, &amp;quot;Мясо гигантских тараканов станет вкусной и недорогой альтернативой говядине&amp;quot;, &amp;quot;Скандал в ботаническом саду: 10 миллионов рублей ушло на зарплату кактусам&amp;quot;, ] А вот новости жалкого подражателя:</description>
    </item>
    
    <item>
      <title>Python. Простое сравнение с шаблоном</title>
      <link>https://antonz.ru/fnmatch/</link>
      <pubDate>Sun, 02 Dec 2018 18:05:00 +0000</pubDate>
      
      <guid>https://antonz.ru/fnmatch/</guid>
      <description>Для проверки строки по шаблону обычно используют регулярные выражения и модуль re. Но иногда хочется что-нибудь попроще, пусть и не такое мощное — вроде like в SQL.
Сравнить строку или список с шаблоном поможет модуль fnmatch:
import fnmatch journal = [ &amp;quot;10:00 Начался обычный день в омской ветклинике&amp;quot;, &amp;quot;10:30 Голубь Френк постучался в стеклянные двери&amp;quot;, &amp;quot;10:50 Лисица Клер поскреблась в окно&amp;quot;, &amp;quot;11:10 Попугай Питер проник через вентиляцию&amp;quot;, &amp;quot;11:11 Клер попыталась сожрать Френка и Питера&amp;quot;, &amp;quot;11:25 Осьминог Пауль всплыл в мужском туалете&amp;quot;, ] fnmatch.</description>
    </item>
    
    <item>
      <title>Python. Все слова с прописной буквы</title>
      <link>https://antonz.ru/string-capwords/</link>
      <pubDate>Fri, 30 Nov 2018 16:01:00 +0000</pubDate>
      
      <guid>https://antonz.ru/string-capwords/</guid>
      <description>Допустим, запустили вы стартап. В автоматическом режиме собираете самые упоротые новости русскоязычных СМИ, вот такие:
 Кот из Новокузнецка признан виновным в потопе
 Автоматически же переводите их на английский, вот так:
 Cat from Novokuznetsk found guilty in the flood
 И ежедневно рассылаете подписчикам по всему миру.
Всё хорошо, но знакомый эксперт из МГИМО подсказывает: в английском принято каждое слово в заголовке начинать с заглавной буквы. А у вас-то не так!</description>
    </item>
    
    <item>
      <title>Python. Отформатировать текст для консоли</title>
      <link>https://antonz.ru/textwrap-fill/</link>
      <pubDate>Thu, 29 Nov 2018 14:45:00 +0000</pubDate>
      
      <guid>https://antonz.ru/textwrap-fill/</guid>
      <description>Если любите делать CLI-утилиты, модуль textwrap наверняка вам понравится.
Он умеет перформатировать многострочный текст, чтобы длина строки не превышала N символов:
text = &amp;quot;Около двух месяцев назад породистый голубь по имени Френк постучался в стеклянные двери омской ветеринарной клиники&amp;quot; formatted = textwrap.fill(text, width=20) print(formatted) Около двух месяцев назад породистый голубь по имени Френк постучался в стеклянные двери Или добавить отступ, например для цитаты:
import textwrap inspirational = &amp;quot;Цитаты простых людей:&amp;quot; quote = &amp;quot;Откройте окно вообще дышать невозможно&amp;quot; quote = textwrap.</description>
    </item>
    
    <item>
      <title>Python. Сделать превьюшку длинного текста</title>
      <link>https://antonz.ru/textwrap-shorten/</link>
      <pubDate>Wed, 28 Nov 2018 17:46:00 +0000</pubDate>
      
      <guid>https://antonz.ru/textwrap-shorten/</guid>
      <description>Допустим, мы хотим получить превьюшку длинной статьи. Можно обрезать механически:
article = &amp;quot;Около двух месяцев назад породистый голубь по имени Френк постучался в стеклянные двери омской ветеринарной клиники&amp;quot; article[:30] &#39;Около двух месяцев назад пород&#39; Фраза оборвана посреди слова — это неуважение к читателю и к Френку.
А можно воспользоваться функцией textwrap.shorten():
import textwrap textwrap.shorten(article, 30, placeholder=&amp;quot;...&amp;quot;) &#39;Около двух месяцев назад...&#39; Намного лучше!
Заметка из телеграм-канала  «Oh My Py»
  </description>
    </item>
    
    <item>
      <title>Oh My Py — всё о стандартной библиотеке Python</title>
      <link>https://antonz.ru/ohmypy/</link>
      <pubDate>Wed, 28 Nov 2018 16:21:00 +0000</pubDate>
      
      <guid>https://antonz.ru/ohmypy/</guid>
      <description>Давно хотел подписаться на интересный канал по Питону, но не нашёл такого и решил завести свой ツ Встречайте Oh My Py — канал про тайные возможности стандартной библиотеки Питона.
Тайные не потому, что кто-то их скрывает, конечно. Просто стандартная библиотека огромная! А разработчики часто не копают глубоко и изобретают велосипед вместо того, чтобы использовать готовое.
Заодно обсудим полезные и не самые известные приёмы в работе с языком и структурами данных. А ещё особенности дизайна и говнокод в стандартной библиотеке (да, встречается и такое).</description>
    </item>
    
  </channel>
</rss>
