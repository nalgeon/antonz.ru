<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>пакетик on Антон Жиянов</title><link>https://antonz.ru/tags/package/</link><description>Recent content in пакетик on Антон Жиянов</description><generator>Hugo -- gohugo.io</generator><language>ru-ru</language><lastBuildDate>Sat, 19 Jun 2021 17:24:59 +0000</lastBuildDate><atom:link href="https://antonz.ru/tags/package/index.xml" rel="self" type="application/rss+xml"/><item><title>Разбор текста по шаблону на Python</title><link>https://antonz.ru/parse/</link><pubDate>Sat, 19 Jun 2021 17:24:59 +0000</pubDate><guid>https://antonz.ru/parse/</guid><description>Все знают, как в питоне форматировать текст по шаблону:
import datetime as dt date = dt.date(2020, 11, 20) who = &amp;#34;Френк&amp;#34; count = 42 tmpl = &amp;#34;{:%Y-%m-%d}: {}и его {:d}друга вылетели в Копенгаген&amp;#34; &amp;gt;&amp;gt;&amp;gt; tmpl.format(date, who, count) &amp;#39;2020-11-20: Френк и его 42 друга вылетели в Копенгаген&amp;#39; А благодаря библиотеке parse от Ричарда Джонса, с такой же легкостью можно разбирать текст обратно по переменным:
import parse tmpl = &amp;#34;{:ti}: {}и его {:d}друга вылетели в Копенгаген&amp;#34; txt = &amp;#34;2020-11-20: Френк и его 42 друга вылетели в Копенгаген&amp;#34; &amp;gt;&amp;gt;&amp;gt; date, who, count = parse.</description></item><item><title>Современный HTTP-клиент для Python</title><link>https://antonz.ru/httpx/</link><pubDate>Sat, 12 Jun 2021 17:21:00 +0000</pubDate><guid>https://antonz.ru/httpx/</guid><description>Мало у какого языка такая нажористая стандартная библиотека, как у питона. Но все равно для работы с HTTP люди пользуются сторонним пакетом requests.
А я вот отказался от него в пользу замечательного httpx от Тома Кристи. Синхронный и асинхронный интерфейсы, поддержка wsgi/asgi, плюс все фичи requests — и совместимость с ним!
Можно заменить requests → httpx, и все продолжит работать:
&amp;gt;&amp;gt;&amp;gt; import httpx &amp;gt;&amp;gt;&amp;gt; r = httpx.get(&amp;quot;http://httpbingo.org/json&amp;quot;) &amp;gt;&amp;gt;&amp;gt; r.status_code 200 &amp;gt;&amp;gt;&amp;gt; r.</description></item><item><title>Универсальные оповещения на Python</title><link>https://antonz.ru/notifiers/</link><pubDate>Sat, 05 Jun 2021 15:00:00 +0000</pubDate><guid>https://antonz.ru/notifiers/</guid><description>Есть куча способов отправлять уведомления — от проверенного SMTP и удобного Telegram до смс и специальных приложений для мобилок вроде Pushover.
Обычно для этого используют 3rd-party библиотеку соответствующего провайдера. Но есть более удобный способ — пакет notifiers от Ора Карми. Он предоставляет простой универсальный интерфейс для отправки сообщений через любой сервис.
Например, через телеграм:
import notifiers token = &amp;#34;bot_token&amp;#34; chat_id = 1234 tg = notifiers.get_notifier(&amp;#34;telegram&amp;#34;) tg.notify(message=&amp;#34;Привет!&amp;#34;, token=token, chat_id=chat_id) Поддерживается аж 16 провайдеров, а интерфейс один — метод .</description></item><item><title>Счетчик для огромных коллекций на Python</title><link>https://antonz.ru/bounter/</link><pubDate>Sun, 30 May 2021 08:34:00 +0000</pubDate><guid>https://antonz.ru/bounter/</guid><description>В стандартной библиотеке есть класс Counter. Он отлично подходит, чтобы считать количество объектов разных типов. Но что делать, если объектов миллиарды, и счетчик просто не помещается в оперативную память?
Поможет bounter — это счетчик, который предоставляет схожий интерфейс, но внутри построен на вероятностных структурах данных. За счет этого он занимает в 30–250 раз меньше памяти, но может (слегка) привирать.
from bounter import bounter counts = bounter(size_mb=128) counts.update([&amp;#34;a&amp;#34;, &amp;#34;b&amp;#34;, &amp;#34;c&amp;#34;, &amp;#34;a&amp;#34;, &amp;#34;b&amp;#34;]) &amp;gt;&amp;gt;&amp;gt; counts.</description></item><item><title>Планировщик задач на Python</title><link>https://antonz.ru/schedule/</link><pubDate>Sat, 22 May 2021 08:31:00 +0000</pubDate><guid>https://antonz.ru/schedule/</guid><description>В стандартной библотеке есть встроенный планировщик задач (а чего вообще в ней нет?). Подробно расскажу в другой раз, но в целом он, скажем так, не слишком юзер-френдли.
Поэтому Дэн Бэйдер сделал schedule — «планировщик для людей». Смотрите, какой милый:
import schedule import time def job(): print(&amp;#34;I&amp;#39;m working...&amp;#34;) schedule.every().hour.do(job) schedule.every(5).to(10).minutes.do(job) schedule.every().day.at(&amp;#34;10:30&amp;#34;).do(job) while True: schedule.run_pending() time.sleep(1) Ноль зависимостей, чистый и великолепно документированный код, примеры на все случаи жизни.</description></item><item><title>Естественная сортировка на Python</title><link>https://antonz.ru/natsort/</link><pubDate>Sat, 15 May 2021 08:28:00 +0000</pubDate><guid>https://antonz.ru/natsort/</guid><description>Это #пакетик — еженедельная рубрика о полезных и интересных пакетах на Python.
Мой сегодняшний выбор — пакет Сета Мортона natsort, который сортирует строки привычным для человека образом.
Допустим, у нас есть список важных гостей. Он в легком беспорядке:
data = [ &amp;#34;4 - Дуглас&amp;#34;, &amp;#34;2 - Клер&amp;#34;, &amp;#34;11 - Зоя&amp;#34;, &amp;#34;1 - Френк&amp;#34;, &amp;#34;31 - Питер&amp;#34;, ] Отсортируем:
&amp;gt;&amp;gt;&amp;gt; sorted(data) [&amp;#39;1 - Френк&amp;#39;, &amp;#39;11 - Зоя&amp;#39;, &amp;#39;2 - Клер&amp;#39;, &amp;#39;31 - Питер&amp;#39;, &amp;#39;4 - Дуглас&amp;#39;] Порядка не прибавилось ツ А вот как будет с natsort:</description></item></channel></rss>