<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>разработка on Антон Жиянов</title>
    <link>https://antonz.ru/tags/development/</link>
    <description>Recent content in разработка on Антон Жиянов</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ru-ru</language>
    <lastBuildDate>Sun, 26 Sep 2021 09:36:07 +0000</lastBuildDate><atom:link href="https://antonz.ru/tags/development/rss" rel="self" type="application/rss+xml" />
    <item>
      <title>Как хранят данные в браузере</title>
      <link>https://antonz.ru/browser-storage/</link>
      <pubDate>Sun, 26 Sep 2021 09:36:07 +0000</pubDate>
      
      <guid>https://antonz.ru/browser-storage/</guid>
      <description>Поговорим о том, как люди хранили данные в браузере, от мохнатой древности до нашего времени.
1. Куки Первые инженеры, едва переодевшись из шкур в неопрятные свитера, попытались использовать родной и привычный HTTP-протокол. Проблема в том, что он не хранит состояние (stateless) — пять запросов от Алисы выглядят точно так же, как пять запросов от пяти разных людей.
Что же делать? В любой непонятной ситуации придумывай костыль! Так появились куки (cookie). Это пары строк (ключ — значение), которые браузер гоняет на сервер с каждым запросом.</description>
    </item>
    
    <item>
      <title>Главный критерий хорошего кода</title>
      <link>https://antonz.ru/good-code/</link>
      <pubDate>Wed, 02 Jun 2021 07:27:39 +0000</pubDate>
      
      <guid>https://antonz.ru/good-code/</guid>
      <description>Хороший код — понятный и непрожорливый до ресурсов. Давайте поговорим об этом.
Время на понимание Главный критерий хорошего кода — это время T, которое требуется не-автору, чтобы разобраться в коде. Причем разобраться не на уровне «вроде понятно», а достаточно хорошо, чтобы внести изменения и ничего не сломать.
Чем меньше T, тем лучше код.
Допустим, Нина и Витя реализовали одну и ту же фичу, а вы хотите ее доработать. Если разберетесь в коде Нины за 10 минут, а в коде Вити за 30 минут — код Нины лучше.</description>
    </item>
    
    <item>
      <title>Второй язык для питониста</title>
      <link>https://antonz.ru/python-plus-one/</link>
      <pubDate>Sun, 09 May 2021 12:15:13 +0000</pubDate>
      
      <guid>https://antonz.ru/python-plus-one/</guid>
      <description>Если вы давно и хорошо знаете питон, некоторые моменты в нем могут напрягать. Например, необходимость начинать каждый новый проект с создания виртуального окружения и установки пачки тулов вроде black, pylint и pytest. Или отсутствующий рефакторинг и частые ошибки из-за динамической типизации. Или убоговатая асинхронность и костыль в виде GIL.
Если у вас так — возможно, пора освоить второй язык. Логично выбрать вариант без питонячих недостатков: статически типизированный, с готовым тулингом, продуманной асинхронностью и параллелизмом.</description>
    </item>
    
    <item>
      <title>​Шпаргалки как альтернатива man</title>
      <link>https://antonz.ru/cheat-sh/</link>
      <pubDate>Fri, 23 Apr 2021 10:46:01 +0000</pubDate>
      
      <guid>https://antonz.ru/cheat-sh/</guid>
      <description>Я вечно забываю синтаксис линуксовых утилит вроде grep, sed и find. Есть команда man, которая показывает документацию по утилите, но для меня она совершенно бесполезна — никогда не получается найти то, что нужно (возможно, это только я такой тупой).
Поэтому был бесконечно счастлив, когда на днях нашел приятную альтернативу от Игоря Чубина — «шпаргалки» с конкретными примерами. Чтобы их включить, достаточно добавить такую функцию в .bashrc:
function cht() { curl &amp;quot;cht.</description>
    </item>
    
    <item>
      <title>Собираем открытые данные с GitHub Actions</title>
      <link>https://antonz.ru/github-actions-scraping/</link>
      <pubDate>Fri, 12 Mar 2021 14:12:59 +0000</pubDate>
      
      <guid>https://antonz.ru/github-actions-scraping/</guid>
      <description>GitHub Actions чаще всего используют для сборки и тестов, но вообще сервис подходит для любой автоматизации.
В этой заметке я расскажу:
 как собрать данные из API, опубликовать датасет на гитхабе, и автоматически актуализировать.  В результате получится идеальный инструмент для сбора и публикации открытых данных.
Будем работать с API станций метро, которое предоставляет HeadHunter. Я буду приводить фрагменты конфига для GitHub Actions, а в конце дам ссылку на готовый репозиторий.</description>
    </item>
    
    <item>
      <title>Простое против легкого</title>
      <link>https://antonz.ru/simple-made-easy/</link>
      <pubDate>Fri, 26 Feb 2021 12:55:15 +0000</pubDate>
      
      <guid>https://antonz.ru/simple-made-easy/</guid>
      <description>9 лет назад в докладе «Simple Made Easy» Рич Хикки рассказал о разнице между простым (simple) и легким (easy) в разработке софта. Стремление к простым программам (в противоположность легким) — самый важный, наверное, принцип разработки. И при этом совершенно непопулярный.
 Simple — это о внутреннем устройстве программы, ее архитектуре. У простых программ мало внутренних зависимостей, движущихся частей, настроек. Антипод простой программы — сложная. Простая программа или сложная — это объективная характеристика.</description>
    </item>
    
    <item>
      <title>Кросс-платформенная сборка с GitHub Actions</title>
      <link>https://antonz.ru/github-actions/</link>
      <pubDate>Thu, 11 Feb 2021 13:34:09 +0000</pubDate>
      
      <guid>https://antonz.ru/github-actions/</guid>
      <description>Если проект живет на GitHub, можно за десять минут настроить авто-сборку под основные операционные системы — Windows, Linux и macOS.
Раньше для сборки почти всегда использовали Travis CI, многие по инерции и сейчас так делают. Но есть способ лучше — GitHub Actions.
GitHub Actions — невероятно мощный бесплатный сервис автоматизации любых задач. Грубо говоря, вы выполняете свой код на серверах Гитхаба и делаете там все, что заблагорассудится. Звучит диковато, но открывает бездну возможностей.</description>
    </item>
    
    <item>
      <title>Плохая и хорошая документация языка</title>
      <link>https://antonz.ru/language-doc/</link>
      <pubDate>Mon, 06 Jul 2020 09:08:48 +0000</pubDate>
      
      <guid>https://antonz.ru/language-doc/</guid>
      <description>Язык Go не отличается красотой. Кто-то называет его «намеренно простым», кто-то уродливым. Но с чем у Go действительно всё классно — так это с документацией. Там много хорошего, но вот главное, на мой взгляд:
 A Tour of Go — интерактивное введение в язык. Effective Go — книга о том, как писать идиоматичный код на Go. Ссылки из документации на исходники каждой функции стандартной библиотеки (например, Max).  Для сравнения я взял топ-10 языков из StackOverflow Developer Survey и посмотрел, как у них дела с этими тремя пунктами.</description>
    </item>
    
    <item>
      <title>Красавица и чудовище. Обработка ошибок в Go</title>
      <link>https://antonz.ru/go-errors/</link>
      <pubDate>Thu, 04 Jun 2020 14:11:07 +0000</pubDate>
      
      <guid>https://antonz.ru/go-errors/</guid>
      <description>Роб Пайк сказал об ошибках в го:
 Explicit error checking forces the programmer to think about errors — and deal with them — when they arise.
 Это правда. Но не вся.
Допустим, я хочу прочитать список целых чисел из текстового файла. Вот как можно сделать это на питоне:
def read_numbers(filename): return [int(line.strip()) for line in open(filename)] Или, в более процедурном стиле:
def read_numbers(filename): numbers = [] for line in open(filename): num = int(line.</description>
    </item>
    
    <item>
      <title>Как сделать классный Python-пакет</title>
      <link>https://antonz.ru/packaging/</link>
      <pubDate>Fri, 15 May 2020 07:58:16 +0000</pubDate>
      
      <guid>https://antonz.ru/packaging/</guid>
      <description>Версия от апреля 2021 года
Бывает, напишешь какую-нибудь полезную утилиту на питоне, и хочется поделиться ей с коллегами. Лучший способ для этого — сделать пакет (package): он устанавливается одной командой и спасает от копипасты.
Если вы, как и я раньше, думаете, что создание пакетов в питоне — большая головная боль, то знайте, что это не так. Чтобы не быть голословным, я сделал это пошаговое руководство. Три основных шага и несколько вспомогательных, со ссылками на гитхаб.</description>
    </item>
    
    <item>
      <title>Автоматизация задач в Python-проекте</title>
      <link>https://antonz.ru/makefile/</link>
      <pubDate>Tue, 05 May 2020 15:16:48 +0000</pubDate>
      
      <guid>https://antonz.ru/makefile/</guid>
      <description>Когда разрабатываешь библиотеку или приложение, всегда найдутся задачи, которые выполняешь изо дня в день:
 проверить код линтерами, прогнать тесты с замером покрытия, запустить в докере, &amp;hellip;  JS-разработчикам повезло (ха): у них в package.json есть специальная секция scripts для таких штук:
{ ... &amp;quot;scripts&amp;quot;: { &amp;quot;format&amp;quot;: &amp;quot;prettier --write \&amp;quot;src/**/*.ts\&amp;quot;&amp;quot;, &amp;quot;lint&amp;quot;: &amp;quot;tslint -p tsconfig.json&amp;quot;, &amp;quot;test&amp;quot;: &amp;quot;jest --coverage --config jestconfig.json&amp;quot;, }, ... } Для Питона ничего подобного не предусмотрено. Можно, конечно, сделать по sh-скрипту на каждую задачу, но это замусоривает каталог проекта, да и хотелось бы все такие задачи держать вместе.</description>
    </item>
    
    <item>
      <title>Юлия → Iuliia. Всё о транслитерации</title>
      <link>https://antonz.ru/iuliia/</link>
      <pubDate>Wed, 29 Apr 2020 08:15:40 +0000</pubDate>
      
      <guid>https://antonz.ru/iuliia/</guid>
      <description>Транслитерация — это запись кириллических слов латиницей (Анна → Anna, Самара → Samara). Её используют в загранпаспортах, водительских удостоверениях, трансграничной доставке, библиотечных каталогах и множестве других международных процессов.
Так вышло, что я недавно окунулся в эту тему, а в Википедии она раскрыта слабо. Поэтому расскажу, что к чему (спойлер — если вы думаете, что с транслитерацией всё плохо, то на самом деле всё ещё хуже).
Кто виноват Транслит — это хрестоматийная ситуация «у нас 14 плохих стандартов, давайте придумаем ещё один».</description>
    </item>
    
    <item>
      <title>Быстрый язык ≠ быстрый код</title>
      <link>https://antonz.ru/fast-language/</link>
      <pubDate>Mon, 01 Jul 2019 08:15:04 +0000</pubDate>
      
      <guid>https://antonz.ru/fast-language/</guid>
      <description>Получил такой комментарий на заметку про быстрый и медленный алгоритмы:
 Мне кажется, тут не совсем корректное сравнение. sorted оптимизированная и написана на С, в то время как insort — просто питоновская функция. Она гоняет питоновские структурки и при любом раскладе будет работать медленно.
 Это вообще популярная точка зрения, что если что-то написано на «быстром» языке, то оно уж всяко будет быстрее, чем написанное на «медленном».
Конечно же, это не так.</description>
    </item>
    
    <item>
      <title>Чистый код. Единообразие в именах</title>
      <link>https://antonz.ru/naming-consistency/</link>
      <pubDate>Thu, 13 Dec 2018 13:23:31 +0000</pubDate>
      
      <guid>https://antonz.ru/naming-consistency/</guid>
      <description>Всякая книга про хороший код начинается с главы об именах переменных и функций. Но каждый, кто работал с большим проектом, знает — хороших имён недостаточно. Важно ещё, чтобы они были единообразными во всём проекте.
Посмотрим на питоновский модуль difflib, который помогал нам сравнивать строки:
 find_longest_match() находит самый длинный совпадающий кусок между двуми последовательностями и возвращает match — объект с совпадением и дополнительной информацией. get_matching_blocks() находит все совпадения между двумя последовательностями и возвращает список из match.</description>
    </item>
    
    <item>
      <title>Чистый код. Похожие названия методов</title>
      <link>https://antonz.ru/real-quick-ratio/</link>
      <pubDate>Thu, 06 Dec 2018 15:54:00 +0000</pubDate>
      
      <guid>https://antonz.ru/real-quick-ratio/</guid>
      <description>На днях мы использовали метод SequenceMatcher.ratio() из модуля difflib, чтобы оценить сходство двух строк.
А что бы вы сказали, если узнали, что у того же класса есть ещё методы quick_ratio() и real_quick_ratio()? С описанием «возвращает верхнюю границу ratio довольно быстро» и «возвращает верхнюю границу ratio очень быстро»?
Я бы сказал, что это говнокод. Если бы коллега принёс такой код на ревью, я бы предложил подумать ещё ツ Либо ты нормально называешь эти методы, чтобы понятно было, когда какой использовать.</description>
    </item>
    
    <item>
      <title>Oh My Py — всё о стандартной библиотеке Python</title>
      <link>https://antonz.ru/ohmypy/</link>
      <pubDate>Wed, 28 Nov 2018 16:21:00 +0000</pubDate>
      
      <guid>https://antonz.ru/ohmypy/</guid>
      <description>Давно хотел подписаться на интересный канал по Питону, но не нашёл такого и решил завести свой ツ Встречайте Oh My Py — канал про тайные возможности стандартной библиотеки Питона.
Тайные не потому, что кто-то их скрывает, конечно. Просто стандартная библиотека огромная! А разработчики часто не копают глубоко и изобретают велосипед вместо того, чтобы использовать готовое.
Заодно обсудим полезные и не самые известные приёмы в работе с языком и структурами данных. А ещё особенности дизайна и говнокод в стандартной библиотеке (да, встречается и такое).</description>
    </item>
    
    <item>
      <title>Тестировщики не должны находить баги</title>
      <link>https://antonz.ru/testers-should-not-find-bugs/</link>
      <pubDate>Tue, 20 Nov 2018 16:21:00 +0000</pubDate>
      
      <guid>https://antonz.ru/testers-should-not-find-bugs/</guid>
      <description>Читаю сейчас книгу Мартина о правильных программистах. Вообще, Мартин весёлый дядька — обожает категоричные утверждения, прямо как я. Но тут превзошёл сам себя: тестировщики, мол не должны ничего находить! На кой-они тогда нужны, верно?
На самом деле, мысль его другая: код должен попадать к тестировщику уже тщательно проверенным. И тут я 100% «за».
Сколько раз наблюдал: программист чего-то там наделал, как-то вроде работает, какие-то даже тесты есть. И перебрасывает в тестирование — проверяйте, мол.</description>
    </item>
    
    <item>
      <title>Django и пустые значения</title>
      <link>https://antonz.ru/django-null/</link>
      <pubDate>Thu, 08 Nov 2018 19:01:50 +0000</pubDate>
      
      <guid>https://antonz.ru/django-null/</guid>
      <description>В последние недели жизнь тесно познакомила меня с самым популярным фреймворком для быстрой разработки веб-приложений на Питоне — Django. В нём много любопытного, чем я время от времени намерен делиться ツ
Допустим, у вас в приложении есть сущность «Клиент», а у клиента поле «Имя». Клиенты указывают имя при регистрации, но поскольку это не обязательно — многие предпочитают оставлять поле пустым. Как в таких случаях должно имя храниться в базе данных?</description>
    </item>
    
    <item>
      <title>Алиса, всё грустно</title>
      <link>https://antonz.ru/alice/</link>
      <pubDate>Wed, 22 Aug 2018 07:54:27 +0000</pubDate>
      
      <guid>https://antonz.ru/alice/</guid>
      <description>Голосовой помощник Яндекса — «Алиса» — работает на смартфонах, в автомобилях и в Яндекс-станции. Алиса обладает «навыками»: человек спрашивает и командует, Алиса отвечает и выполняет.
Есть стандартные навыки («какая сейчас погода»). Можно делать собственные: «включи свет», «проверь почту», «закажи пропуск». В теории выглядит красиво.
 У Яндекса целый каталог навыков  Я посмотрел, как «нестандартные» навыки работают на практике. Резюме такое, что для «умного» дома или офиса они совсем не годятся.</description>
    </item>
    
    <item>
      <title>Как понять рекурсию</title>
      <link>https://antonz.ru/recursion/</link>
      <pubDate>Sat, 11 Aug 2018 09:51:13 +0000</pubDate>
      
      <guid>https://antonz.ru/recursion/</guid>
      <description>У программистов есть расхожая шутка:
 Чтобы понять рекурсию, надо понять рекурсию.
 Шутка на самом деле неудачная. Чтобы это увидеть, достаточно перевести её в псевдокод:
def understand_recursion(): understand_recursion() Не хватает важнейшей составляющей — базового случая. В результате получается бесконечная цепочка вызовов. Понятно теперь, почему программисты так лажают в рекурсивных алгоритмах.
Исправим ошибку:
def understand_recursion(myself): if recursion_is_understood(myself): return understand_recursion(myself) Или, переходя на естественный язык:
Чтобы понять рекурсию, надо понимать рекурсию до тех пор, пока не поймёте  И подписывайтесь на  «Oh My Py»</description>
    </item>
    
    <item>
      <title>Синтез и распознавание речи в 50 строк на JavaScript</title>
      <link>https://antonz.ru/speech-api/</link>
      <pubDate>Tue, 07 Aug 2018 12:29:34 +0000</pubDate>
      
      <guid>https://antonz.ru/speech-api/</guid>
      <description>Если вы, как большинство нормальных людей, не следите пристально за развитием веб-API, то вот краткая сводка их успехов в обработке речи.
Синтез речи Вовсю работает в нормальных браузерах. Реализуется в несколько строчек на джаваскрипте:
See the Pen Синтез речи by Anton (@nalgeon) on CodePen.
Функция speak создаёт говорилку и озвучивает переданный текст на русском языке.
Распознавание речи Работает только в хроме и фаерфоксе, причём у каждого по-своему. На андроиде тоже работает, хотя функциональность ограничена по сравнению с десктопом.</description>
    </item>
    
    <item>
      <title>Математика для программиста</title>
      <link>https://antonz.ru/math/</link>
      <pubDate>Mon, 23 Jul 2018 13:03:53 +0000</pubDate>
      
      <guid>https://antonz.ru/math/</guid>
      <description>В университете меня три года пичкали функциональным анализом, дифференциальными уравнениями и теорией функций комплексного переменного. Считаю это преступлением против юности: как и большинству программистов, эти знания никогда не понадобились.
В этой заметке я расскажу, какие (небольшие) кусочки математики действительно пригодятся программисту и как их освоить за несколько месяцев. Если вы уже программируете — можно использовать как чек-лист для самопроверки.
 Иногда математика и вовсе не нужна // xkcd  Сразу скажу, что если вы программируете игры или разрабатываете софт для физиков, медиков или биологов — этого не хватит.</description>
    </item>
    
    <item>
      <title>Сломается всё</title>
      <link>https://antonz.ru/release-it/</link>
      <pubDate>Tue, 19 Dec 2017 12:51:48 +0000</pubDate>
      
      <guid>https://antonz.ru/release-it/</guid>
      <description>(и что с этим делать)
За долгую историю общения с нагруженными сервисами я понял — законы Мерфи работают.
Сломается всё, каждая отдельная часть. Сломается самым изощрённым способом. Сломаются внутренности, о которых ты даже не подозревал, что они существуют.
Сбои невозможно предупредить. Всё что остаётся — минимизировать риски и последствия.
Интересно, что этому никто не учит. Подозреваю, что те кто обычно учат — сами не умеют, а те кто умеют — не любят учить.</description>
    </item>
    
    <item>
      <title>Днище ИТ-безопасности</title>
      <link>https://antonz.ru/it-security/</link>
      <pubDate>Tue, 12 Dec 2017 09:28:51 +0000</pubDate>
      
      <guid>https://antonz.ru/it-security/</guid>
      <description>С подачи Григория Бакунова я прочитал письмо Линуса Торвальдса о разработчиках, пользователях и спецах по информационной безопасности. Оно длинное, но вот самый смак в вольном переводе:
 Когда ты, безопасник, бесишь пользователей и разработчиков — я не приму работу и назову тебя хреновым специалистом.
  Потому что в конце концов, важны именно пользователи. Без них система может быть «безопасной», но вся твоя огораживательная активность — просто мастурбация. В конце концов, ты не сделал ничего полезного.</description>
    </item>
    
    <item>
      <title>Гладкие и шершавые интеграции</title>
      <link>https://antonz.ru/smooth-integration/</link>
      <pubDate>Fri, 10 Nov 2017 10:20:33 +0000</pubDate>
      
      <guid>https://antonz.ru/smooth-integration/</guid>
      <description>Если вы работаете над облачным сервисом, то здоровенная часть пользовательского опыта — «гладкость» интеграции вашего сервиса со всякими другими. На эту часть разработчикам всегда хочется забить (вот ещё, возиться со сторонними сервисами) — а пользователи страдают.
Например, есть Яндекс-касса, которая сама не умеет выписывать чеки, но интегрирована с онлайн-кассами (Атол и Модуль-касса). Вот основной пункт инструкции по подключению:
 Пропишите здесь настройки для интеграции. Их можно скопировать в личном кабинете вашей онлайн-кассы.</description>
    </item>
    
    <item>
      <title>Урл как интерфейс</title>
      <link>https://antonz.ru/url-as-interface/</link>
      <pubDate>Wed, 26 Jul 2017 12:41:03 +0000</pubDate>
      
      <guid>https://antonz.ru/url-as-interface/</guid>
      <description>Для меня урл (URL) на сайте или в веб-приложении — часть интерфейса. Поэтому он должен быть хорош.
Понимаю, что нормальные люди не задумываются об урлах, а в идеале вовсе не знают, что это такое. Но я гик, поэтому хочу красивые и информативные адреса. Если у вас так же — оставайтесь, поговорим о плохих и хороших урлах.
Плохие урлы Начнём с характеристик плохого урла.
Урл не зависит от состояния Пусть есть список клиентов с адресом /customers.</description>
    </item>
    
    <item>
      <title>Программирование без интернета</title>
      <link>https://antonz.ru/programming-without-internet/</link>
      <pubDate>Fri, 10 Feb 2017 15:47:40 +0000</pubDate>
      
      <guid>https://antonz.ru/programming-without-internet/</guid>
      <description>оригинал на xkcd  Топ-3 повседневных вопросов программиста:
 как сделать Х, почему работает так, а не эдак, как назвать переменную.  С третьим вопросом всё понятно — он неразрешим в принципе. С первыми двумя интереснее.
Чтобы получить ответы, программисты девяностых читали исходники и руководства. Программисты двухтысячных начали активно гуглить. А затем в 2008 появился Stack Overflow, и стал «внешней памятью» для разработчиков. Теперь на 95% вопросов есть готовый ответ: первая ссылка из гугла на Стек.</description>
    </item>
    
    <item>
      <title>Как найти программиста: единственный рабочий метод</title>
      <link>https://antonz.ru/find-developer/</link>
      <pubDate>Wed, 28 Sep 2016 08:08:32 +0000</pubDate>
      
      <guid>https://antonz.ru/find-developer/</guid>
      <description>Прежде всего, проверьте рабочее место программиста. Больше всего шансов найти его за монитором. Изредка программист может быть под столом, ковыряться в системном блоке. Если слышите голоса от кофемашины — проверьте там. Программисты любят общаться за кофе с другими программистами. Кто-то пьет вместо кофе чай, а особо отличившиеся — воду. Некоторые просто сидят на диванчике. К сожалению, некоторых программистов стоит поискать в курилке. Не курит? Тогда он в туалете. Со смартфоном это может быть надолго.</description>
    </item>
    
    <item>
      <title>Ричард Хипп и SQLite</title>
      <link>https://antonz.ru/richard-hipp/</link>
      <pubDate>Mon, 30 May 2016 09:07:30 +0000</pubDate>
      
      <guid>https://antonz.ru/richard-hipp/</guid>
      <description>Ричард Хипп — создатель SQLite, самой распространенной в мире базы данных.
В 2001 году Ричард разрабатывал приложение по контракту. В качестве базы в проекте использовался Информикс. Он был кривовато настроен, и иногда падал — тогда приложение не работало. При этом база использовалась только на чтение. Ричард подумал — а зачем тогда клиент-серверная СУБД? Сделал свою встроенную базу — SQLitе, с базовой поддержкой SQL — и приложение перестало зависеть от сервера.</description>
    </item>
    
    <item>
      <title>Главный секрет фронтенд-разработки</title>
      <link>https://antonz.ru/frontend-secret/</link>
      <pubDate>Wed, 30 Mar 2016 08:44:16 +0000</pubDate>
      
      <guid>https://antonz.ru/frontend-secret/</guid>
      <description>Бурный рост фреймворков, библиотек и подходов в джаваскрипт-разработке вызывает объяснимое беспокойство у моих знакомых фронтендеров.
Беда в том, что большинство ребят в веб-разработке очень молодые и не знают главный секрет новых тулов:
Они все сдохнут. И очень скоро.  Поэтому, если вы начинающий разработчик — не переживайте. Выдохните. Закройте эти пятьдесят вкладочек в браузере с «полезными ссылками для веб-разработчика». Отпишитесь от еженедельных рассылок. Не читайте в твитере гуру веб-разработки, они пишут не для вас.</description>
    </item>
    
    <item>
      <title>Миф о сложности Oracle Database</title>
      <link>https://antonz.ru/oracle-myth/</link>
      <pubDate>Sun, 21 Sep 2014 16:19:42 +0000</pubDate>
      
      <guid>https://antonz.ru/oracle-myth/</guid>
      <description>Участвовали когда-нибудь в разработке корпоративного софта? Тогда вы знаете, что Оракл — это такая мегасложная система управления базами данных. Разработчик приложения, которое читает и пишет данные в БД Оракл, имеет минимум 3 года опыта и сертификат. Этого недостаточно, поэтому приложение тормозит уже на 10 пользователях и 5000 записей в базе. Чтобы оптимизировать производительность или настроить БД, нужен совсем другой человек. У него 15 лет стажа, 50 сертификатов и непривлекательные залысины с бифокальными очками.</description>
    </item>
    
    <item>
      <title>Картоха, урлы и состояние</title>
      <link>https://antonz.ru/urls-state-potatoes/</link>
      <pubDate>Thu, 15 May 2014 20:44:26 +0000</pubDate>
      
      <guid>https://antonz.ru/urls-state-potatoes/</guid>
      <description>Если вы разрабатываете веб-приложение, то рано или поздно столкнетесь с проблемой сохранения текущего состояния системы для пользователя.
Например, вы продаете через интернет элитный картофель. Покупатель заходит на сайт и первым делом настраивает условия отбора картофелин: строго из Боливии или ЮАР, урожая 2013 года, размер клубня от 3 до 7 см, желательно в форме морского тюленя. Получает список из 300 позиций (да, в ЮАР очень популярна картоха в форме тюленя), нарезанный на 6 страниц из 50 элементов каждая.</description>
    </item>
    
  </channel>
</rss>
