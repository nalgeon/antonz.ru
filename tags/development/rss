<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>разработка on Антон Жиянов</title>
    <link>https://antonz.ru/tags/development/</link>
    <description>Recent content in разработка on Антон Жиянов</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ru-ru</language>
    <lastBuildDate>Thu, 11 Nov 2021 16:18:00 +0000</lastBuildDate><atom:link href="https://antonz.ru/tags/development/rss" rel="self" type="application/rss+xml" />
    <item>
      <title>Как на самом деле устроен список в Python</title>
      <link>https://antonz.ru/list-internals/</link>
      <pubDate>Thu, 11 Nov 2021 16:18:00 +0000</pubDate>
      
      <guid>https://antonz.ru/list-internals/</guid>
      <description>Эта заметка посвящена структуре данных номер один в мире — массивам. Если вы еще не гуру алгоритмов и структур данных — гарантирую, что лучше поймете списки в питоне, их преимущества и ограничения. А если и так все знаете — освежите ключевые моменты.
Все знают, как работать со списком в питоне:
&amp;gt;&amp;gt;&amp;gt; guests = [&amp;#34;Френк&amp;#34;, &amp;#34;Клер&amp;#34;, &amp;#34;Зоя&amp;#34;] &amp;gt;&amp;gt;&amp;gt; guests[1] &amp;#39;Клер&amp;#39; Наверняка вы знаете, что выборка элемента по индексу — guests[idx] — отработает очень быстро даже на списке из миллиона элементов.</description>
    </item>
    
    <item>
      <title>Как хранят данные в браузере</title>
      <link>https://antonz.ru/browser-storage/</link>
      <pubDate>Sun, 26 Sep 2021 09:36:07 +0000</pubDate>
      
      <guid>https://antonz.ru/browser-storage/</guid>
      <description>Поговорим о том, как люди хранили данные в браузере, от мохнатой древности до нашего времени.
1. Куки Первые инженеры, едва переодевшись из шкур в неопрятные свитера, попытались использовать родной и привычный HTTP-протокол. Проблема в том, что он не хранит состояние (stateless) — пять запросов от Алисы выглядят точно так же, как пять запросов от пяти разных людей.
Что же делать? В любой непонятной ситуации придумывай костыль! Так появились куки (cookie). Это пары строк (ключ — значение), которые браузер гоняет на сервер с каждым запросом.</description>
    </item>
    
    <item>
      <title>Главный критерий хорошего кода</title>
      <link>https://antonz.ru/good-code/</link>
      <pubDate>Wed, 02 Jun 2021 07:27:39 +0000</pubDate>
      
      <guid>https://antonz.ru/good-code/</guid>
      <description>Хороший код — понятный и непрожорливый до ресурсов. Давайте поговорим об этом.
Время на понимание Главный критерий хорошего кода — это время T, которое требуется не-автору, чтобы разобраться в коде. Причем разобраться не на уровне «вроде понятно», а достаточно хорошо, чтобы внести изменения и ничего не сломать.
Чем меньше T, тем лучше код.
Допустим, Нина и Витя реализовали одну и ту же фичу, а вы хотите ее доработать. Если разберетесь в коде Нины за 10 минут, а в коде Вити за 30 минут — код Нины лучше.</description>
    </item>
    
    <item>
      <title>Второй язык для питониста</title>
      <link>https://antonz.ru/python-plus-one/</link>
      <pubDate>Sun, 09 May 2021 12:15:13 +0000</pubDate>
      
      <guid>https://antonz.ru/python-plus-one/</guid>
      <description>Если вы давно и хорошо знаете питон, некоторые моменты в нем могут напрягать. Например, необходимость начинать каждый новый проект с создания виртуального окружения и установки пачки тулов вроде black, pylint и pytest. Или отсутствующий рефакторинг и частые ошибки из-за динамической типизации. Или убоговатая асинхронность и костыль в виде GIL.
Если у вас так — возможно, пора освоить второй язык. Логично выбрать вариант без питонячих недостатков: статически типизированный, с готовым тулингом, продуманной асинхронностью и параллелизмом.</description>
    </item>
    
    <item>
      <title>​Шпаргалки как альтернатива man</title>
      <link>https://antonz.ru/cheat-sh/</link>
      <pubDate>Fri, 23 Apr 2021 10:46:01 +0000</pubDate>
      
      <guid>https://antonz.ru/cheat-sh/</guid>
      <description>Я вечно забываю синтаксис линуксовых утилит вроде grep, sed и find. Есть команда man, которая показывает документацию по утилите, но для меня она совершенно бесполезна — никогда не получается найти то, что нужно (возможно, это только я такой тупой).
Поэтому был бесконечно счастлив, когда на днях нашел приятную альтернативу от Игоря Чубина — «шпаргалки» с конкретными примерами. Чтобы их включить, достаточно добавить такую функцию в .bashrc:
function cht() { curl &amp;quot;cht.</description>
    </item>
    
    <item>
      <title>Собираем открытые данные с GitHub Actions</title>
      <link>https://antonz.ru/github-actions-scraping/</link>
      <pubDate>Fri, 12 Mar 2021 14:12:59 +0000</pubDate>
      
      <guid>https://antonz.ru/github-actions-scraping/</guid>
      <description>GitHub Actions чаще всего используют для сборки и тестов, но вообще сервис подходит для любой автоматизации.
В этой заметке я расскажу:
 как собрать данные из API, опубликовать датасет на гитхабе, и автоматически актуализировать.  В результате получится идеальный инструмент для сбора и публикации открытых данных.
Будем работать с API станций метро, которое предоставляет HeadHunter. Я буду приводить фрагменты конфига для GitHub Actions, а в конце дам ссылку на готовый репозиторий.</description>
    </item>
    
    <item>
      <title>Простое против легкого</title>
      <link>https://antonz.ru/simple-made-easy/</link>
      <pubDate>Fri, 26 Feb 2021 12:55:15 +0000</pubDate>
      
      <guid>https://antonz.ru/simple-made-easy/</guid>
      <description>9 лет назад в докладе «Simple Made Easy» Рич Хикки рассказал о разнице между простым (simple) и легким (easy) в разработке софта. Стремление к простым программам (в противоположность легким) — самый важный, наверное, принцип разработки. И при этом совершенно непопулярный.
 Simple — это о внутреннем устройстве программы, ее архитектуре. У простых программ мало внутренних зависимостей, движущихся частей, настроек. Антипод простой программы — сложная. Простая программа или сложная — это объективная характеристика.</description>
    </item>
    
    <item>
      <title>Кросс-платформенная сборка с GitHub Actions</title>
      <link>https://antonz.ru/github-actions/</link>
      <pubDate>Thu, 11 Feb 2021 13:34:09 +0000</pubDate>
      
      <guid>https://antonz.ru/github-actions/</guid>
      <description>Если проект живет на GitHub, можно за десять минут настроить авто-сборку под основные операционные системы — Windows, Linux и macOS.
Раньше для сборки почти всегда использовали Travis CI, многие по инерции и сейчас так делают. Но есть способ лучше — GitHub Actions.
GitHub Actions — невероятно мощный бесплатный сервис автоматизации любых задач. Грубо говоря, вы выполняете свой код на серверах Гитхаба и делаете там все, что заблагорассудится. Звучит диковато, но открывает бездну возможностей.</description>
    </item>
    
    <item>
      <title>Плохая и хорошая документация языка</title>
      <link>https://antonz.ru/language-doc/</link>
      <pubDate>Mon, 06 Jul 2020 09:08:48 +0000</pubDate>
      
      <guid>https://antonz.ru/language-doc/</guid>
      <description>Язык Go не отличается красотой. Кто-то называет его «намеренно простым», кто-то уродливым. Но с чем у Go действительно всё классно — так это с документацией. Там много хорошего, но вот главное, на мой взгляд:
 A Tour of Go — интерактивное введение в язык. Effective Go — книга о том, как писать идиоматичный код на Go. Ссылки из документации на исходники каждой функции стандартной библиотеки (например, Max).  Для сравнения я взял топ-10 языков из StackOverflow Developer Survey и посмотрел, как у них дела с этими тремя пунктами.</description>
    </item>
    
    <item>
      <title>Красавица и чудовище. Обработка ошибок в Go</title>
      <link>https://antonz.ru/go-errors/</link>
      <pubDate>Thu, 04 Jun 2020 14:11:07 +0000</pubDate>
      
      <guid>https://antonz.ru/go-errors/</guid>
      <description>Роб Пайк сказал об ошибках в го:
 Explicit error checking forces the programmer to think about errors — and deal with them — when they arise.
 Это правда. Но не вся.
Допустим, я хочу прочитать список целых чисел из текстового файла. Вот как можно сделать это на питоне:
def read_numbers(filename): return [int(line.strip()) for line in open(filename)] Или, в более процедурном стиле:
def read_numbers(filename): numbers = [] for line in open(filename): num = int(line.</description>
    </item>
    
  </channel>
</rss>
