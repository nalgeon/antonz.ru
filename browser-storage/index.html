<!doctype html><html lang=en>
<head><meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1">
<meta name=yandex-verification content="166c4872c92b3261">
<meta name=google-site-verification content="RDIpvK7QdMQQUb3kxVN3FAjfDdKdfHQSyGVfLb-GaPU">
<title>Как хранят данные в браузере</title>
<meta name=description content="От мохнатой древности до нашего времени.">
<meta name=robots content="index, follow">
<link rel=stylesheet type=text/css href=/assets/css/style.7e4c5f3f192fd25b5982f92aad85dd80d7b6d2b5d719b89aeb4ab01138fb00a0.css>
<link rel=icon href=/assets/favicon/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=/assets/favicon/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=/assets/favicon/favicon-32x32.png>
<link rel=apple-touch-icon href=/assets/favicon/apple-touch-icon.png>
<link rel=mask-icon href=/assets/favicon/safari-pinned-tab.svg>
<meta name=theme-color content="#fff">
<meta name=msapplication-TileColor content="#fff">
<link rel=canonical href=https://antonz.ru/browser-storage/>
<meta name=author content="Антон Жиянов">
<meta property="og:site_name" content="Антон Жиянов">
<meta property="og:type" content="article">
<meta property="og:title" content="Как хранят данные в браузере">
<meta property="og:description" content="От мохнатой древности до нашего времени.">
<meta property="og:url" content="https://antonz.ru/browser-storage/">
<meta property="og:image" content="https://antonz.ru/browser-storage/cover.png">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:title content="Как хранят данные в браузере">
<meta name=twitter:description content="От мохнатой древности до нашего времени.">
<meta name=twitter:url content="https://antonz.ru/browser-storage/">
<meta name=twitter:site content="@nalgeon">
<meta name=twitter:image content="https://antonz.ru/browser-storage/cover.png"></head>
<body>
<div class=header>
<div class=container>
<div class=row>
<div class="col-xs-6 col-sm-3">
<a class=img-link href=/>
<img src=/assets/antonz.jpg class=header-icon>
</a> 
<a href=/>
<strong>Антон Жиянов</strong>
</a>
</div>
<div class="col-xs-12 col-sm-6 col-md-4 hidden-mobile">
<a class=menu__link href=/projects/>
<span>проекты</span>
</a>
<a class=menu__link href=/all/>
<span>блог</span>
</a>
<a class=menu__link href=/#about>
<span>контакты</span>
</a>
<a class=menu__link href=https://antonz.org>
<span>en</span>
</a>
</div>
<div class="col-xs-6 col-sm-3"><div class=search-module>
<form action=https://antonz.ru/search/ method=get target=_self accept-charset=utf-8>
<input type=hidden name=searchid value=2403959>
<input type=hidden name=l10n value=ru>
<input type=hidden name=reqenc>
<input type=search name=text placeholder="поиск по сайту">
</form>
</div></div>
</div>
</div>
</div>
<div class=storey>
<div class=container>
<article class=post>
<div class=row>
<div class="col-xs-12 col-sm-10 article article--big">
<header>
<h1 class=post__title>Как хранят данные в браузере</h1>
</header>
<p>Поговорим о том, как люди хранили данные в браузере, от мохнатой древности до нашего времени.</p>
<h2 id=1-куки>1. Куки</h2>
<p>Первые инженеры, едва переодевшись из шкур в неопрятные свитера, попытались использовать родной и привычный HTTP-протокол. Проблема в том, что он не хранит состояние (stateless) — пять запросов от Алисы выглядят точно так же, как пять запросов от пяти разных людей.</p>
<p>Что же делать? В любой непонятной ситуации придумывай костыль! Так появились <em>куки</em> (cookie). Это пары строк (ключ — значение), которые браузер гоняет на сервер с каждым запросом. Таким образом stateless протокол внезапно становится немножко stateful.</p>
<figure>
<img alt=Куки class=img-bordered-thin src=storage-cookies.png>
</figure>
<p>Куки хороши тем, что доступны и на клиенте, и на сервере. Когда вы ходите по страницам интернет-магазина и складываете товары в корзину, браузер с каждым запросом передает в куках идентификатор сессии. По нему сервер магазина понимает, что товары относятся именно к вашей корзине.</p>
<p>Куку может установить не только тот сайт, на котором вы находитесь, но и вообще любой (так называемые third-party cookies). Этим немедленно воспользовались хитрозадые рекламодатели. Если на сайте магазина подключен фейсбук, а вы купили ботинки — теперь до конца жизни будете видеть рекламу ботинок на всех сайтах, подключенных к фейсбуку.</p>
<p>Third-party cookies можно отключить в настройках браузера, а в Сафари они даже отключены по умолчанию. Рекомендую это сделать. Правда, некоторые особенно кривые сайты при этом перестанут работать — но оно и к лучшему, как по мне.</p>
<p>Работа с куками в JS реализована традиционно для веба — максимально неудобно. <code>document.cookie</code> — это все куки, склеенные в одну строку через точку с запятой. Наслаждайтесь парсингом.</p>
<p>Вообще, о куках можно еще много плохого рассказать. Делать этого я, конечно, не буду.</p>
<p><a href=https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies>Куки на MDN</a></p>
<h2 id=2-web-storage>2. Web Storage</h2>
<p>Постепенно разработчики поняли, что надо оставить HTTP в покое и сделать нормальное API хранения данных в браузере. Так появились <em>localStorage</em> и <em>sessionStorage</em> с очень простым интерфейсом:</p>
<ul>
<li>получить значение по ключу,</li>
<li>записать значение по ключу,</li>
<li>удалить значение по ключу.</li>
</ul>
<p>localStorage хранит данные вечно, а sessionStorage — только пока открыта вкладка браузера. local свой у каждого домена, чужие данные посмотреть не получится. А session отдельный у каждой вкладки. Максимальный размер базы — несколько мегабайт.</p>
<figure>
<img alt="Web Storage" class=img-bordered-thin src=storage-webstorage.png>
</figure>
<p>И ключи, и значения — только строки, так что числа, массивы и объекты приходится превращать в строку перед сохранением. И парсить из строки при выборке. Обычно не заморачиваются и используют <code>JSON.stringify</code> / <code>JSON.parse</code>.</p>
<p>sessionStorage редко используют, а вот localStorage весьма популярен. Простой, удобный, быстрый — что еще надо:</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#a90d91>let</span> <span style=color:#000>obj</span> <span style=color:#000>=</span> { <span style=color:#000>a</span><span style=color:#000>:</span> <span style=color:#1c01ce>42</span> };
<span style=color:#a90d91>let</span> <span style=color:#000>objStr</span> <span style=color:#000>=</span> <span style=color:#000>JSON</span>.<span style=color:#000>stringify</span>(<span style=color:#000>obj</span>);
<span style=color:#000>localStorage</span>.<span style=color:#000>setItem</span>(<span style=color:#c41a16>&#34;q&#34;</span>, <span style=color:#000>objStr</span>);

<span style=color:#a90d91>let</span> <span style=color:#000>objStr</span> <span style=color:#000>=</span> <span style=color:#000>localStorage</span>.<span style=color:#000>getItem</span>(<span style=color:#c41a16>&#34;q&#34;</span>);
<span style=color:#000>JSON</span>.<span style=color:#000>parse</span>(<span style=color:#000>objStr</span>);
<span style=color:#177500>// {a: 42}
</span></code></pre></div><p>Ребята из команды Chrome рекомендуют вместо Web Storage использовать более новый механизм — IndexedDB. Это, мягко говоря, странный совет — но о своеобразном подходе разработчиков браузеров мы еще поговорим.</p>
<p><a href=https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API>Web Storage на MDN</a></p>
<h2 id=3-web-sql>3. Web SQL</h2>
<p>Постепенно разработчики дозрели до полноценной базы данных в браузере. Надо сказать, что абсолютно во всех браузерах — что мобильных, что десктопных — уже встроена отличная СУБД, которая реализует стандарт SQL-92 (и большой кусок более поздних стандартов) — <a href=https://sqlite.org/>SQLite</a>.</p>
<figure>
<img alt="Web SQL" class=img-bordered-thin src=storage-websql.png>
</figure>
<p>Казалось бы, придумай удобный интерфейс поверх SQLite, согласуй со всеми и вперед — что может быть логичнее? Собственно, в конце нулевых так и сделали — новый стандарт <em>Web SQL</em> поддержали Apple (Safari), Google (Chrome) и Opera (еще популярная тогда). А Mozilla (Firefox) — нет.</p>
<p>Замечательные люди из Мозиллы заявили, что:</p>
<ol>
<li>Использовать SQL в вебе некрасиво, у веба свой путь.</li>
<li>Где это видано, всем использовать SQLite, вместо того, чтобы каждый браузер напилил свой велосипед.</li>
</ol>
<p>Классные аргументы, да? Очень характерно для веба.</p>
<p>В результате Web SQL убили, использовать его сейчас нельзя. А элегантное решение, которое гении из Мозиллы породили ему на замену (IndexedDB), я вам скоро покажу.</p>
<div class=boxed style=margin-bottom:.8em>
<p><strong>🤔 SQL в браузере</strong></p>
<p>Если интересно, как может работать настоящий SQL в браузере — попробуйте онлайн-песочницу <strong><a href=https://sqlime.org/>sqlime</a></strong>. Там можно подключить любую SQLite-базу или создать новую с нуля и делать к ней запросы прямо из браузера.</p>
</div>
<p><a href=https://docs.tizen.org/application/web/guides/w3c/storage/websql/>Документация по Web SQL</a> (для полноты картины)</p>
<h2 id=4-indexed-database>4. Indexed Database</h2>
<p>Ну уж тут-то разработчики браузеров развернулись. <em>IndexedDB</em> — это настоящая NoSQL-база данных у вас в браузере. Можно сделать полноценное приложение, которое шустро ворочает сотнями мегабайт данных, не обращаясь к серверу. Прямо на вашем айфоне, мухаха.</p>
<p>Начнем с хорошего в IndexedDB:</p>
<ul>
<li>есть коллекции (аналог таблиц в реляционных БД), индексы и транзакции;</li>
<li>без проблем хранит массивы и объекты;</li>
<li>поддерживает версионирование схемы данных;</li>
<li>(условно) неограниченный размер базы;</li>
<li>работает асинхронно.</li>
</ul>
<figure>
<img alt="Indexed Database" class=img-bordered-thin src=storage-indexeddb.png>
</figure>
<p>А теперь о плохом:</p>
<blockquote class=big><p>всё очень сложно</p></blockquote>
<p>Никаких вам get / set, будьте любезны освоить многочисленные концепции, приемы и особенности работы, чтобы записать свой несчастный объект в базу и получить его обратно. Уверен, вы просто мечтали освоить еще одну СУБД. Ваши мечты сбылись.</p>
<figure>
<img alt="Код для IndexedDB" class=img-bordered-thin src=storage-indexeddb-tutotial.png>
<figcaption>Картинка из туториала по IndexedDB, для вдохновения. Пришлось уменьшить масштаб, а то на экран не влезала.</figcaption>
</figure>
<p>Ах, и еще. В вебе есть стандарт асинхронной работы — механизм промисов (promise) и async / await. Так вот, IndexedDB его не поддерживает. Потому что fuck you, that&rsquo;s why. Используйте костылики (<a href=https://github.com/jakearchibald/idb>idb</a>) — это ведь так элегантно.</p>
<p><a href=https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API>IndexedDB на MDN</a></p>
<h2 id=5-cache-api>5. Cache API</h2>
<p>Допустим, у вас веб-приложение для заметок. Было бы здорово, чтобы оно работало даже когда нет сети, верно?</p>
<p>Сами заметки можно хранить в localStorage или IndexedDB. Но что делать, если человек обновит страницу, а сети нет? Тут и пригодится <em>Cache API</em>.</p>
<p>Cache API создан, чтобы хранить не данные приложения, а сетевые запросы и ответы. Обычно это файлы приложения — все ваши <code>*.html</code>, <code>*.css</code> и <code>*.js</code></p>
<p>Если сохранить файлы в кеш, то в офлайн-режиме можно перехватить запросы и вернуть их из кеша, когда человек обновит страницу. За перехват отвечает другой механизм — service worker, о нем не будем.</p>
<p>Cache API простой и асинхронный, одно удовольствие:</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#a90d91>const</span> <span style=color:#000>cache</span> <span style=color:#000>=</span> <span style=color:#a90d91>await</span> <span style=color:#000>caches</span>.<span style=color:#000>open</span>(<span style=color:#c41a16>&#34;app&#34;</span>);
<span style=color:#a90d91>await</span> <span style=color:#000>cache</span>.<span style=color:#000>add</span>(<span style=color:#c41a16>&#34;/app.js&#34;</span>);
<span style=color:#a90d91>const</span> <span style=color:#000>resp</span> <span style=color:#000>=</span> <span style=color:#a90d91>await</span> <span style=color:#000>cache</span>.<span style=color:#000>match</span>(<span style=color:#c41a16>&#34;/app.js&#34;</span>);
</code></pre></div><p><code>.add()</code> сам запросит указанный файл и сложит ответ в кеш, такой заботливый.</p>
<p>Возможно, вы ожидаете, что Cache API умеет очищать старые или редко используемые записи (на то он и кеш). Но нет! Это веб, так что решите вопрос как-нибудь самостоятельно.</p>
<p>На самом деле, никто не мешает использовать кеш и для данных приложения. Но так обычно не делают:</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#a90d91>const</span> <span style=color:#000>data</span> <span style=color:#000>=</span> { <span style=color:#000>a</span><span style=color:#000>:</span> <span style=color:#1c01ce>42</span> };
<span style=color:#a90d91>let</span> <span style=color:#000>resp</span> <span style=color:#000>=</span> <span style=color:#a90d91>new</span> <span style=color:#000>Response</span>(<span style=color:#000>JSON</span>.<span style=color:#000>stringify</span>(<span style=color:#000>data</span>));
<span style=color:#a90d91>await</span> <span style=color:#000>cache</span>.<span style=color:#000>put</span>(<span style=color:#c41a16>&#34;data.json&#34;</span>, <span style=color:#000>resp</span>);

<span style=color:#000>resp</span> <span style=color:#000>=</span> <span style=color:#a90d91>await</span> <span style=color:#000>cache</span>.<span style=color:#000>match</span>(<span style=color:#c41a16>&#34;data.json&#34;</span>);
<span style=color:#a90d91>await</span> <span style=color:#000>resp</span>.<span style=color:#000>json</span>();
<span style=color:#177500>// { a: 42 }
</span></code></pre></div><p><a href=https://developer.mozilla.org/en-US/docs/Web/API/Cache>Cache API на MDN</a></p>
<h2 id=6-storage-api>6. Storage API</h2>
<p><em>Storage API</em> на самом деле ничего не хранит (обожаю веб). Вместо этого оно сообщает, сколько места занято вашим барахлом и сколько всего доступно.</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#a90d91>const</span> {<span style=color:#000>usage</span>, <span style=color:#000>quota</span>} <span style=color:#000>=</span> <span style=color:#a90d91>await</span> <span style=color:#000>navigator</span>.<span style=color:#000>storage</span>.<span style=color:#000>estimate</span>();
</code></pre></div><p><code>usage</code> и <code>quota</code> считаются суммарно по всем видам хранилищ — Web Storage, IndexedDB и CacheAPI.</p>
<p>А ещё можно сообщить браузеру, что ваши данные ну очень ценные, и молча удалять их никак нельзя, только с разрешения человека:</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=color:#000>navigator</span>.<span style=color:#000>storage</span>.<span style=color:#000>persist</span>()
</code></pre></div><p>Storage API пока не работает в Safari. Увы.</p>
<p><a href=https://developer.mozilla.org/en-US/docs/Web/API/Storage_API>Storage API на MDN</a></p>
<h2 id=7-file-whatever-api>7. File (whatever) API</h2>
<p>Пара замечательных API с интуитивно понятными названиями: <em>File System Access API</em> и <em>File and Directory Entries API</em>.</p>
<p>Когда-нибудь они позволят вам писать файлы прямо на устройство пользователя. Но пока совсем сырые, так что не будем на них останавливаться.</p>
<h2 id=очень-краткие-выводы>Очень краткие выводы</h2>
<ul>
<li>Web Storage для мелочевки</li>
<li>IndexedDB для серьезных данных</li>
<li>Cache API для файлов и запросов</li>
</ul>
<p>Куки оставьте Цукербергу, Web SQL погиб молодым, File * API ещё не родились, а Storage API считает место.</p>
<p><em>И подписывайтесь на <a href=https://twitter.com/nalgeon>@nalgeon</a> в твитере, чтобы не пропустить новые заметки</em> 🚀</p>
</div>
</div><footer class=post__footer>
<div class=row>
<div class=col-xs-12>
<div class=post__date>
<time datetime="2021-09-26 09:36:07 +0000 UTC">26.09.2021</time>
</div>
<div class=post__tags>
<a href=https://antonz.ru/tags/data/>данные</a>&nbsp;
<a href=https://antonz.ru/tags/development/>разработка</a>&nbsp;
</div>
</div>
</div>
</footer></article>
<aside class=post__related>
<div class=article>
<div class=row>
<div class="col-xs-12 col-sm-6">
<p>&larr;&nbsp;<a href=https://antonz.ru/acknowledge/>Признать проблему</a></p>
</div>
<div class="col-xs-12 col-sm-6">
<p><a href=https://antonz.ru/sqlime/>SQLite-песочница в браузере</a>&nbsp;&rarr;</p>
</div>
</div>
</div>
<div class=article>
<div class=row>
<div class="col-xs-12 col-sm-8 col-md-6">
<h3>Ещё по теме</h3>
<p><a href=/oracle-myth/>Миф о сложности Oracle Database</a></p>
<p><a href=/sql-groups/>Найти группы похожих объектов с помощью SQL</a></p>
<p><a href=/good-code/>Главный критерий хорошего кода</a></p>
</div>
</div>
</div>
</aside>
<script src=https://utteranc.es/client.js repo=nalgeon/comments.antonz.ru issue-term=pathname theme=github-light crossorigin=anonymous async></script></div>
</div>
<footer class="container footer">
<ul class=naked-list>
<li class=footer__item>Подписаться:
<a href=https://twitter.com/nalgeon class=footer__social-link><i class="fab fa-twitter"></i><span>Твиттер</span></a>
<a href=https://www.facebook.com/nalgeon class=footer__social-link><i class="fab fa-facebook-f"></i><span>Фейсбук</span></a>
<a href=/rss class=footer__social-link><i class="fas fa-rss"></i><span>RSS</span></a>
</li>
<li class=footer__item>Почта: <a href=mailto:m@antonz.ru>m@antonz.ru</a></li>
<li class=footer__item>и приходите в
<a class=footer__link href=https://career.hflabs.ru/>HFLabs</a>
</li>
</ul>
</footer>
<script async src=//gc.zgo.at/count.js data-goatcounter=https://antonzru.goatcounter.com/count></script></body>
</html>